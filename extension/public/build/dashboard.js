var app = (function () {
	'use strict';

	/** @returns {void} */
	function noop() {}

	const identity = (x) => x;

	/**
	 * @template T
	 * @template S
	 * @param {T} tar
	 * @param {S} src
	 * @returns {T & S}
	 */
	function assign(tar, src) {
		// @ts-ignore
		for (const k in src) tar[k] = src[k];
		return /** @type {T & S} */ (tar);
	}

	/** @returns {void} */
	function add_location(element, file, line, column, char) {
		element.__svelte_meta = {
			loc: { file, line, column, char }
		};
	}

	function run(fn) {
		return fn();
	}

	function blank_object() {
		return Object.create(null);
	}

	/**
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function run_all(fns) {
		fns.forEach(run);
	}

	/**
	 * @param {any} thing
	 * @returns {thing is Function}
	 */
	function is_function(thing) {
		return typeof thing === 'function';
	}

	/** @returns {boolean} */
	function safe_not_equal(a, b) {
		return a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';
	}

	let src_url_equal_anchor;

	/**
	 * @param {string} element_src
	 * @param {string} url
	 * @returns {boolean}
	 */
	function src_url_equal(element_src, url) {
		if (element_src === url) return true;
		if (!src_url_equal_anchor) {
			src_url_equal_anchor = document.createElement('a');
		}
		// This is actually faster than doing URL(..).href
		src_url_equal_anchor.href = url;
		return element_src === src_url_equal_anchor.href;
	}

	/** @returns {boolean} */
	function is_empty(obj) {
		return Object.keys(obj).length === 0;
	}

	/** @returns {void} */
	function validate_store(store, name) {
		if (store != null && typeof store.subscribe !== 'function') {
			throw new Error(`'${name}' is not a store with a 'subscribe' method`);
		}
	}

	function subscribe(store, ...callbacks) {
		if (store == null) {
			for (const callback of callbacks) {
				callback(undefined);
			}
			return noop;
		}
		const unsub = store.subscribe(...callbacks);
		return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	/**
	 * Get the current value from a store by subscribing and immediately unsubscribing.
	 *
	 * https://svelte.dev/docs/svelte-store#get
	 * @template T
	 * @param {import('../store/public.js').Readable<T>} store
	 * @returns {T}
	 */
	function get_store_value(store) {
		let value;
		subscribe(store, (_) => (value = _))();
		return value;
	}

	/** @returns {void} */
	function component_subscribe(component, store, callback) {
		component.$$.on_destroy.push(subscribe(store, callback));
	}

	function action_destroyer(action_result) {
		return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
	}

	/** @param {number | string} value
	 * @returns {[number, string]}
	 */
	function split_css_unit(value) {
		const split = typeof value === 'string' && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
		return split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];
	}

	const is_client = typeof window !== 'undefined';

	/** @type {() => number} */
	let now = is_client ? () => window.performance.now() : () => Date.now();

	let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;

	const tasks = new Set();

	/**
	 * @param {number} now
	 * @returns {void}
	 */
	function run_tasks(now) {
		tasks.forEach((task) => {
			if (!task.c(now)) {
				tasks.delete(task);
				task.f();
			}
		});
		if (tasks.size !== 0) raf(run_tasks);
	}

	/**
	 * Creates a new task that runs on each raf frame
	 * until it returns a falsy value or is aborted
	 * @param {import('./private.js').TaskCallback} callback
	 * @returns {import('./private.js').Task}
	 */
	function loop(callback) {
		/** @type {import('./private.js').TaskEntry} */
		let task;
		if (tasks.size === 0) raf(run_tasks);
		return {
			promise: new Promise((fulfill) => {
				tasks.add((task = { c: callback, f: fulfill }));
			}),
			abort() {
				tasks.delete(task);
			}
		};
	}

	/** @type {typeof globalThis} */
	const globals =
		typeof window !== 'undefined'
			? window
			: typeof globalThis !== 'undefined'
			? globalThis
			: // @ts-ignore Node typings have this
			  global;

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */
	function append(target, node) {
		target.appendChild(node);
	}

	/**
	 * @param {Node} node
	 * @returns {ShadowRoot | Document}
	 */
	function get_root_for_style(node) {
		if (!node) return document;
		const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
		if (root && /** @type {ShadowRoot} */ (root).host) {
			return /** @type {ShadowRoot} */ (root);
		}
		return node.ownerDocument;
	}

	/**
	 * @param {Node} node
	 * @returns {CSSStyleSheet}
	 */
	function append_empty_stylesheet(node) {
		const style_element = element('style');
		// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,
		// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.
		// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.
		// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.
		// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.
		style_element.textContent = '/* empty */';
		append_stylesheet(get_root_for_style(node), style_element);
		return style_element.sheet;
	}

	/**
	 * @param {ShadowRoot | Document} node
	 * @param {HTMLStyleElement} style
	 * @returns {CSSStyleSheet}
	 */
	function append_stylesheet(node, style) {
		append(/** @type {Document} */ (node).head || node, style);
		return style.sheet;
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */
	function insert(target, node, anchor) {
		target.insertBefore(node, anchor || null);
	}

	/**
	 * @param {Node} node
	 * @returns {void}
	 */
	function detach(node) {
		if (node.parentNode) {
			node.parentNode.removeChild(node);
		}
	}

	/**
	 * @returns {void} */
	function destroy_each(iterations, detaching) {
		for (let i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d(detaching);
		}
	}

	/**
	 * @template {keyof HTMLElementTagNameMap} K
	 * @param {K} name
	 * @returns {HTMLElementTagNameMap[K]}
	 */
	function element(name) {
		return document.createElement(name);
	}

	/**
	 * @template {keyof SVGElementTagNameMap} K
	 * @param {K} name
	 * @returns {SVGElement}
	 */
	function svg_element(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	/**
	 * @param {string} data
	 * @returns {Text}
	 */
	function text(data) {
		return document.createTextNode(data);
	}

	/**
	 * @returns {Text} */
	function space() {
		return text(' ');
	}

	/**
	 * @returns {Text} */
	function empty() {
		return text('');
	}

	/**
	 * @param {EventTarget} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @returns {() => void}
	 */
	function listen(node, event, handler, options) {
		node.addEventListener(event, handler, options);
		return () => node.removeEventListener(event, handler, options);
	}

	/**
	 * @returns {(event: any) => any} */
	function prevent_default(fn) {
		return function (event) {
			event.preventDefault();
			// @ts-ignore
			return fn.call(this, event);
		};
	}

	/**
	 * @returns {(event: any) => any} */
	function stop_propagation(fn) {
		return function (event) {
			event.stopPropagation();
			// @ts-ignore
			return fn.call(this, event);
		};
	}

	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */
	function attr(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
	}

	/**
	 * @param {Element} element
	 * @returns {ChildNode[]}
	 */
	function children(element) {
		return Array.from(element.childNodes);
	}

	/**
	 * @returns {void} */
	function set_input_value(input, value) {
		input.value = value == null ? '' : value;
	}

	/**
	 * @returns {void} */
	function set_style(node, key, value, important) {
		if (value == null) {
			node.style.removeProperty(key);
		} else {
			node.style.setProperty(key, value, '');
		}
	}

	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]
	 * @returns {CustomEvent<T>}
	 */
	function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
		return new CustomEvent(type, { detail, bubbles, cancelable });
	}

	/**
	 * @typedef {Node & {
	 * 	claim_order?: number;
	 * 	hydrate_init?: true;
	 * 	actual_end_child?: NodeEx;
	 * 	childNodes: NodeListOf<NodeEx>;
	 * }} NodeEx
	 */

	/** @typedef {ChildNode & NodeEx} ChildNodeEx */

	/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */

	/**
	 * @typedef {ChildNodeEx[] & {
	 * 	claim_info?: {
	 * 		last_index: number;
	 * 		total_claimed: number;
	 * 	};
	 * }} ChildNodeArray
	 */

	// we need to store the information for multiple documents because a Svelte application could also contain iframes
	// https://github.com/sveltejs/svelte/issues/3624
	/** @type {Map<Document | ShadowRoot, import('./private.d.ts').StyleInformation>} */
	const managed_styles = new Map();

	let active = 0;

	// https://github.com/darkskyapp/string-hash/blob/master/index.js
	/**
	 * @param {string} str
	 * @returns {number}
	 */
	function hash(str) {
		let hash = 5381;
		let i = str.length;
		while (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
		return hash >>> 0;
	}

	/**
	 * @param {Document | ShadowRoot} doc
	 * @param {Element & ElementCSSInlineStyle} node
	 * @returns {{ stylesheet: any; rules: {}; }}
	 */
	function create_style_information(doc, node) {
		const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
		managed_styles.set(doc, info);
		return info;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {number} a
	 * @param {number} b
	 * @param {number} duration
	 * @param {number} delay
	 * @param {(t: number) => number} ease
	 * @param {(t: number, u: number) => string} fn
	 * @param {number} uid
	 * @returns {string}
	 */
	function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
		const step = 16.666 / duration;
		let keyframes = '{\n';
		for (let p = 0; p <= 1; p += step) {
			const t = a + (b - a) * ease(p);
			keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
		}
		const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
		const name = `__svelte_${hash(rule)}_${uid}`;
		const doc = get_root_for_style(node);
		const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
		if (!rules[name]) {
			rules[name] = true;
			stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
		}
		const animation = node.style.animation || '';
		node.style.animation = `${
		animation ? `${animation}, ` : ''
	}${name} ${duration}ms linear ${delay}ms 1 both`;
		active += 1;
		return name;
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {string} [name]
	 * @returns {void}
	 */
	function delete_rule(node, name) {
		const previous = (node.style.animation || '').split(', ');
		const next = previous.filter(
			name
				? (anim) => anim.indexOf(name) < 0 // remove specific animation
				: (anim) => anim.indexOf('__svelte') === -1 // remove all Svelte animations
		);
		const deleted = previous.length - next.length;
		if (deleted) {
			node.style.animation = next.join(', ');
			active -= deleted;
			if (!active) clear_rules();
		}
	}

	/** @returns {void} */
	function clear_rules() {
		raf(() => {
			if (active) return;
			managed_styles.forEach((info) => {
				const { ownerNode } = info.stylesheet;
				// there is no ownerNode if it runs on jsdom.
				if (ownerNode) detach(ownerNode);
			});
			managed_styles.clear();
		});
	}

	let current_component;

	/** @returns {void} */
	function set_current_component(component) {
		current_component = component;
	}

	function get_current_component() {
		if (!current_component) throw new Error('Function called outside component initialization');
		return current_component;
	}

	/**
	 * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
	 * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
	 * it can be called from an external module).
	 *
	 * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.
	 *
	 * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).
	 *
	 * https://svelte.dev/docs/svelte#onmount
	 * @template T
	 * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn
	 * @returns {void}
	 */
	function onMount(fn) {
		get_current_component().$$.on_mount.push(fn);
	}

	/**
	 * Schedules a callback to run immediately after the component has been updated.
	 *
	 * The first time the callback runs will be after the initial `onMount`
	 *
	 * https://svelte.dev/docs/svelte#afterupdate
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function afterUpdate(fn) {
		get_current_component().$$.after_update.push(fn);
	}

	/**
	 * Schedules a callback to run immediately before the component is unmounted.
	 *
	 * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
	 * only one that runs inside a server-side component.
	 *
	 * https://svelte.dev/docs/svelte#ondestroy
	 * @param {() => any} fn
	 * @returns {void}
	 */
	function onDestroy(fn) {
		get_current_component().$$.on_destroy.push(fn);
	}

	/**
	 * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).
	 * Event dispatchers are functions that can take two arguments: `name` and `detail`.
	 *
	 * Component events created with `createEventDispatcher` create a
	 * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
	 * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
	 * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
	 * property and can contain any type of data.
	 *
	 * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:
	 * ```ts
	 * const dispatch = createEventDispatcher<{
	 *  loaded: never; // does not take a detail argument
	 *  change: string; // takes a detail argument of type string, which is required
	 *  optional: number | null; // takes an optional detail argument of type number
	 * }>();
	 * ```
	 *
	 * https://svelte.dev/docs/svelte#createeventdispatcher
	 * @template {Record<string, any>} [EventMap=any]
	 * @returns {import('./public.js').EventDispatcher<EventMap>}
	 */
	function createEventDispatcher() {
		const component = get_current_component();
		return (type, detail, { cancelable = false } = {}) => {
			const callbacks = component.$$.callbacks[type];
			if (callbacks) {
				// TODO are there situations where events could be dispatched
				// in a server (non-DOM) environment?
				const event = custom_event(/** @type {string} */ (type), detail, { cancelable });
				callbacks.slice().forEach((fn) => {
					fn.call(component, event);
				});
				return !event.defaultPrevented;
			}
			return true;
		};
	}

	// TODO figure out if we still want to support
	// shorthand events, or if we want to implement
	// a real bubbling mechanism
	/**
	 * @param component
	 * @param event
	 * @returns {void}
	 */
	function bubble(component, event) {
		const callbacks = component.$$.callbacks[event.type];
		if (callbacks) {
			// @ts-ignore
			callbacks.slice().forEach((fn) => fn.call(this, event));
		}
	}

	const dirty_components = [];
	const binding_callbacks = [];

	let render_callbacks = [];

	const flush_callbacks = [];

	const resolved_promise = /* @__PURE__ */ Promise.resolve();

	let update_scheduled = false;

	/** @returns {void} */
	function schedule_update() {
		if (!update_scheduled) {
			update_scheduled = true;
			resolved_promise.then(flush);
		}
	}

	/** @returns {void} */
	function add_render_callback(fn) {
		render_callbacks.push(fn);
	}

	/** @returns {void} */
	function add_flush_callback(fn) {
		flush_callbacks.push(fn);
	}

	// flush() calls callbacks in this order:
	// 1. All beforeUpdate callbacks, in order: parents before children
	// 2. All bind:this callbacks, in reverse order: children before parents.
	// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
	//    for afterUpdates called during the initial onMount, which are called in
	//    reverse order: children before parents.
	// Since callbacks might update component values, which could trigger another
	// call to flush(), the following steps guard against this:
	// 1. During beforeUpdate, any updated components will be added to the
	//    dirty_components array and will cause a reentrant call to flush(). Because
	//    the flush index is kept outside the function, the reentrant call will pick
	//    up where the earlier call left off and go through all dirty components. The
	//    current_component value is saved and restored so that the reentrant call will
	//    not interfere with the "parent" flush() call.
	// 2. bind:this callbacks cannot trigger new flush() calls.
	// 3. During afterUpdate, any updated components will NOT have their afterUpdate
	//    callback called a second time; the seen_callbacks set, outside the flush()
	//    function, guarantees this behavior.
	const seen_callbacks = new Set();

	let flushidx = 0; // Do *not* move this inside the flush() function

	/** @returns {void} */
	function flush() {
		// Do not reenter flush while dirty components are updated, as this can
		// result in an infinite loop. Instead, let the inner flush handle it.
		// Reentrancy is ok afterwards for bindings etc.
		if (flushidx !== 0) {
			return;
		}
		const saved_component = current_component;
		do {
			// first, call beforeUpdate functions
			// and update components
			try {
				while (flushidx < dirty_components.length) {
					const component = dirty_components[flushidx];
					flushidx++;
					set_current_component(component);
					update(component.$$);
				}
			} catch (e) {
				// reset dirty state to not end up in a deadlocked state and then rethrow
				dirty_components.length = 0;
				flushidx = 0;
				throw e;
			}
			set_current_component(null);
			dirty_components.length = 0;
			flushidx = 0;
			while (binding_callbacks.length) binding_callbacks.pop()();
			// then, once components are updated, call
			// afterUpdate functions. This may cause
			// subsequent updates...
			for (let i = 0; i < render_callbacks.length; i += 1) {
				const callback = render_callbacks[i];
				if (!seen_callbacks.has(callback)) {
					// ...so guard against infinite loops
					seen_callbacks.add(callback);
					callback();
				}
			}
			render_callbacks.length = 0;
		} while (dirty_components.length);
		while (flush_callbacks.length) {
			flush_callbacks.pop()();
		}
		update_scheduled = false;
		seen_callbacks.clear();
		set_current_component(saved_component);
	}

	/** @returns {void} */
	function update($$) {
		if ($$.fragment !== null) {
			$$.update();
			run_all($$.before_update);
			const dirty = $$.dirty;
			$$.dirty = [-1];
			$$.fragment && $$.fragment.p($$.ctx, dirty);
			$$.after_update.forEach(add_render_callback);
		}
	}

	/**
	 * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
	 * @param {Function[]} fns
	 * @returns {void}
	 */
	function flush_render_callbacks(fns) {
		const filtered = [];
		const targets = [];
		render_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));
		targets.forEach((c) => c());
		render_callbacks = filtered;
	}

	/**
	 * @type {Promise<void> | null}
	 */
	let promise;

	/**
	 * @returns {Promise<void>}
	 */
	function wait() {
		if (!promise) {
			promise = Promise.resolve();
			promise.then(() => {
				promise = null;
			});
		}
		return promise;
	}

	/**
	 * @param {Element} node
	 * @param {INTRO | OUTRO | boolean} direction
	 * @param {'start' | 'end'} kind
	 * @returns {void}
	 */
	function dispatch(node, direction, kind) {
		node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
	}

	const outroing = new Set();

	/**
	 * @type {Outro}
	 */
	let outros;

	/**
	 * @returns {void} */
	function group_outros() {
		outros = {
			r: 0,
			c: [],
			p: outros // parent group
		};
	}

	/**
	 * @returns {void} */
	function check_outros() {
		if (!outros.r) {
			run_all(outros.c);
		}
		outros = outros.p;
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} [local]
	 * @returns {void}
	 */
	function transition_in(block, local) {
		if (block && block.i) {
			outroing.delete(block);
			block.i(local);
		}
	}

	/**
	 * @param {import('./private.js').Fragment} block
	 * @param {0 | 1} local
	 * @param {0 | 1} [detach]
	 * @param {() => void} [callback]
	 * @returns {void}
	 */
	function transition_out(block, local, detach, callback) {
		if (block && block.o) {
			if (outroing.has(block)) return;
			outroing.add(block);
			outros.c.push(() => {
				outroing.delete(block);
				if (callback) {
					if (detach) block.d(1);
					callback();
				}
			});
			block.o(local);
		} else if (callback) {
			callback();
		}
	}

	/**
	 * @type {import('../transition/public.js').TransitionConfig}
	 */
	const null_transition = { duration: 0 };

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {TransitionFn} fn
	 * @param {any} params
	 * @returns {{ start(): void; invalidate(): void; end(): void; }}
	 */
	function create_in_transition(node, fn, params) {
		/**
		 * @type {TransitionOptions} */
		const options = { direction: 'in' };
		let config = fn(node, params, options);
		let running = false;
		let animation_name;
		let task;
		let uid = 0;

		/**
		 * @returns {void} */
		function cleanup() {
			if (animation_name) delete_rule(node, animation_name);
		}

		/**
		 * @returns {void} */
		function go() {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick = noop,
				css
			} = config || null_transition;
			if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
			tick(0, 1);
			const start_time = now() + delay;
			const end_time = start_time + duration;
			if (task) task.abort();
			running = true;
			add_render_callback(() => dispatch(node, true, 'start'));
			task = loop((now) => {
				if (running) {
					if (now >= end_time) {
						tick(1, 0);
						dispatch(node, true, 'end');
						cleanup();
						return (running = false);
					}
					if (now >= start_time) {
						const t = easing((now - start_time) / duration);
						tick(t, 1 - t);
					}
				}
				return running;
			});
		}
		let started = false;
		return {
			start() {
				if (started) return;
				started = true;
				delete_rule(node);
				if (is_function(config)) {
					config = config(options);
					wait().then(go);
				} else {
					go();
				}
			},
			invalidate() {
				started = false;
			},
			end() {
				if (running) {
					cleanup();
					running = false;
				}
			}
		};
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {TransitionFn} fn
	 * @param {any} params
	 * @returns {{ end(reset: any): void; }}
	 */
	function create_out_transition(node, fn, params) {
		/** @type {TransitionOptions} */
		const options = { direction: 'out' };
		let config = fn(node, params, options);
		let running = true;
		let animation_name;
		const group = outros;
		group.r += 1;
		/** @type {boolean} */
		let original_inert_value;

		/**
		 * @returns {void} */
		function go() {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick = noop,
				css
			} = config || null_transition;

			if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);

			const start_time = now() + delay;
			const end_time = start_time + duration;
			add_render_callback(() => dispatch(node, false, 'start'));

			if ('inert' in node) {
				original_inert_value = /** @type {HTMLElement} */ (node).inert;
				node.inert = true;
			}

			loop((now) => {
				if (running) {
					if (now >= end_time) {
						tick(0, 1);
						dispatch(node, false, 'end');
						if (!--group.r) {
							// this will result in `end()` being called,
							// so we don't need to clean up here
							run_all(group.c);
						}
						return false;
					}
					if (now >= start_time) {
						const t = easing((now - start_time) / duration);
						tick(1 - t, t);
					}
				}
				return running;
			});
		}

		if (is_function(config)) {
			wait().then(() => {
				// @ts-ignore
				config = config(options);
				go();
			});
		} else {
			go();
		}

		return {
			end(reset) {
				if (reset && 'inert' in node) {
					node.inert = original_inert_value;
				}
				if (reset && config.tick) {
					config.tick(1, 0);
				}
				if (running) {
					if (animation_name) delete_rule(node, animation_name);
					running = false;
				}
			}
		};
	}

	/**
	 * @param {Element & ElementCSSInlineStyle} node
	 * @param {TransitionFn} fn
	 * @param {any} params
	 * @param {boolean} intro
	 * @returns {{ run(b: 0 | 1): void; end(): void; }}
	 */
	function create_bidirectional_transition(node, fn, params, intro) {
		/**
		 * @type {TransitionOptions} */
		const options = { direction: 'both' };
		let config = fn(node, params, options);
		let t = intro ? 0 : 1;

		/**
		 * @type {Program | null} */
		let running_program = null;

		/**
		 * @type {PendingProgram | null} */
		let pending_program = null;
		let animation_name = null;

		/** @type {boolean} */
		let original_inert_value;

		/**
		 * @returns {void} */
		function clear_animation() {
			if (animation_name) delete_rule(node, animation_name);
		}

		/**
		 * @param {PendingProgram} program
		 * @param {number} duration
		 * @returns {Program}
		 */
		function init(program, duration) {
			const d = /** @type {Program['d']} */ (program.b - t);
			duration *= Math.abs(d);
			return {
				a: t,
				b: program.b,
				d,
				duration,
				start: program.start,
				end: program.start + duration,
				group: program.group
			};
		}

		/**
		 * @param {INTRO | OUTRO} b
		 * @returns {void}
		 */
		function go(b) {
			const {
				delay = 0,
				duration = 300,
				easing = identity,
				tick = noop,
				css
			} = config || null_transition;

			/**
			 * @type {PendingProgram} */
			const program = {
				start: now() + delay,
				b
			};

			if (!b) {
				// @ts-ignore todo: improve typings
				program.group = outros;
				outros.r += 1;
			}

			if ('inert' in node) {
				if (b) {
					if (original_inert_value !== undefined) {
						// aborted/reversed outro — restore previous inert value
						node.inert = original_inert_value;
					}
				} else {
					original_inert_value = /** @type {HTMLElement} */ (node).inert;
					node.inert = true;
				}
			}

			if (running_program || pending_program) {
				pending_program = program;
			} else {
				// if this is an intro, and there's a delay, we need to do
				// an initial tick and/or apply CSS animation immediately
				if (css) {
					clear_animation();
					animation_name = create_rule(node, t, b, duration, delay, easing, css);
				}
				if (b) tick(0, 1);
				running_program = init(program, duration);
				add_render_callback(() => dispatch(node, b, 'start'));
				loop((now) => {
					if (pending_program && now > pending_program.start) {
						running_program = init(pending_program, duration);
						pending_program = null;
						dispatch(node, running_program.b, 'start');
						if (css) {
							clear_animation();
							animation_name = create_rule(
								node,
								t,
								running_program.b,
								running_program.duration,
								0,
								easing,
								config.css
							);
						}
					}
					if (running_program) {
						if (now >= running_program.end) {
							tick((t = running_program.b), 1 - t);
							dispatch(node, running_program.b, 'end');
							if (!pending_program) {
								// we're done
								if (running_program.b) {
									// intro — we can tidy up immediately
									clear_animation();
								} else {
									// outro — needs to be coordinated
									if (!--running_program.group.r) run_all(running_program.group.c);
								}
							}
							running_program = null;
						} else if (now >= running_program.start) {
							const p = now - running_program.start;
							t = running_program.a + running_program.d * easing(p / running_program.duration);
							tick(t, 1 - t);
						}
					}
					return !!(running_program || pending_program);
				});
			}
		}
		return {
			run(b) {
				if (is_function(config)) {
					wait().then(() => {
						const opts = { direction: b ? 'in' : 'out' };
						// @ts-ignore
						config = config(opts);
						go(b);
					});
				} else {
					go(b);
				}
			},
			end() {
				clear_animation();
				running_program = pending_program = null;
			}
		};
	}

	/** @typedef {1} INTRO */
	/** @typedef {0} OUTRO */
	/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */
	/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */

	/**
	 * @typedef {Object} Outro
	 * @property {number} r
	 * @property {Function[]} c
	 * @property {Object} p
	 */

	/**
	 * @typedef {Object} PendingProgram
	 * @property {number} start
	 * @property {INTRO|OUTRO} b
	 * @property {Outro} [group]
	 */

	/**
	 * @typedef {Object} Program
	 * @property {number} a
	 * @property {INTRO|OUTRO} b
	 * @property {1|-1} d
	 * @property {number} duration
	 * @property {number} start
	 * @property {number} end
	 * @property {Outro} [group]
	 */

	// general each functions:

	function ensure_array_like(array_like_or_iterator) {
		return array_like_or_iterator?.length !== undefined
			? array_like_or_iterator
			: Array.from(array_like_or_iterator);
	}

	/** @returns {void} */
	function bind(component, name, callback) {
		const index = component.$$.props[name];
		if (index !== undefined) {
			component.$$.bound[index] = callback;
			callback(component.$$.ctx[index]);
		}
	}

	/** @returns {void} */
	function create_component(block) {
		block && block.c();
	}

	/** @returns {void} */
	function mount_component(component, target, anchor) {
		const { fragment, after_update } = component.$$;
		fragment && fragment.m(target, anchor);
		// onMount happens before the initial afterUpdate
		add_render_callback(() => {
			const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
			// if the component was destroyed immediately
			// it will update the `$$.on_destroy` reference to `null`.
			// the destructured on_destroy may still reference to the old array
			if (component.$$.on_destroy) {
				component.$$.on_destroy.push(...new_on_destroy);
			} else {
				// Edge case - component was destroyed immediately,
				// most likely as a result of a binding initialising
				run_all(new_on_destroy);
			}
			component.$$.on_mount = [];
		});
		after_update.forEach(add_render_callback);
	}

	/** @returns {void} */
	function destroy_component(component, detaching) {
		const $$ = component.$$;
		if ($$.fragment !== null) {
			flush_render_callbacks($$.after_update);
			run_all($$.on_destroy);
			$$.fragment && $$.fragment.d(detaching);
			// TODO null out other refs, including component.$$ (but need to
			// preserve final state?)
			$$.on_destroy = $$.fragment = null;
			$$.ctx = [];
		}
	}

	/** @returns {void} */
	function make_dirty(component, i) {
		if (component.$$.dirty[0] === -1) {
			dirty_components.push(component);
			schedule_update();
			component.$$.dirty.fill(0);
		}
		component.$$.dirty[(i / 31) | 0] |= 1 << i % 31;
	}

	// TODO: Document the other params
	/**
	 * @param {SvelteComponent} component
	 * @param {import('./public.js').ComponentConstructorOptions} options
	 *
	 * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.
	 * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.
	 * This will be the `add_css` function from the compiled component.
	 *
	 * @returns {void}
	 */
	function init(
		component,
		options,
		instance,
		create_fragment,
		not_equal,
		props,
		append_styles = null,
		dirty = [-1]
	) {
		const parent_component = current_component;
		set_current_component(component);
		/** @type {import('./private.js').T$$} */
		const $$ = (component.$$ = {
			fragment: null,
			ctx: [],
			// state
			props,
			update: noop,
			not_equal,
			bound: blank_object(),
			// lifecycle
			on_mount: [],
			on_destroy: [],
			on_disconnect: [],
			before_update: [],
			after_update: [],
			context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
			// everything else
			callbacks: blank_object(),
			dirty,
			skip_bound: false,
			root: options.target || parent_component.$$.root
		});
		append_styles && append_styles($$.root);
		let ready = false;
		$$.ctx = instance
			? instance(component, options.props || {}, (i, ret, ...rest) => {
					const value = rest.length ? rest[0] : ret;
					if ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {
						if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
						if (ready) make_dirty(component, i);
					}
					return ret;
			  })
			: [];
		$$.update();
		ready = true;
		run_all($$.before_update);
		// `false` as a special case of no DOM component
		$$.fragment = create_fragment ? create_fragment($$.ctx) : false;
		if (options.target) {
			if (options.hydrate) {
				// TODO: what is the correct type here?
				// @ts-expect-error
				const nodes = children(options.target);
				$$.fragment && $$.fragment.l(nodes);
				nodes.forEach(detach);
			} else {
				// eslint-disable-next-line @typescript-eslint/no-non-null-assertion
				$$.fragment && $$.fragment.c();
			}
			if (options.intro) transition_in(component.$$.fragment);
			mount_component(component, options.target, options.anchor);
			flush();
		}
		set_current_component(parent_component);
	}

	/**
	 * Base class for Svelte components. Used when dev=false.
	 *
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 */
	class SvelteComponent {
		/**
		 * ### PRIVATE API
		 *
		 * Do not use, may change at any time
		 *
		 * @type {any}
		 */
		$$ = undefined;
		/**
		 * ### PRIVATE API
		 *
		 * Do not use, may change at any time
		 *
		 * @type {any}
		 */
		$$set = undefined;

		/** @returns {void} */
		$destroy() {
			destroy_component(this, 1);
			this.$destroy = noop;
		}

		/**
		 * @template {Extract<keyof Events, string>} K
		 * @param {K} type
		 * @param {((e: Events[K]) => void) | null | undefined} callback
		 * @returns {() => void}
		 */
		$on(type, callback) {
			if (!is_function(callback)) {
				return noop;
			}
			const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
			callbacks.push(callback);
			return () => {
				const index = callbacks.indexOf(callback);
				if (index !== -1) callbacks.splice(index, 1);
			};
		}

		/**
		 * @param {Partial<Props>} props
		 * @returns {void}
		 */
		$set(props) {
			if (this.$$set && !is_empty(props)) {
				this.$$.skip_bound = true;
				this.$$set(props);
				this.$$.skip_bound = false;
			}
		}
	}

	/**
	 * @typedef {Object} CustomElementPropDefinition
	 * @property {string} [attribute]
	 * @property {boolean} [reflect]
	 * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]
	 */

	// generated during release, do not modify

	/**
	 * The current version, as set in package.json.
	 *
	 * https://svelte.dev/docs/svelte-compiler#svelte-version
	 * @type {string}
	 */
	const VERSION = '4.2.19';
	const PUBLIC_VERSION = '4';

	/**
	 * @template T
	 * @param {string} type
	 * @param {T} [detail]
	 * @returns {void}
	 */
	function dispatch_dev(type, detail) {
		document.dispatchEvent(custom_event(type, { version: VERSION, ...detail }, { bubbles: true }));
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @returns {void}
	 */
	function append_dev(target, node) {
		dispatch_dev('SvelteDOMInsert', { target, node });
		append(target, node);
	}

	/**
	 * @param {Node} target
	 * @param {Node} node
	 * @param {Node} [anchor]
	 * @returns {void}
	 */
	function insert_dev(target, node, anchor) {
		dispatch_dev('SvelteDOMInsert', { target, node, anchor });
		insert(target, node, anchor);
	}

	/**
	 * @param {Node} node
	 * @returns {void}
	 */
	function detach_dev(node) {
		dispatch_dev('SvelteDOMRemove', { node });
		detach(node);
	}

	/**
	 * @param {Node} node
	 * @param {string} event
	 * @param {EventListenerOrEventListenerObject} handler
	 * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]
	 * @param {boolean} [has_prevent_default]
	 * @param {boolean} [has_stop_propagation]
	 * @param {boolean} [has_stop_immediate_propagation]
	 * @returns {() => void}
	 */
	function listen_dev(
		node,
		event,
		handler,
		options,
		has_prevent_default,
		has_stop_propagation,
		has_stop_immediate_propagation
	) {
		const modifiers =
			options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
		if (has_prevent_default) modifiers.push('preventDefault');
		if (has_stop_propagation) modifiers.push('stopPropagation');
		if (has_stop_immediate_propagation) modifiers.push('stopImmediatePropagation');
		dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
		const dispose = listen(node, event, handler, options);
		return () => {
			dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
			dispose();
		};
	}

	/**
	 * @param {Element} node
	 * @param {string} attribute
	 * @param {string} [value]
	 * @returns {void}
	 */
	function attr_dev(node, attribute, value) {
		attr(node, attribute, value);
		if (value == null) dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
		else dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
	}

	/**
	 * @param {Element} node
	 * @param {string} property
	 * @param {any} [value]
	 * @returns {void}
	 */
	function prop_dev(node, property, value) {
		node[property] = value;
		dispatch_dev('SvelteDOMSetProperty', { node, property, value });
	}

	/**
	 * @param {Text} text
	 * @param {unknown} data
	 * @returns {void}
	 */
	function set_data_dev(text, data) {
		data = '' + data;
		if (text.data === data) return;
		dispatch_dev('SvelteDOMSetData', { node: text, data });
		text.data = /** @type {string} */ (data);
	}

	function ensure_array_like_dev(arg) {
		if (
			typeof arg !== 'string' &&
			!(arg && typeof arg === 'object' && 'length' in arg) &&
			!(typeof Symbol === 'function' && arg && Symbol.iterator in arg)
		) {
			throw new Error('{#each} only works with iterable values.');
		}
		return ensure_array_like(arg);
	}

	/**
	 * @returns {void} */
	function validate_slots(name, slot, keys) {
		for (const slot_key of Object.keys(slot)) {
			if (!~keys.indexOf(slot_key)) {
				console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
			}
		}
	}

	function construct_svelte_component_dev(component, props) {
		const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
		try {
			const instance = new component(props);
			if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
				throw new Error(error_message);
			}
			return instance;
		} catch (err) {
			const { message } = err;
			if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
				throw new Error(error_message);
			} else {
				throw err;
			}
		}
	}

	/**
	 * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
	 *
	 * Can be used to create strongly typed Svelte components.
	 *
	 * #### Example:
	 *
	 * You have component library on npm called `component-library`, from which
	 * you export a component called `MyComponent`. For Svelte+TypeScript users,
	 * you want to provide typings. Therefore you create a `index.d.ts`:
	 * ```ts
	 * import { SvelteComponent } from "svelte";
	 * export class MyComponent extends SvelteComponent<{foo: string}> {}
	 * ```
	 * Typing this makes it possible for IDEs like VS Code with the Svelte extension
	 * to provide intellisense and to use the component like this in a Svelte file
	 * with TypeScript:
	 * ```svelte
	 * <script lang="ts">
	 * 	import { MyComponent } from "component-library";
	 * </script>
	 * <MyComponent foo={'bar'} />
	 * ```
	 * @template {Record<string, any>} [Props=any]
	 * @template {Record<string, any>} [Events=any]
	 * @template {Record<string, any>} [Slots=any]
	 * @extends {SvelteComponent<Props, Events>}
	 */
	class SvelteComponentDev extends SvelteComponent {
		/**
		 * For type checking capabilities only.
		 * Does not exist at runtime.
		 * ### DO NOT USE!
		 *
		 * @type {Props}
		 */
		$$prop_def;
		/**
		 * For type checking capabilities only.
		 * Does not exist at runtime.
		 * ### DO NOT USE!
		 *
		 * @type {Events}
		 */
		$$events_def;
		/**
		 * For type checking capabilities only.
		 * Does not exist at runtime.
		 * ### DO NOT USE!
		 *
		 * @type {Slots}
		 */
		$$slot_def;

		/** @param {import('./public.js').ComponentConstructorOptions<Props>} options */
		constructor(options) {
			if (!options || (!options.target && !options.$$inline)) {
				throw new Error("'target' is a required option");
			}
			super();
		}

		/** @returns {void} */
		$destroy() {
			super.$destroy();
			this.$destroy = () => {
				console.warn('Component was already destroyed'); // eslint-disable-line no-console
			};
		}

		/** @returns {void} */
		$capture_state() {}

		/** @returns {void} */
		$inject_state() {}
	}

	if (typeof window !== 'undefined')
		// @ts-ignore
		(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);

	/* src/lib/components/basic/icons/locked.svelte generated by Svelte v4.2.19 */
	const file$1A = "src/lib/components/basic/icons/locked.svelte";

	function create_fragment$1B(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M18 8V10.605C19.15 10.935 20 11.995 20 13.25V19.25C20 20.765 18.765 22 17.25 22H6.75C5.235 22 4 20.765 4 19.25V13.25C4 11.99 4.85 10.935 6 10.605V8C6 4.69 8.69 2 12 2C15.31 2 18 4.69 18 8ZM16.5 8C16.5 5.52 14.48 3.5 12 3.5C9.52 3.5 7.5 5.52 7.5 8V10.5H16.5V8ZM17.25 20.5C17.94 20.5 18.5 19.94 18.5 19.25V13.25C18.5 12.56 17.94 12 17.25 12H6.75C6.06 12 5.5 12.56 5.5 13.25V19.25C5.5 19.94 6.06 20.5 6.75 20.5H17.25ZM12 14C12.83 14 13.5 14.67 13.5 15.5C13.5 16.05 13.195 16.53 12.75 16.79V18.5H11.25V16.79C10.805 16.53 10.5 16.055 10.5 15.5C10.5 14.67 11.17 14 12 14Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$1A, 11, 1, 154);
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "width", "24");
				attr_dev(svg, "height", "24");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				add_location(svg, file$1A, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1B.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1B($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Locked', slots, []);
		let { color = "#89B4FA" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Locked> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class Locked extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1B, create_fragment$1B, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Locked",
				options,
				id: create_fragment$1B.name
			});
		}

		get color() {
			throw new Error("<Locked>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<Locked>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/eye.svelte generated by Svelte v4.2.19 */
	const file$1z = "src/lib/components/basic/icons/eye.svelte";

	function create_fragment$1A(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M2.06518 12.31C2.19518 12.6 5.34018 19.5 12.0002 19.5C18.6602 19.5 21.8052 12.605 21.9352 12.31L22.0802 11.98L21.9152 11.66C21.7652 11.365 18.1352 4.5 12.0002 4.5C5.34018 4.5 2.19518 11.405 2.06518 11.7L1.93018 12.005L2.06518 12.31ZM12.0002 18C7.05018 18 4.24518 13.265 3.58518 12.005C4.24518 10.74 7.05518 6 12.0002 6C16.5252 6 19.6352 10.73 20.4002 12.025C19.7202 13.32 16.9502 18 12.0002 18ZM8.00018 12C8.00018 14.205 9.79518 16 12.0002 16C14.2052 16 16.0002 14.205 16.0002 12C16.0002 9.795 14.2052 8 12.0002 8C9.79518 8 8.00018 9.795 8.00018 12ZM9.50018 12C9.50018 10.62 10.6202 9.5 12.0002 9.5C13.3802 9.5 14.5002 10.62 14.5002 12C14.5002 13.38 13.3802 14.5 12.0002 14.5C10.6202 14.5 9.50018 13.38 9.50018 12Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$1z, 11, 1, 154);
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "width", "24");
				attr_dev(svg, "height", "24");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				add_location(svg, file$1z, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1A.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1A($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Eye', slots, []);
		let { color = "#85889C" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Eye> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class Eye extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1A, create_fragment$1A, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Eye",
				options,
				id: create_fragment$1A.name
			});
		}

		get color() {
			throw new Error("<Eye>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<Eye>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/unlocked.svelte generated by Svelte v4.2.19 */
	const file$1y = "src/lib/components/basic/icons/unlocked.svelte";

	function create_fragment$1z(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M7.50012 10.5H17.2451C18.7601 10.5 19.9951 11.735 19.9951 13.25V19.25C19.9951 20.765 18.7601 22 17.2451 22H6.74512C5.23012 22 3.99512 20.765 3.99512 19.25V13.25C3.99512 11.99 4.84512 10.935 5.99512 10.605V8.005C5.99512 4.7 8.68512 2.005 11.9951 2.005C14.4151 2.005 16.5851 3.445 17.5251 5.67L16.1451 6.255C15.4401 4.585 13.8151 3.505 12.0001 3.505C9.52012 3.505 7.50012 5.525 7.50012 8.005V10.5ZM17.2501 20.5C17.9401 20.5 18.5001 19.94 18.5001 19.25V13.25C18.5001 12.56 17.9401 12 17.2501 12H6.75012C6.06012 12 5.50012 12.56 5.50012 13.25V19.25C5.50012 19.94 6.06012 20.5 6.75012 20.5H17.2501ZM12.0001 13.9996C12.8301 13.9996 13.5001 14.6696 13.5001 15.4996C13.5001 16.0496 13.1951 16.5296 12.7501 16.7896V18.4996H11.2501V16.7896C10.8051 16.5296 10.5001 16.0546 10.5001 15.4996C10.5001 14.6696 11.1701 13.9996 12.0001 13.9996Z");
				attr_dev(path, "fill", "#85889C");
				add_location(path, file$1y, 7, 1, 103);
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "width", "24");
				attr_dev(svg, "height", "24");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				add_location(svg, file$1y, 0, 0, 0);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1z.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1z($$self, $$props) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Unlocked', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Unlocked> was created with unknown prop '${key}'`);
		});

		return [];
	}

	class Unlocked extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1z, create_fragment$1z, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Unlocked",
				options,
				id: create_fragment$1z.name
			});
		}
	}

	/* src/lib/components/basic/icons/copyIcon.svelte generated by Svelte v4.2.19 */
	const file$1x = "src/lib/components/basic/icons/copyIcon.svelte";

	function create_fragment$1y(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M7.25 18H19.75C20.44 18 21 17.44 21 16.75V4.25C21 3.56 20.44 3 19.75 3H7.25C6.56 3 6 3.56 6 4.25V16.75C6 17.44 6.56 18 7.25 18ZM19.5 16.5H7.5V4.5H19.5V16.5ZM5.75 21H18V19.5H5.75C5.06 19.5 4.5 18.94 4.5 18.25V6.00003H3V18.25C3 19.765 4.235 21 5.75 21Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$1x, 11, 1, 154);
				attr_dev(svg, "width", "24");
				attr_dev(svg, "height", "24");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1x, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1y.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1y($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('CopyIcon', slots, []);
		let { color = "#85889C" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CopyIcon> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class CopyIcon extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1y, create_fragment$1y, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "CopyIcon",
				options,
				id: create_fragment$1y.name
			});
		}

		get color() {
			throw new Error("<CopyIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<CopyIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/activeCopy.svelte generated by Svelte v4.2.19 */
	const file$1w = "src/lib/components/basic/icons/activeCopy.svelte";

	function create_fragment$1x(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M7.25 18H19.75C20.44 18 21 17.44 21 16.75V4.25C21 3.56 20.44 3 19.75 3H7.25C6.56 3 6 3.56 6 4.25V16.75C6 17.44 6.56 18 7.25 18ZM19.5 16.5H7.5V4.5H19.5V16.5ZM5.75 21H18V19.5H5.75C5.06 19.5 4.5 18.94 4.5 18.25V6.00003H3V18.25C3 19.765 4.235 21 5.75 21Z");
				attr_dev(path, "fill", "#BFC0CC");
				add_location(path, file$1w, 7, 1, 103);
				attr_dev(svg, "width", "24");
				attr_dev(svg, "height", "24");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1w, 0, 0, 0);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1x.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1x($$self, $$props) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ActiveCopy', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ActiveCopy> was created with unknown prop '${key}'`);
		});

		return [];
	}

	class ActiveCopy extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1x, create_fragment$1x, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ActiveCopy",
				options,
				id: create_fragment$1x.name
			});
		}
	}

	/* src/lib/components/basic/icons/closedEye.svelte generated by Svelte v4.2.19 */
	const file$1v = "src/lib/components/basic/icons/closedEye.svelte";

	function create_fragment$1w(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M22.0802 11.98L21.9352 12.31C21.8552 12.49 20.6552 15.125 18.2152 17.155L21.2802 20.22L20.2202 21.28L2.72018 3.77997L3.78018 2.71997L7.01518 5.95497C8.38018 5.09997 10.0352 4.49997 12.0002 4.49997C18.1352 4.49997 21.7652 11.37 21.9152 11.66L22.0802 11.98ZM10.8502 9.78997L14.2102 13.15C14.3902 12.805 14.5002 12.415 14.5002 12C14.5002 10.62 13.3802 9.49997 12.0002 9.49997C11.5802 9.49997 11.1952 9.60997 10.8502 9.78997ZM16.0002 12C16.0002 12.835 15.7402 13.605 15.3052 14.245L17.1252 16.065C18.9102 14.615 20.0052 12.765 20.3952 12.02C19.6302 10.725 16.5252 5.99497 11.9952 5.99497C10.5102 5.99497 9.22518 6.42997 8.12518 7.06497L9.75518 8.69497C10.3952 8.25997 11.1702 7.99997 12.0002 7.99997C14.2052 7.99997 16.0002 9.79497 16.0002 12ZM3.58518 12.005C4.24518 13.265 7.05518 18 12.0002 18C12.8702 18 13.6752 17.845 14.4152 17.595L15.5902 18.77C14.5302 19.22 13.3402 19.5 12.0002 19.5C5.34018 19.5 2.19518 12.605 2.06518 12.31L1.93018 12.005L2.06518 11.7C2.06646 11.6973 2.06801 11.6939 2.06982 11.69C2.1668 11.4813 3.02142 9.64201 4.69518 7.875L5.77018 8.95C4.61018 10.175 3.88018 11.44 3.58518 12.005Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$1v, 11, 1, 154);
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "width", "24");
				attr_dev(svg, "height", "24");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				add_location(svg, file$1v, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1w.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1w($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ClosedEye', slots, []);
		let { color = "#85889C" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ClosedEye> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class ClosedEye extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1w, create_fragment$1w, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ClosedEye",
				options,
				id: create_fragment$1w.name
			});
		}

		get color() {
			throw new Error("<ClosedEye>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<ClosedEye>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/binIcon.svelte generated by Svelte v4.2.19 */
	const file$1u = "src/lib/components/basic/icons/binIcon.svelte";

	function create_fragment$1v(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M21 5H16V4.75C16 3.235 14.765 2 13.25 2H10.75C9.235 2 8 3.235 8 4.75V5H3V6.5H4V19.25C4 20.765 5.235 22 6.75 22H17.25C18.765 22 20 20.765 20 19.25V6.5H21V5ZM9.5 4.75C9.5 4.06 10.06 3.5 10.75 3.5H13.25C13.94 3.5 14.5 4.06 14.5 4.75V5H9.5V4.75ZM18.5 19.25C18.5 19.94 17.94 20.5 17.25 20.5H6.75C6.06 20.5 5.5 19.94 5.5 19.25V6.5H18.5V19.25ZM10.5 9.5H9V17.5H10.5V9.5ZM13.5 9.5H15V17.5H13.5V9.5Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$1u, 11, 1, 154);
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				add_location(svg, file$1u, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1v.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1v($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('BinIcon', slots, []);
		let { color = "#85889C" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BinIcon> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class BinIcon extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1v, create_fragment$1v, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "BinIcon",
				options,
				id: create_fragment$1v.name
			});
		}

		get color() {
			throw new Error("<BinIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<BinIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/lens.svelte generated by Svelte v4.2.19 */
	const file$1t = "src/lib/components/basic/icons/lens.svelte";

	function create_fragment$1u(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "d", "M16.9365 16.9453C16.8199 17.0602 16.6628 17.1247 16.499 17.125C16.3331 17.1243 16.1737 17.06 16.0537 16.9453L12.6787 13.5625C11.2573 14.7564 9.42983 15.3555 7.57746 15.2348C5.72509 15.114 3.99084 14.2828 2.7364 12.9146C1.48197 11.5463 0.804205 9.7465 0.84447 7.89063C0.884735 6.03477 1.63992 4.2661 2.95252 2.9535C4.26512 1.6409 6.03379 0.885712 7.88966 0.845447C9.74552 0.805181 11.5453 1.48294 12.9136 2.73738C14.2819 3.99182 15.1131 5.72607 15.2338 7.57844C15.3545 9.43081 14.7554 11.2583 13.5615 12.6797L16.9365 16.0547C16.9956 16.1128 17.0425 16.1822 17.0745 16.2586C17.1065 16.3351 17.123 16.4171 17.123 16.5C17.123 16.5829 17.1065 16.6649 17.0745 16.7414C17.0425 16.8178 16.9956 16.8872 16.9365 16.9453ZM8.06152 14C9.23585 14 10.3838 13.6518 11.3602 12.9994C12.3366 12.3469 13.0977 11.4196 13.5471 10.3347C13.9965 9.24975 14.114 8.05591 13.8849 6.90415C13.6558 5.75239 13.0903 4.69443 12.26 3.86405C11.4296 3.03368 10.3716 2.46819 9.21987 2.23909C8.06811 2.00999 6.87428 2.12757 5.78934 2.57696C4.7044 3.02636 3.77709 3.78738 3.12467 4.7638C2.47225 5.74022 2.12402 6.88817 2.12402 8.0625C2.12609 9.63659 2.75231 11.1456 3.86536 12.2587C4.97841 13.3717 6.48743 13.9979 8.06152 14Z");
				attr_dev(path, "fill", "#30363D");
				add_location(path, file$1t, 7, 1, 103);
				attr_dev(svg, "width", "18");
				attr_dev(svg, "height", "18");
				attr_dev(svg, "viewBox", "0 0 18 18");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1t, 0, 0, 0);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1u.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1u($$self, $$props) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Lens', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Lens> was created with unknown prop '${key}'`);
		});

		return [];
	}

	class Lens extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1u, create_fragment$1u, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Lens",
				options,
				id: create_fragment$1u.name
			});
		}
	}

	/* src/lib/components/basic/icons/closePanel.svelte generated by Svelte v4.2.19 */
	const file$1s = "src/lib/components/basic/icons/closePanel.svelte";

	function create_fragment$1t(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "d", "M20.28 4.77973L19.22 3.71973L12 10.9397L4.77997 3.71973L3.71997 4.77973L10.94 11.9997L3.71997 19.2197L4.77997 20.2797L12 13.0597L19.22 20.2797L20.28 19.2197L13.06 11.9997L20.28 4.77973Z");
				attr_dev(path, "fill", "#6E7681");
				add_location(path, file$1s, 11, 1, 154);
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "width", /*size*/ ctx[0]);
				attr_dev(svg, "height", /*size*/ ctx[0]);
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				add_location(svg, file$1s, 4, 0, 43);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*size*/ 1) {
					attr_dev(svg, "width", /*size*/ ctx[0]);
				}

				if (dirty & /*size*/ 1) {
					attr_dev(svg, "height", /*size*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1t.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1t($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ClosePanel', slots, []);
		let { size = 20 } = $$props;
		const writable_props = ['size'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ClosePanel> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('size' in $$props) $$invalidate(0, size = $$props.size);
		};

		$$self.$capture_state = () => ({ size });

		$$self.$inject_state = $$props => {
			if ('size' in $$props) $$invalidate(0, size = $$props.size);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [size];
	}

	class ClosePanel extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1t, create_fragment$1t, safe_not_equal, { size: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ClosePanel",
				options,
				id: create_fragment$1t.name
			});
		}

		get size() {
			throw new Error("<ClosePanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set size(value) {
			throw new Error("<ClosePanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/infoIcon.svelte generated by Svelte v4.2.19 */
	const file$1r = "src/lib/components/basic/icons/infoIcon.svelte";

	function create_fragment$1s(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M12 22C6.485 22 2 17.515 2 12C2 6.485 6.485 2 12 2C17.515 2 22 6.485 22 12C22 17.515 17.515 22 12 22ZM12 3.5C7.315 3.5 3.5 7.315 3.5 12C3.5 16.685 7.315 20.5 12 20.5C16.685 20.5 20.5 16.685 20.5 12C20.5 7.315 16.685 3.5 12 3.5ZM12.75 16V10.5H11.25V16H12.75ZM13 8C13 8.55228 12.5523 9 12 9C11.4477 9 11 8.55228 11 8C11 7.44772 11.4477 7 12 7C12.5523 7 13 7.44772 13 8Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$1r, 11, 1, 154);
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				add_location(svg, file$1r, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1s.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1s($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('InfoIcon', slots, []);
		let { color = "#4D4F60" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InfoIcon> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class InfoIcon extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1s, create_fragment$1s, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "InfoIcon",
				options,
				id: create_fragment$1s.name
			});
		}

		get color() {
			throw new Error("<InfoIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<InfoIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/downArrow.svelte generated by Svelte v4.2.19 */
	const file$1q = "src/lib/components/basic/icons/downArrow.svelte";

	function create_fragment$1r(ctx) {
		let svg;
		let path;
		let path_fill_value;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "d", "M11.9997 16.0402C11.6797 16.0402 11.3597 15.9202 11.1147 15.6752L5.21973 9.78021L6.27973 8.72021L11.9997 14.4402L17.7197 8.72021L18.7797 9.78021L12.8847 15.6752C12.6397 15.9202 12.3197 16.0402 11.9997 16.0402Z");
				attr_dev(path, "fill", path_fill_value = setbackground$1(/*type*/ ctx[0]));
				add_location(path, file$1q, 23, 1, 410);
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				add_location(svg, file$1q, 16, 0, 307);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*type*/ 1 && path_fill_value !== (path_fill_value = setbackground$1(/*type*/ ctx[0]))) {
					attr_dev(path, "fill", path_fill_value);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1r.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function setbackground$1(type) {
		const typeToClassMap = {
			reader: "#F9E2AF",
			manager: "#F5C2E7",
			owner: "#A6E3A1",
			common: "#6E7681",
			indicator: "#74C7EC",
			profile: "#85889C",
			profileActive: "#F2F2F0"
		};

		return typeToClassMap[type] || "";
	}

	function instance$1r($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('DownArrow', slots, []);
		let { type } = $$props;

		$$self.$$.on_mount.push(function () {
			if (type === undefined && !('type' in $$props || $$self.$$.bound[$$self.$$.props['type']])) {
				console.warn("<DownArrow> was created without expected prop 'type'");
			}
		});

		const writable_props = ['type'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DownArrow> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('type' in $$props) $$invalidate(0, type = $$props.type);
		};

		$$self.$capture_state = () => ({ type, setbackground: setbackground$1 });

		$$self.$inject_state = $$props => {
			if ('type' in $$props) $$invalidate(0, type = $$props.type);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [type];
	}

	class DownArrow extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1r, create_fragment$1r, safe_not_equal, { type: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "DownArrow",
				options,
				id: create_fragment$1r.name
			});
		}

		get type() {
			throw new Error("<DownArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set type(value) {
			throw new Error("<DownArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/rightArrow.svelte generated by Svelte v4.2.19 */
	const file$1p = "src/lib/components/basic/icons/rightArrow.svelte";

	function create_fragment$1q(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "d", "M16.04 12.0003C16.04 12.3203 15.92 12.6403 15.675 12.8853L9.77997 18.7803L8.71997 17.7203L14.44 12.0003L8.71997 6.28027L9.77997 5.22027L15.675 11.1153C15.92 11.3603 16.04 11.6803 16.04 12.0003Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$1p, 11, 1, 154);
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				add_location(svg, file$1p, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1q.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1q($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('RightArrow', slots, []);
		let { color = "#6E7681" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RightArrow> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class RightArrow extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1q, create_fragment$1q, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "RightArrow",
				options,
				id: create_fragment$1q.name
			});
		}

		get color() {
			throw new Error("<RightArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<RightArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/more.svelte generated by Svelte v4.2.19 */
	const file$1o = "src/lib/components/basic/icons/more.svelte";

	function create_fragment$1p(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M13.5 5C13.5 5.82843 12.8284 6.5 12 6.5C11.1716 6.5 10.5 5.82843 10.5 5C10.5 4.17157 11.1716 3.5 12 3.5C12.8284 3.5 13.5 4.17157 13.5 5ZM12 13.5C12.8284 13.5 13.5 12.8284 13.5 12C13.5 11.1716 12.8284 10.5 12 10.5C11.1716 10.5 10.5 11.1716 10.5 12C10.5 12.8284 11.1716 13.5 12 13.5ZM12 20.5C12.8284 20.5 13.5 19.8284 13.5 19C13.5 18.1716 12.8284 17.5 12 17.5C11.1716 17.5 10.5 18.1716 10.5 19C10.5 19.8284 11.1716 20.5 12 20.5Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$1o, 11, 1, 154);
				attr_dev(svg, "width", "24");
				attr_dev(svg, "height", "24");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1o, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1p.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1p($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('More', slots, []);
		let { color = "#4D4F60" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<More> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class More extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1p, create_fragment$1p, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "More",
				options,
				id: create_fragment$1p.name
			});
		}

		get color() {
			throw new Error("<More>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<More>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/share.svelte generated by Svelte v4.2.19 */
	const file$1n = "src/lib/components/basic/icons/share.svelte";

	function create_fragment$1o(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "d", "M14.2785 16.7206L14.4487 16.8205L14.5854 16.6781C15.1357 16.1047 15.9016 15.75 16.75 15.75C18.4019 15.75 19.75 17.0981 19.75 18.75C19.75 20.4019 18.4019 21.75 16.75 21.75C15.0981 21.75 13.75 20.4019 13.75 18.75C13.75 18.4453 13.7962 18.1507 13.8833 17.8755L13.9436 17.6853L13.7715 17.5844L7.72152 14.0344L7.55129 13.9345L7.41462 14.0769C6.86431 14.6503 6.09845 15.005 5.25 15.005C3.59807 15.005 2.25 13.6569 2.25 12.005C2.25 10.3531 3.59807 9.005 5.25 9.005C6.09903 9.005 6.86932 9.36008 7.4139 9.93235L7.55055 10.0759L7.72152 9.97563L13.7715 6.42563L13.9436 6.32468L13.8833 6.13453C13.7963 5.85963 13.75 5.56013 13.75 5.255C13.75 3.60308 15.0981 2.255 16.75 2.255C18.4019 2.255 19.75 3.60308 19.75 5.255C19.75 6.90693 18.4019 8.255 16.75 8.255C15.897 8.255 15.131 7.89568 14.5854 7.32693L14.4487 7.18448L14.2785 7.28438L8.22848 10.8344L8.05645 10.9353L8.11666 11.1255C8.20383 11.4008 8.25 11.6953 8.25 12C8.25 12.3051 8.20372 12.6046 8.11666 12.8795L8.05645 13.0697L8.22848 13.1706L14.2785 16.7206ZM18.75 5.25C18.75 4.14693 17.8531 3.25 16.75 3.25C15.6469 3.25 14.75 4.14693 14.75 5.25C14.75 6.35308 15.6469 7.25 16.75 7.25C17.8531 7.25 18.75 6.35308 18.75 5.25ZM3.25 12C3.25 13.1031 4.14693 14 5.25 14C6.35307 14 7.25 13.1031 7.25 12C7.25 10.8969 6.35307 10 5.25 10C4.14693 10 3.25 10.8969 3.25 12ZM14.75 18.75C14.75 19.8531 15.6469 20.75 16.75 20.75C17.8531 20.75 18.75 19.8531 18.75 18.75C18.75 17.6469 17.8531 16.75 16.75 16.75C15.6469 16.75 14.75 17.6469 14.75 18.75Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				attr_dev(path, "stroke-width", "1");
				add_location(path, file$1n, 12, 1, 168);
				attr_dev(svg, "width", /*size*/ ctx[1]);
				attr_dev(svg, "height", /*size*/ ctx[1]);
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1n, 5, 0, 57);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}

				if (dirty & /*size*/ 2) {
					attr_dev(svg, "width", /*size*/ ctx[1]);
				}

				if (dirty & /*size*/ 2) {
					attr_dev(svg, "height", /*size*/ ctx[1]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1o.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1o($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Share', slots, []);
		let { color } = $$props;
		let { size } = $$props;

		$$self.$$.on_mount.push(function () {
			if (color === undefined && !('color' in $$props || $$self.$$.bound[$$self.$$.props['color']])) {
				console.warn("<Share> was created without expected prop 'color'");
			}

			if (size === undefined && !('size' in $$props || $$self.$$.bound[$$self.$$.props['size']])) {
				console.warn("<Share> was created without expected prop 'size'");
			}
		});

		const writable_props = ['color', 'size'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Share> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
		};

		$$self.$capture_state = () => ({ color, size });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color, size];
	}

	class Share extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1o, create_fragment$1o, safe_not_equal, { color: 0, size: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Share",
				options,
				id: create_fragment$1o.name
			});
		}

		get color() {
			throw new Error("<Share>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<Share>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get size() {
			throw new Error("<Share>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set size(value) {
			throw new Error("<Share>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/add.svelte generated by Svelte v4.2.19 */
	const file$1m = "src/lib/components/basic/icons/add.svelte";

	function create_fragment$1n(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "d", "M13 11.25V11.5H13.25H20.25V12.5H13.25H13V12.75V19.75H12V12.75V12.5H11.75H4.75V11.5H11.75H12V11.25V4.25H13V11.25Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				attr_dev(path, "stroke", /*color*/ ctx[0]);
				attr_dev(path, "stroke-width", "1");
				add_location(path, file$1m, 11, 1, 154);
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 25 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1m, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}

				if (dirty & /*color*/ 1) {
					attr_dev(path, "stroke", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1n.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1n($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Add', slots, []);
		let { color = "#010409" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Add> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class Add extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1n, create_fragment$1n, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Add",
				options,
				id: create_fragment$1n.name
			});
		}

		get color() {
			throw new Error("<Add>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<Add>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/profile.svelte generated by Svelte v4.2.19 */
	const file$1l = "src/lib/components/basic/icons/profile.svelte";

	function create_fragment$1m(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M10 20C10 14.485 14.485 10 20 10C25.515 10 30 14.485 30 20C30 25.515 25.515 30 20 30C14.485 30 10 25.515 10 20ZM15.63 26.665L15.49 27.19H15.495C16.805 28.015 18.35 28.5 20.005 28.5C21.66 28.5 23.205 28.015 24.515 27.19L24.375 26.665C24.11 25.68 23.215 24.995 22.2 24.995H17.805C16.785 24.995 15.895 25.685 15.63 26.665ZM22.2 23.495C23.865 23.495 25.33 24.605 25.795 26.2V26.205C27.455 24.65 28.5 22.45 28.5 20C28.5 15.315 24.685 11.5 20 11.5C15.315 11.5 11.5 15.315 11.505 19.995C11.505 22.445 12.55 24.65 14.21 26.2C14.675 24.605 16.14 23.495 17.805 23.495H22.2ZM15.5 17.5C15.5 15.02 17.52 13 20 13C22.48 13 24.5 15.02 24.5 17.5C24.5 19.98 22.48 22 20 22C17.52 22 15.5 19.98 15.5 17.5ZM17 17.5C17 19.155 18.345 20.5 20 20.5C21.655 20.5 23 19.155 23 17.5C23 15.845 21.655 14.5 20 14.5C18.345 14.5 17 15.845 17 17.5Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$1l, 11, 1, 154);
				attr_dev(svg, "width", "30");
				attr_dev(svg, "height", "30");
				attr_dev(svg, "viewBox", "0 0 40 40");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1l, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1m.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1m($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Profile', slots, []);
		let { color = "#85889C" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Profile> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class Profile extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1m, create_fragment$1m, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Profile",
				options,
				id: create_fragment$1m.name
			});
		}

		get color() {
			throw new Error("<Profile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<Profile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/logo.svelte generated by Svelte v4.2.19 */
	const file$1k = "src/lib/components/basic/icons/logo.svelte";

	function create_fragment$1l(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "d", "M16.196 37.576C13.7 37.576 11.412 36.984 9.332 35.8C7.284 34.616 5.652 33 4.436 30.952C3.22 28.904 2.612 26.584 2.612 23.992C2.612 21.368 3.22 19.048 4.436 17.032C5.652 14.984 7.284 13.384 9.332 12.232C11.38 11.048 13.668 10.456 16.196 10.456C18.756 10.456 21.044 11.048 23.06 12.232C25.108 13.384 26.724 14.984 27.908 17.032C29.124 19.048 29.732 21.368 29.732 23.992C29.732 26.616 29.124 28.952 27.908 31C26.692 33.048 25.06 34.664 23.012 35.848C20.964 37 18.692 37.576 16.196 37.576ZM16.196 32.536C17.732 32.536 19.092 32.168 20.276 31.432C21.46 30.696 22.388 29.688 23.06 28.408C23.764 27.096 24.116 25.624 24.116 23.992C24.116 22.36 23.764 20.904 23.06 19.624C22.388 18.344 21.46 17.336 20.276 16.6C19.092 15.864 17.732 15.496 16.196 15.496C14.692 15.496 13.332 15.864 12.116 16.6C10.932 17.336 9.988 18.344 9.284 19.624C8.612 20.904 8.276 22.36 8.276 23.992C8.276 25.624 8.612 27.096 9.284 28.408C9.988 29.688 10.932 30.696 12.116 31.432C13.332 32.168 14.692 32.536 16.196 32.536ZM44.6274 37.576C41.9714 37.576 39.6354 36.92 37.6194 35.608C35.6354 34.296 34.2434 32.536 33.4434 30.328L37.6194 28.36C38.3234 29.832 39.2834 31 40.4994 31.864C41.7474 32.728 43.1234 33.16 44.6274 33.16C45.9074 33.16 46.9474 32.872 47.7474 32.296C48.5474 31.72 48.9474 30.936 48.9474 29.944C48.9474 29.304 48.7714 28.792 48.4194 28.408C48.0674 27.992 47.6194 27.656 47.0754 27.4C46.5634 27.144 46.0354 26.952 45.4914 26.824L41.4114 25.672C39.1714 25.032 37.4914 24.072 36.3714 22.792C35.2834 21.48 34.7394 19.96 34.7394 18.232C34.7394 16.664 35.1394 15.304 35.9394 14.152C36.7394 12.968 37.8434 12.056 39.2514 11.416C40.6594 10.776 42.2434 10.456 44.0034 10.456C46.3714 10.456 48.4834 11.048 50.3394 12.232C52.1954 13.384 53.5074 15 54.2754 17.08L50.0994 19.048C49.5874 17.8 48.7714 16.808 47.6514 16.072C46.5634 15.336 45.3314 14.968 43.9554 14.968C42.7714 14.968 41.8274 15.256 41.1234 15.832C40.4194 16.376 40.0674 17.096 40.0674 17.992C40.0674 18.6 40.2274 19.112 40.5474 19.528C40.8674 19.912 41.2834 20.232 41.7954 20.488C42.3074 20.712 42.8354 20.904 43.3794 21.064L47.6034 22.312C49.7474 22.92 51.3954 23.88 52.5474 25.192C53.6994 26.472 54.2754 28.008 54.2754 29.8C54.2754 31.336 53.8594 32.696 53.0274 33.88C52.2274 35.032 51.1074 35.944 49.6674 36.616C48.2274 37.256 46.5474 37.576 44.6274 37.576ZM66.6571 37L56.4811 11.032H62.3851L70.2091 32.2H68.0491L75.8731 11.032H81.8251L71.6011 37H66.6571ZM92.3503 37.576C90.5903 37.576 89.0383 37.272 87.6943 36.664C86.3823 36.024 85.3583 35.16 84.6223 34.072C83.8863 32.952 83.5183 31.64 83.5183 30.136C83.5183 28.728 83.8223 27.464 84.4303 26.344C85.0703 25.224 86.0463 24.28 87.3583 23.512C88.6703 22.744 90.3183 22.2 92.3023 21.88L101.326 20.392V24.664L93.3583 26.056C91.9183 26.312 90.8623 26.776 90.1903 27.448C89.5183 28.088 89.1823 28.92 89.1823 29.944C89.1823 30.936 89.5503 31.752 90.2863 32.392C91.0543 33 92.0303 33.304 93.2143 33.304C94.6863 33.304 95.9663 32.984 97.0543 32.344C98.1743 31.704 99.0383 30.856 99.6463 29.8C100.254 28.712 100.558 27.512 100.558 26.2V19.528C100.558 18.248 100.078 17.208 99.1183 16.408C98.1903 15.576 96.9423 15.16 95.3743 15.16C93.9343 15.16 92.6703 15.544 91.5823 16.312C90.5263 17.048 89.7423 18.008 89.2303 19.192L84.7183 16.936C85.1983 15.656 85.9823 14.536 87.0703 13.576C88.1583 12.584 89.4223 11.816 90.8623 11.272C92.3343 10.728 93.8863 10.456 95.5182 10.456C97.5663 10.456 99.3743 10.84 100.942 11.608C102.542 12.376 103.774 13.448 104.638 14.824C105.534 16.168 105.982 17.736 105.982 19.528V37H100.798V32.296L101.902 32.44C101.294 33.496 100.51 34.408 99.5503 35.176C98.6223 35.944 97.5503 36.536 96.3343 36.952C95.1503 37.368 93.8223 37.576 92.3503 37.576ZM121.588 37.576C119.636 37.576 117.924 37.144 116.452 36.28C114.98 35.384 113.828 34.152 112.996 32.584C112.196 30.984 111.796 29.144 111.796 27.064V11.032H117.22V26.584C117.22 27.768 117.46 28.808 117.94 29.704C118.42 30.6 119.092 31.304 119.956 31.816C120.82 32.296 121.812 32.536 122.932 32.536C124.084 32.536 125.092 32.28 125.956 31.768C126.82 31.256 127.492 30.536 127.972 29.608C128.484 28.68 128.74 27.592 128.74 26.344V11.032H134.116V37H128.98V31.912L129.556 32.584C128.948 34.184 127.94 35.416 126.532 36.28C125.124 37.144 123.476 37.576 121.588 37.576ZM140.449 37V0.663999H145.873V37H140.449ZM164.215 37.576C161.719 37.576 159.479 36.984 157.495 35.8C155.543 34.584 153.991 32.952 152.839 30.904C151.719 28.856 151.159 26.552 151.159 23.992C151.159 21.432 151.735 19.128 152.887 17.08C154.039 15.032 155.591 13.416 157.543 12.232C159.495 11.048 161.703 10.456 164.167 10.456C166.247 10.456 168.087 10.872 169.687 11.704C171.287 12.536 172.551 13.688 173.479 15.16L172.663 16.408V0.663999H178.039V37H172.903V31.72L173.527 32.728C172.631 34.296 171.351 35.496 169.687 36.328C168.023 37.16 166.199 37.576 164.215 37.576ZM164.743 32.536C166.247 32.536 167.591 32.168 168.775 31.432C169.991 30.696 170.935 29.688 171.607 28.408C172.311 27.096 172.663 25.624 172.663 23.992C172.663 22.36 172.311 20.904 171.607 19.624C170.935 18.344 169.991 17.336 168.775 16.6C167.591 15.864 166.247 15.496 164.743 15.496C163.239 15.496 161.879 15.864 160.663 16.6C159.447 17.336 158.503 18.344 157.831 19.624C157.159 20.904 156.823 22.36 156.823 23.992C156.823 25.624 157.159 27.096 157.831 28.408C158.503 29.688 159.431 30.696 160.615 31.432C161.831 32.168 163.207 32.536 164.743 32.536Z");
				attr_dev(path, "fill", "#C9D1D9");
				add_location(path, file$1k, 7, 1, 105);
				attr_dev(svg, "width", "182");
				attr_dev(svg, "height", "45");
				attr_dev(svg, "viewBox", "0 0 182 45");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1k, 0, 0, 0);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1l.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1l($$self, $$props) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Logo', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Logo> was created with unknown prop '${key}'`);
		});

		return [];
	}

	class Logo extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1l, create_fragment$1l, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Logo",
				options,
				id: create_fragment$1l.name
			});
		}
	}

	const subscriber_queue = [];

	/**
	 * Creates a `Readable` store that allows reading by subscription.
	 *
	 * https://svelte.dev/docs/svelte-store#readable
	 * @template T
	 * @param {T} [value] initial value
	 * @param {import('./public.js').StartStopNotifier<T>} [start]
	 * @returns {import('./public.js').Readable<T>}
	 */
	function readable(value, start) {
		return {
			subscribe: writable(value, start).subscribe
		};
	}

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * https://svelte.dev/docs/svelte-store#writable
	 * @template T
	 * @param {T} [value] initial value
	 * @param {import('./public.js').StartStopNotifier<T>} [start]
	 * @returns {import('./public.js').Writable<T>}
	 */
	function writable(value, start = noop) {
		/** @type {import('./public.js').Unsubscriber} */
		let stop;
		/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */
		const subscribers = new Set();
		/** @param {T} new_value
		 * @returns {void}
		 */
		function set(new_value) {
			if (safe_not_equal(value, new_value)) {
				value = new_value;
				if (stop) {
					// store is ready
					const run_queue = !subscriber_queue.length;
					for (const subscriber of subscribers) {
						subscriber[1]();
						subscriber_queue.push(subscriber, value);
					}
					if (run_queue) {
						for (let i = 0; i < subscriber_queue.length; i += 2) {
							subscriber_queue[i][0](subscriber_queue[i + 1]);
						}
						subscriber_queue.length = 0;
					}
				}
			}
		}

		/**
		 * @param {import('./public.js').Updater<T>} fn
		 * @returns {void}
		 */
		function update(fn) {
			set(fn(value));
		}

		/**
		 * @param {import('./public.js').Subscriber<T>} run
		 * @param {import('./private.js').Invalidator<T>} [invalidate]
		 * @returns {import('./public.js').Unsubscriber}
		 */
		function subscribe(run, invalidate = noop) {
			/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */
			const subscriber = [run, invalidate];
			subscribers.add(subscriber);
			if (subscribers.size === 1) {
				stop = start(set, update) || noop;
			}
			run(value);
			return () => {
				subscribers.delete(subscriber);
				if (subscribers.size === 0 && stop) {
					stop();
					stop = null;
				}
			};
		}
		return { set, update, subscribe };
	}

	/**
	 * Derived value store by synchronizing one or more readable stores and
	 * applying an aggregation function over its input values.
	 *
	 * https://svelte.dev/docs/svelte-store#derived
	 * @template {import('./private.js').Stores} S
	 * @template T
	 * @overload
	 * @param {S} stores - input stores
	 * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values
	 * @param {T} [initial_value] - initial value
	 * @returns {import('./public.js').Readable<T>}
	 */

	/**
	 * Derived value store by synchronizing one or more readable stores and
	 * applying an aggregation function over its input values.
	 *
	 * https://svelte.dev/docs/svelte-store#derived
	 * @template {import('./private.js').Stores} S
	 * @template T
	 * @overload
	 * @param {S} stores - input stores
	 * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values
	 * @param {T} [initial_value] - initial value
	 * @returns {import('./public.js').Readable<T>}
	 */

	/**
	 * @template {import('./private.js').Stores} S
	 * @template T
	 * @param {S} stores
	 * @param {Function} fn
	 * @param {T} [initial_value]
	 * @returns {import('./public.js').Readable<T>}
	 */
	function derived(stores, fn, initial_value) {
		const single = !Array.isArray(stores);
		/** @type {Array<import('./public.js').Readable<any>>} */
		const stores_array = single ? [stores] : stores;
		if (!stores_array.every(Boolean)) {
			throw new Error('derived() expects stores as input, got a falsy value');
		}
		const auto = fn.length < 2;
		return readable(initial_value, (set, update) => {
			let started = false;
			const values = [];
			let pending = 0;
			let cleanup = noop;
			const sync = () => {
				if (pending) {
					return;
				}
				cleanup();
				const result = fn(single ? values[0] : values, set, update);
				if (auto) {
					set(result);
				} else {
					cleanup = is_function(result) ? result : noop;
				}
			};
			const unsubscribers = stores_array.map((store, i) =>
				subscribe(
					store,
					(value) => {
						values[i] = value;
						pending &= ~(1 << i);
						if (started) {
							sync();
						}
					},
					() => {
						pending |= 1 << i;
					}
				)
			);
			started = true;
			sync();
			return function stop() {
				run_all(unsubscribers);
				cleanup();
				// We need to set this to false because callbacks can still happen despite having unsubscribed:
				// Callbacks might already be placed in the queue which doesn't know it should no longer
				// invoke this derived store.
				started = false;
			};
		});
	}

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var browserPolyfill = {exports: {}};

	(function (module, exports) {
		(function (global, factory) {
		  {
		    factory(module);
		  }
		})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : commonjsGlobal, function (module) {

		  if (!globalThis.chrome?.runtime?.id) {
		    throw new Error("This script should only be loaded in a browser extension.");
		  }

		  if (typeof globalThis.browser === "undefined" || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) {
		    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received."; // Wrapping the bulk of this polyfill in a one-time-use function is a minor
		    // optimization for Firefox. Since Spidermonkey does not fully parse the
		    // contents of a function until the first time it's called, and since it will
		    // never actually need to be called, this allows the polyfill to be included
		    // in Firefox nearly for free.

		    const wrapAPIs = extensionAPIs => {
		      // NOTE: apiMetadata is associated to the content of the api-metadata.json file
		      // at build time by replacing the following "include" with the content of the
		      // JSON file.
		      const apiMetadata = {
		        "alarms": {
		          "clear": {
		            "minArgs": 0,
		            "maxArgs": 1
		          },
		          "clearAll": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "get": {
		            "minArgs": 0,
		            "maxArgs": 1
		          },
		          "getAll": {
		            "minArgs": 0,
		            "maxArgs": 0
		          }
		        },
		        "bookmarks": {
		          "create": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "get": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getChildren": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getRecent": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getSubTree": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getTree": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "move": {
		            "minArgs": 2,
		            "maxArgs": 2
		          },
		          "remove": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "removeTree": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "search": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "update": {
		            "minArgs": 2,
		            "maxArgs": 2
		          }
		        },
		        "browserAction": {
		          "disable": {
		            "minArgs": 0,
		            "maxArgs": 1,
		            "fallbackToNoCallback": true
		          },
		          "enable": {
		            "minArgs": 0,
		            "maxArgs": 1,
		            "fallbackToNoCallback": true
		          },
		          "getBadgeBackgroundColor": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getBadgeText": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getPopup": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getTitle": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "openPopup": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "setBadgeBackgroundColor": {
		            "minArgs": 1,
		            "maxArgs": 1,
		            "fallbackToNoCallback": true
		          },
		          "setBadgeText": {
		            "minArgs": 1,
		            "maxArgs": 1,
		            "fallbackToNoCallback": true
		          },
		          "setIcon": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "setPopup": {
		            "minArgs": 1,
		            "maxArgs": 1,
		            "fallbackToNoCallback": true
		          },
		          "setTitle": {
		            "minArgs": 1,
		            "maxArgs": 1,
		            "fallbackToNoCallback": true
		          }
		        },
		        "browsingData": {
		          "remove": {
		            "minArgs": 2,
		            "maxArgs": 2
		          },
		          "removeCache": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "removeCookies": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "removeDownloads": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "removeFormData": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "removeHistory": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "removeLocalStorage": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "removePasswords": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "removePluginData": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "settings": {
		            "minArgs": 0,
		            "maxArgs": 0
		          }
		        },
		        "commands": {
		          "getAll": {
		            "minArgs": 0,
		            "maxArgs": 0
		          }
		        },
		        "contextMenus": {
		          "remove": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "removeAll": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "update": {
		            "minArgs": 2,
		            "maxArgs": 2
		          }
		        },
		        "cookies": {
		          "get": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getAll": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getAllCookieStores": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "remove": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "set": {
		            "minArgs": 1,
		            "maxArgs": 1
		          }
		        },
		        "devtools": {
		          "inspectedWindow": {
		            "eval": {
		              "minArgs": 1,
		              "maxArgs": 2,
		              "singleCallbackArg": false
		            }
		          },
		          "panels": {
		            "create": {
		              "minArgs": 3,
		              "maxArgs": 3,
		              "singleCallbackArg": true
		            },
		            "elements": {
		              "createSidebarPane": {
		                "minArgs": 1,
		                "maxArgs": 1
		              }
		            }
		          }
		        },
		        "downloads": {
		          "cancel": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "download": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "erase": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getFileIcon": {
		            "minArgs": 1,
		            "maxArgs": 2
		          },
		          "open": {
		            "minArgs": 1,
		            "maxArgs": 1,
		            "fallbackToNoCallback": true
		          },
		          "pause": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "removeFile": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "resume": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "search": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "show": {
		            "minArgs": 1,
		            "maxArgs": 1,
		            "fallbackToNoCallback": true
		          }
		        },
		        "extension": {
		          "isAllowedFileSchemeAccess": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "isAllowedIncognitoAccess": {
		            "minArgs": 0,
		            "maxArgs": 0
		          }
		        },
		        "history": {
		          "addUrl": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "deleteAll": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "deleteRange": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "deleteUrl": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getVisits": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "search": {
		            "minArgs": 1,
		            "maxArgs": 1
		          }
		        },
		        "i18n": {
		          "detectLanguage": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getAcceptLanguages": {
		            "minArgs": 0,
		            "maxArgs": 0
		          }
		        },
		        "identity": {
		          "launchWebAuthFlow": {
		            "minArgs": 1,
		            "maxArgs": 1
		          }
		        },
		        "idle": {
		          "queryState": {
		            "minArgs": 1,
		            "maxArgs": 1
		          }
		        },
		        "management": {
		          "get": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getAll": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "getSelf": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "setEnabled": {
		            "minArgs": 2,
		            "maxArgs": 2
		          },
		          "uninstallSelf": {
		            "minArgs": 0,
		            "maxArgs": 1
		          }
		        },
		        "notifications": {
		          "clear": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "create": {
		            "minArgs": 1,
		            "maxArgs": 2
		          },
		          "getAll": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "getPermissionLevel": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "update": {
		            "minArgs": 2,
		            "maxArgs": 2
		          }
		        },
		        "pageAction": {
		          "getPopup": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getTitle": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "hide": {
		            "minArgs": 1,
		            "maxArgs": 1,
		            "fallbackToNoCallback": true
		          },
		          "setIcon": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "setPopup": {
		            "minArgs": 1,
		            "maxArgs": 1,
		            "fallbackToNoCallback": true
		          },
		          "setTitle": {
		            "minArgs": 1,
		            "maxArgs": 1,
		            "fallbackToNoCallback": true
		          },
		          "show": {
		            "minArgs": 1,
		            "maxArgs": 1,
		            "fallbackToNoCallback": true
		          }
		        },
		        "permissions": {
		          "contains": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getAll": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "remove": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "request": {
		            "minArgs": 1,
		            "maxArgs": 1
		          }
		        },
		        "runtime": {
		          "getBackgroundPage": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "getPlatformInfo": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "openOptionsPage": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "requestUpdateCheck": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "sendMessage": {
		            "minArgs": 1,
		            "maxArgs": 3
		          },
		          "sendNativeMessage": {
		            "minArgs": 2,
		            "maxArgs": 2
		          },
		          "setUninstallURL": {
		            "minArgs": 1,
		            "maxArgs": 1
		          }
		        },
		        "sessions": {
		          "getDevices": {
		            "minArgs": 0,
		            "maxArgs": 1
		          },
		          "getRecentlyClosed": {
		            "minArgs": 0,
		            "maxArgs": 1
		          },
		          "restore": {
		            "minArgs": 0,
		            "maxArgs": 1
		          }
		        },
		        "storage": {
		          "local": {
		            "clear": {
		              "minArgs": 0,
		              "maxArgs": 0
		            },
		            "get": {
		              "minArgs": 0,
		              "maxArgs": 1
		            },
		            "getBytesInUse": {
		              "minArgs": 0,
		              "maxArgs": 1
		            },
		            "remove": {
		              "minArgs": 1,
		              "maxArgs": 1
		            },
		            "set": {
		              "minArgs": 1,
		              "maxArgs": 1
		            }
		          },
		          "managed": {
		            "get": {
		              "minArgs": 0,
		              "maxArgs": 1
		            },
		            "getBytesInUse": {
		              "minArgs": 0,
		              "maxArgs": 1
		            }
		          },
		          "sync": {
		            "clear": {
		              "minArgs": 0,
		              "maxArgs": 0
		            },
		            "get": {
		              "minArgs": 0,
		              "maxArgs": 1
		            },
		            "getBytesInUse": {
		              "minArgs": 0,
		              "maxArgs": 1
		            },
		            "remove": {
		              "minArgs": 1,
		              "maxArgs": 1
		            },
		            "set": {
		              "minArgs": 1,
		              "maxArgs": 1
		            }
		          }
		        },
		        "tabs": {
		          "captureVisibleTab": {
		            "minArgs": 0,
		            "maxArgs": 2
		          },
		          "create": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "detectLanguage": {
		            "minArgs": 0,
		            "maxArgs": 1
		          },
		          "discard": {
		            "minArgs": 0,
		            "maxArgs": 1
		          },
		          "duplicate": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "executeScript": {
		            "minArgs": 1,
		            "maxArgs": 2
		          },
		          "get": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getCurrent": {
		            "minArgs": 0,
		            "maxArgs": 0
		          },
		          "getZoom": {
		            "minArgs": 0,
		            "maxArgs": 1
		          },
		          "getZoomSettings": {
		            "minArgs": 0,
		            "maxArgs": 1
		          },
		          "goBack": {
		            "minArgs": 0,
		            "maxArgs": 1
		          },
		          "goForward": {
		            "minArgs": 0,
		            "maxArgs": 1
		          },
		          "highlight": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "insertCSS": {
		            "minArgs": 1,
		            "maxArgs": 2
		          },
		          "move": {
		            "minArgs": 2,
		            "maxArgs": 2
		          },
		          "query": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "reload": {
		            "minArgs": 0,
		            "maxArgs": 2
		          },
		          "remove": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "removeCSS": {
		            "minArgs": 1,
		            "maxArgs": 2
		          },
		          "sendMessage": {
		            "minArgs": 2,
		            "maxArgs": 3
		          },
		          "setZoom": {
		            "minArgs": 1,
		            "maxArgs": 2
		          },
		          "setZoomSettings": {
		            "minArgs": 1,
		            "maxArgs": 2
		          },
		          "update": {
		            "minArgs": 1,
		            "maxArgs": 2
		          }
		        },
		        "topSites": {
		          "get": {
		            "minArgs": 0,
		            "maxArgs": 0
		          }
		        },
		        "webNavigation": {
		          "getAllFrames": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "getFrame": {
		            "minArgs": 1,
		            "maxArgs": 1
		          }
		        },
		        "webRequest": {
		          "handlerBehaviorChanged": {
		            "minArgs": 0,
		            "maxArgs": 0
		          }
		        },
		        "windows": {
		          "create": {
		            "minArgs": 0,
		            "maxArgs": 1
		          },
		          "get": {
		            "minArgs": 1,
		            "maxArgs": 2
		          },
		          "getAll": {
		            "minArgs": 0,
		            "maxArgs": 1
		          },
		          "getCurrent": {
		            "minArgs": 0,
		            "maxArgs": 1
		          },
		          "getLastFocused": {
		            "minArgs": 0,
		            "maxArgs": 1
		          },
		          "remove": {
		            "minArgs": 1,
		            "maxArgs": 1
		          },
		          "update": {
		            "minArgs": 2,
		            "maxArgs": 2
		          }
		        }
		      };

		      if (Object.keys(apiMetadata).length === 0) {
		        throw new Error("api-metadata.json has not been included in browser-polyfill");
		      }
		      /**
		       * A WeakMap subclass which creates and stores a value for any key which does
		       * not exist when accessed, but behaves exactly as an ordinary WeakMap
		       * otherwise.
		       *
		       * @param {function} createItem
		       *        A function which will be called in order to create the value for any
		       *        key which does not exist, the first time it is accessed. The
		       *        function receives, as its only argument, the key being created.
		       */


		      class DefaultWeakMap extends WeakMap {
		        constructor(createItem, items = undefined) {
		          super(items);
		          this.createItem = createItem;
		        }

		        get(key) {
		          if (!this.has(key)) {
		            this.set(key, this.createItem(key));
		          }

		          return super.get(key);
		        }

		      }
		      /**
		       * Returns true if the given object is an object with a `then` method, and can
		       * therefore be assumed to behave as a Promise.
		       *
		       * @param {*} value The value to test.
		       * @returns {boolean} True if the value is thenable.
		       */


		      const isThenable = value => {
		        return value && typeof value === "object" && typeof value.then === "function";
		      };
		      /**
		       * Creates and returns a function which, when called, will resolve or reject
		       * the given promise based on how it is called:
		       *
		       * - If, when called, `chrome.runtime.lastError` contains a non-null object,
		       *   the promise is rejected with that value.
		       * - If the function is called with exactly one argument, the promise is
		       *   resolved to that value.
		       * - Otherwise, the promise is resolved to an array containing all of the
		       *   function's arguments.
		       *
		       * @param {object} promise
		       *        An object containing the resolution and rejection functions of a
		       *        promise.
		       * @param {function} promise.resolve
		       *        The promise's resolution function.
		       * @param {function} promise.reject
		       *        The promise's rejection function.
		       * @param {object} metadata
		       *        Metadata about the wrapped method which has created the callback.
		       * @param {boolean} metadata.singleCallbackArg
		       *        Whether or not the promise is resolved with only the first
		       *        argument of the callback, alternatively an array of all the
		       *        callback arguments is resolved. By default, if the callback
		       *        function is invoked with only a single argument, that will be
		       *        resolved to the promise, while all arguments will be resolved as
		       *        an array if multiple are given.
		       *
		       * @returns {function}
		       *        The generated callback function.
		       */


		      const makeCallback = (promise, metadata) => {
		        return (...callbackArgs) => {
		          if (extensionAPIs.runtime.lastError) {
		            promise.reject(new Error(extensionAPIs.runtime.lastError.message));
		          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
		            promise.resolve(callbackArgs[0]);
		          } else {
		            promise.resolve(callbackArgs);
		          }
		        };
		      };

		      const pluralizeArguments = numArgs => numArgs == 1 ? "argument" : "arguments";
		      /**
		       * Creates a wrapper function for a method with the given name and metadata.
		       *
		       * @param {string} name
		       *        The name of the method which is being wrapped.
		       * @param {object} metadata
		       *        Metadata about the method being wrapped.
		       * @param {integer} metadata.minArgs
		       *        The minimum number of arguments which must be passed to the
		       *        function. If called with fewer than this number of arguments, the
		       *        wrapper will raise an exception.
		       * @param {integer} metadata.maxArgs
		       *        The maximum number of arguments which may be passed to the
		       *        function. If called with more than this number of arguments, the
		       *        wrapper will raise an exception.
		       * @param {boolean} metadata.singleCallbackArg
		       *        Whether or not the promise is resolved with only the first
		       *        argument of the callback, alternatively an array of all the
		       *        callback arguments is resolved. By default, if the callback
		       *        function is invoked with only a single argument, that will be
		       *        resolved to the promise, while all arguments will be resolved as
		       *        an array if multiple are given.
		       *
		       * @returns {function(object, ...*)}
		       *       The generated wrapper function.
		       */


		      const wrapAsyncFunction = (name, metadata) => {
		        return function asyncFunctionWrapper(target, ...args) {
		          if (args.length < metadata.minArgs) {
		            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
		          }

		          if (args.length > metadata.maxArgs) {
		            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
		          }

		          return new Promise((resolve, reject) => {
		            if (metadata.fallbackToNoCallback) {
		              // This API method has currently no callback on Chrome, but it return a promise on Firefox,
		              // and so the polyfill will try to call it with a callback first, and it will fallback
		              // to not passing the callback if the first call fails.
		              try {
		                target[name](...args, makeCallback({
		                  resolve,
		                  reject
		                }, metadata));
		              } catch (cbError) {
		                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + "falling back to call it without a callback: ", cbError);
		                target[name](...args); // Update the API method metadata, so that the next API calls will not try to
		                // use the unsupported callback anymore.

		                metadata.fallbackToNoCallback = false;
		                metadata.noCallback = true;
		                resolve();
		              }
		            } else if (metadata.noCallback) {
		              target[name](...args);
		              resolve();
		            } else {
		              target[name](...args, makeCallback({
		                resolve,
		                reject
		              }, metadata));
		            }
		          });
		        };
		      };
		      /**
		       * Wraps an existing method of the target object, so that calls to it are
		       * intercepted by the given wrapper function. The wrapper function receives,
		       * as its first argument, the original `target` object, followed by each of
		       * the arguments passed to the original method.
		       *
		       * @param {object} target
		       *        The original target object that the wrapped method belongs to.
		       * @param {function} method
		       *        The method being wrapped. This is used as the target of the Proxy
		       *        object which is created to wrap the method.
		       * @param {function} wrapper
		       *        The wrapper function which is called in place of a direct invocation
		       *        of the wrapped method.
		       *
		       * @returns {Proxy<function>}
		       *        A Proxy object for the given method, which invokes the given wrapper
		       *        method in its place.
		       */


		      const wrapMethod = (target, method, wrapper) => {
		        return new Proxy(method, {
		          apply(targetMethod, thisObj, args) {
		            return wrapper.call(thisObj, target, ...args);
		          }

		        });
		      };

		      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
		      /**
		       * Wraps an object in a Proxy which intercepts and wraps certain methods
		       * based on the given `wrappers` and `metadata` objects.
		       *
		       * @param {object} target
		       *        The target object to wrap.
		       *
		       * @param {object} [wrappers = {}]
		       *        An object tree containing wrapper functions for special cases. Any
		       *        function present in this object tree is called in place of the
		       *        method in the same location in the `target` object tree. These
		       *        wrapper methods are invoked as described in {@see wrapMethod}.
		       *
		       * @param {object} [metadata = {}]
		       *        An object tree containing metadata used to automatically generate
		       *        Promise-based wrapper functions for asynchronous. Any function in
		       *        the `target` object tree which has a corresponding metadata object
		       *        in the same location in the `metadata` tree is replaced with an
		       *        automatically-generated wrapper function, as described in
		       *        {@see wrapAsyncFunction}
		       *
		       * @returns {Proxy<object>}
		       */

		      const wrapObject = (target, wrappers = {}, metadata = {}) => {
		        let cache = Object.create(null);
		        let handlers = {
		          has(proxyTarget, prop) {
		            return prop in target || prop in cache;
		          },

		          get(proxyTarget, prop, receiver) {
		            if (prop in cache) {
		              return cache[prop];
		            }

		            if (!(prop in target)) {
		              return undefined;
		            }

		            let value = target[prop];

		            if (typeof value === "function") {
		              // This is a method on the underlying object. Check if we need to do
		              // any wrapping.
		              if (typeof wrappers[prop] === "function") {
		                // We have a special-case wrapper for this method.
		                value = wrapMethod(target, target[prop], wrappers[prop]);
		              } else if (hasOwnProperty(metadata, prop)) {
		                // This is an async method that we have metadata for. Create a
		                // Promise wrapper for it.
		                let wrapper = wrapAsyncFunction(prop, metadata[prop]);
		                value = wrapMethod(target, target[prop], wrapper);
		              } else {
		                // This is a method that we don't know or care about. Return the
		                // original method, bound to the underlying object.
		                value = value.bind(target);
		              }
		            } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
		              // This is an object that we need to do some wrapping for the children
		              // of. Create a sub-object wrapper for it with the appropriate child
		              // metadata.
		              value = wrapObject(value, wrappers[prop], metadata[prop]);
		            } else if (hasOwnProperty(metadata, "*")) {
		              // Wrap all properties in * namespace.
		              value = wrapObject(value, wrappers[prop], metadata["*"]);
		            } else {
		              // We don't need to do any wrapping for this property,
		              // so just forward all access to the underlying object.
		              Object.defineProperty(cache, prop, {
		                configurable: true,
		                enumerable: true,

		                get() {
		                  return target[prop];
		                },

		                set(value) {
		                  target[prop] = value;
		                }

		              });
		              return value;
		            }

		            cache[prop] = value;
		            return value;
		          },

		          set(proxyTarget, prop, value, receiver) {
		            if (prop in cache) {
		              cache[prop] = value;
		            } else {
		              target[prop] = value;
		            }

		            return true;
		          },

		          defineProperty(proxyTarget, prop, desc) {
		            return Reflect.defineProperty(cache, prop, desc);
		          },

		          deleteProperty(proxyTarget, prop) {
		            return Reflect.deleteProperty(cache, prop);
		          }

		        }; // Per contract of the Proxy API, the "get" proxy handler must return the
		        // original value of the target if that value is declared read-only and
		        // non-configurable. For this reason, we create an object with the
		        // prototype set to `target` instead of using `target` directly.
		        // Otherwise we cannot return a custom object for APIs that
		        // are declared read-only and non-configurable, such as `chrome.devtools`.
		        //
		        // The proxy handlers themselves will still use the original `target`
		        // instead of the `proxyTarget`, so that the methods and properties are
		        // dereferenced via the original targets.

		        let proxyTarget = Object.create(target);
		        return new Proxy(proxyTarget, handlers);
		      };
		      /**
		       * Creates a set of wrapper functions for an event object, which handles
		       * wrapping of listener functions that those messages are passed.
		       *
		       * A single wrapper is created for each listener function, and stored in a
		       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`
		       * retrieve the original wrapper, so that  attempts to remove a
		       * previously-added listener work as expected.
		       *
		       * @param {DefaultWeakMap<function, function>} wrapperMap
		       *        A DefaultWeakMap object which will create the appropriate wrapper
		       *        for a given listener function when one does not exist, and retrieve
		       *        an existing one when it does.
		       *
		       * @returns {object}
		       */


		      const wrapEvent = wrapperMap => ({
		        addListener(target, listener, ...args) {
		          target.addListener(wrapperMap.get(listener), ...args);
		        },

		        hasListener(target, listener) {
		          return target.hasListener(wrapperMap.get(listener));
		        },

		        removeListener(target, listener) {
		          target.removeListener(wrapperMap.get(listener));
		        }

		      });

		      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {
		        if (typeof listener !== "function") {
		          return listener;
		        }
		        /**
		         * Wraps an onRequestFinished listener function so that it will return a
		         * `getContent()` property which returns a `Promise` rather than using a
		         * callback API.
		         *
		         * @param {object} req
		         *        The HAR entry object representing the network request.
		         */


		        return function onRequestFinished(req) {
		          const wrappedReq = wrapObject(req, {}
		          /* wrappers */
		          , {
		            getContent: {
		              minArgs: 0,
		              maxArgs: 0
		            }
		          });
		          listener(wrappedReq);
		        };
		      });
		      const onMessageWrappers = new DefaultWeakMap(listener => {
		        if (typeof listener !== "function") {
		          return listener;
		        }
		        /**
		         * Wraps a message listener function so that it may send responses based on
		         * its return value, rather than by returning a sentinel value and calling a
		         * callback. If the listener function returns a Promise, the response is
		         * sent when the promise either resolves or rejects.
		         *
		         * @param {*} message
		         *        The message sent by the other end of the channel.
		         * @param {object} sender
		         *        Details about the sender of the message.
		         * @param {function(*)} sendResponse
		         *        A callback which, when called with an arbitrary argument, sends
		         *        that value as a response.
		         * @returns {boolean}
		         *        True if the wrapped listener returned a Promise, which will later
		         *        yield a response. False otherwise.
		         */


		        return function onMessage(message, sender, sendResponse) {
		          let didCallSendResponse = false;
		          let wrappedSendResponse;
		          let sendResponsePromise = new Promise(resolve => {
		            wrappedSendResponse = function (response) {
		              didCallSendResponse = true;
		              resolve(response);
		            };
		          });
		          let result;

		          try {
		            result = listener(message, sender, wrappedSendResponse);
		          } catch (err) {
		            result = Promise.reject(err);
		          }

		          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called
		          // wrappedSendResponse synchronously, we can exit earlier
		          // because there will be no response sent from this listener.

		          if (result !== true && !isResultThenable && !didCallSendResponse) {
		            return false;
		          } // A small helper to send the message if the promise resolves
		          // and an error if the promise rejects (a wrapped sendMessage has
		          // to translate the message into a resolved promise or a rejected
		          // promise).


		          const sendPromisedResult = promise => {
		            promise.then(msg => {
		              // send the message value.
		              sendResponse(msg);
		            }, error => {
		              // Send a JSON representation of the error if the rejected value
		              // is an instance of error, or the object itself otherwise.
		              let message;

		              if (error && (error instanceof Error || typeof error.message === "string")) {
		                message = error.message;
		              } else {
		                message = "An unexpected error occurred";
		              }

		              sendResponse({
		                __mozWebExtensionPolyfillReject__: true,
		                message
		              });
		            }).catch(err => {
		              // Print an error on the console if unable to send the response.
		              console.error("Failed to send onMessage rejected reply", err);
		            });
		          }; // If the listener returned a Promise, send the resolved value as a
		          // result, otherwise wait the promise related to the wrappedSendResponse
		          // callback to resolve and send it as a response.


		          if (isResultThenable) {
		            sendPromisedResult(result);
		          } else {
		            sendPromisedResult(sendResponsePromise);
		          } // Let Chrome know that the listener is replying.


		          return true;
		        };
		      });

		      const wrappedSendMessageCallback = ({
		        reject,
		        resolve
		      }, reply) => {
		        if (extensionAPIs.runtime.lastError) {
		          // Detect when none of the listeners replied to the sendMessage call and resolve
		          // the promise to undefined as in Firefox.
		          // See https://github.com/mozilla/webextension-polyfill/issues/130
		          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
		            resolve();
		          } else {
		            reject(new Error(extensionAPIs.runtime.lastError.message));
		          }
		        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
		          // Convert back the JSON representation of the error into
		          // an Error instance.
		          reject(new Error(reply.message));
		        } else {
		          resolve(reply);
		        }
		      };

		      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
		        if (args.length < metadata.minArgs) {
		          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
		        }

		        if (args.length > metadata.maxArgs) {
		          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
		        }

		        return new Promise((resolve, reject) => {
		          const wrappedCb = wrappedSendMessageCallback.bind(null, {
		            resolve,
		            reject
		          });
		          args.push(wrappedCb);
		          apiNamespaceObj.sendMessage(...args);
		        });
		      };

		      const staticWrappers = {
		        devtools: {
		          network: {
		            onRequestFinished: wrapEvent(onRequestFinishedWrappers)
		          }
		        },
		        runtime: {
		          onMessage: wrapEvent(onMessageWrappers),
		          onMessageExternal: wrapEvent(onMessageWrappers),
		          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
		            minArgs: 1,
		            maxArgs: 3
		          })
		        },
		        tabs: {
		          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
		            minArgs: 2,
		            maxArgs: 3
		          })
		        }
		      };
		      const settingMetadata = {
		        clear: {
		          minArgs: 1,
		          maxArgs: 1
		        },
		        get: {
		          minArgs: 1,
		          maxArgs: 1
		        },
		        set: {
		          minArgs: 1,
		          maxArgs: 1
		        }
		      };
		      apiMetadata.privacy = {
		        network: {
		          "*": settingMetadata
		        },
		        services: {
		          "*": settingMetadata
		        },
		        websites: {
		          "*": settingMetadata
		        }
		      };
		      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
		    }; // The build process adds a UMD wrapper around this file, which makes the
		    // `module` variable available.


		    module.exports = wrapAPIs(chrome);
		  } else {
		    module.exports = globalThis.browser;
		  }
		});
		
	} (browserPolyfill));

	var browserPolyfillExports = browserPolyfill.exports;
	var browser = /*@__PURE__*/getDefaultExportFromCjs(browserPolyfillExports);

	const getFromStorage = async (key) => {
	    try {
	        const result = await browser.storage.local.get(key);
	        return result[key];
	    }
	    catch (error) {
	        console.error(`Error getting ${key} from storage:`, error);
	        return undefined;
	    }
	};
	const setToStorage = async (key, value) => {
	    try {
	        await browser.storage.local.set({ [key]: value });
	    }
	    catch (error) {
	        console.error(`Error setting ${key} in storage:`, error);
	    }
	};
	const StorageService = {
	    getCertificate: () => getFromStorage("certificate"),
	    setCertificate: (certificate) => setToStorage("certificate", certificate),
	    getToken: () => getFromStorage("token"),
	    setToken: (token) => setToStorage("token", token),
	    getBaseUrl: () => getFromStorage("baseUrl"),
	    setBaseUrl: (url) => setToStorage("baseUrl", url),
	    getIsLoggedIn: () => getFromStorage("isLoggedIn"),
	    setIsLoggedIn: (isLoggedIn) => setToStorage("isLoggedIn", isLoggedIn),
	    getEncryptedCertificate: () => getFromStorage("certificate"),
	    setEncryptedCertificate: (key) => setToStorage("certificate", key),
	    getSalt: () => getFromStorage("salt"),
	    setSalt: (salt) => setToStorage("salt", salt),
	    clearStorage: async () => {
	        try {
	            await browser.storage.local.clear();
	        }
	        catch (error) {
	            console.error("Error clearing storage:", error);
	        }
	    },
	};
	const LocalStorageService = {
	    get: (key, parse = false) => {
	        try {
	            const item = localStorage.getItem(key);
	            if (item === null)
	                return null;
	            return parse ? JSON.parse(item) : item;
	        }
	        catch (error) {
	            console.error(`Error getting item ${key} from localStorage:`, error);
	            return null;
	        }
	    },
	    set: (key, value, stringify = false) => {
	        try {
	            const item = stringify ? JSON.stringify(value) : String(value);
	            localStorage.setItem(key, item);
	        }
	        catch (error) {
	            console.error(`Error setting item ${key} in localStorage:`, error);
	        }
	    },
	    remove: (key) => {
	        try {
	            localStorage.removeItem(key);
	        }
	        catch (error) {
	            console.error(`Error removing item ${key} from localStorage:`, error);
	        }
	    },
	    clear: () => {
	        try {
	            localStorage.clear();
	        }
	        catch (error) {
	            console.error("Error clearing localStorage:", error);
	        }
	    },
	};

	let selectedPage = writable("");
	let showAddFolderDrawer = writable(false);
	let showAddGroupDrawer = writable(false);
	let showFolderShareDrawer = writable(false);
	let showFolderRenameDrawer = writable(false);
	let showCredentialShareDrawer = writable(false);
	let showAddUserDrawer = writable(false);
	let allUsersSelected = writable(false);
	let showAddUserToGroupDrawer = writable(false);
	let showRenameGroupDrawer = writable(false);
	let showCredentialDetailsDrawer = writable(false);
	let buttonRef = writable(null);
	let showMoreOptions = writable(false);
	let modalManager = writable(null);
	let DeleteConfirmationModal = writable(false);
	let accessListSelected = writable(false);
	let showMoreGroupOptions = writable(false);
	let toastStore = writable({ show: false, message: "", type: true });
	let selectedSection = writable("SharedFolders");
	let showAddCliDrawer = writable(false);
	let showAddEnvDrawer = writable(false);
	let promptPassword = writable(false);
	let changePassword = writable(false);
	const storedPage = LocalStorageService.get("selectedPage");
	if (storedPage) {
	    selectedPage.set(storedPage);
	}
	else {
	    selectedPage.set("Folders");
	}
	selectedPage.subscribe((value) => {
	    LocalStorageService.set("selectedPage", value);
	});

	let groupStore = writable([]);
	let groupUsers = writable([]);
	let selectedGroup = writable(null);
	const storedGroup = LocalStorageService.get("selectedGroup", true);
	if (storedGroup) {
	    selectedGroup.set(storedGroup);
	}
	else {
	    selectedGroup.set(null);
	}
	selectedGroup.subscribe((value) => {
	    LocalStorageService.set("selectedGroup", value, true);
	});

	let folderStore = writable([]);
	let envStore = writable([]);
	let selectedEnv = writable(null);
	let selectedFolder = writable(undefined);
	selectedFolder.subscribe((value) => {
	    if (value) {
	        LocalStorageService.set("selectedFolder", value, true);
	    }
	});

	/* src/lib/components/basic/icons/multipleFolders.svelte generated by Svelte v4.2.19 */
	const file$1j = "src/lib/components/basic/icons/multipleFolders.svelte";

	function create_fragment$1k(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "d", "M7.75 18H19.25C20.765 18 22 16.765 22 15.25V7.75C22 6.235 20.765 5 19.25 5H13.56L11.56 3H7.75C6.235 3 5 4.235 5 5.75V15.25C5 16.765 6.235 18 7.75 18ZM6.5 5.75C6.5 5.06 7.06 4.5 7.75 4.5H10.94L12.94 6.5H19.25C19.94 6.5 20.5 7.06 20.5 7.75V15.25C20.5 15.94 19.94 16.5 19.25 16.5H7.75C7.06 16.5 6.5 15.94 6.5 15.25V5.75ZM4.75 21H19V19.5H4.75C4.06 19.5 3.5 18.94 3.5 18.25V7H2V18.25C2 19.765 3.235 21 4.75 21Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$1j, 11, 1, 142);
				attr_dev(svg, "width", "24");
				attr_dev(svg, "height", "24");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1j, 4, 0, 39);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1k.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1k($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('MultipleFolders', slots, []);
		let { color } = $$props;

		$$self.$$.on_mount.push(function () {
			if (color === undefined && !('color' in $$props || $$self.$$.bound[$$self.$$.props['color']])) {
				console.warn("<MultipleFolders> was created without expected prop 'color'");
			}
		});

		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MultipleFolders> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class MultipleFolders extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1k, create_fragment$1k, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "MultipleFolders",
				options,
				id: create_fragment$1k.name
			});
		}

		get color() {
			throw new Error("<MultipleFolders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<MultipleFolders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/groupIcon.svelte generated by Svelte v4.2.19 */
	const file$1i = "src/lib/components/basic/icons/groupIcon.svelte";

	function create_fragment$1j(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M7 9C5.07 9 3.5 7.43 3.5 5.5C3.5 3.57 5.07 2 7 2C8.93 2 10.5 3.57 10.5 5.5C10.5 7.43 8.93 9 7 9ZM7 3.5C5.895 3.5 5 4.395 5 5.5C5 6.605 5.895 7.5 7 7.5C8.105 7.5 9 6.605 9 5.5C9 4.395 8.105 3.5 7 3.5ZM13.4999 5.5C13.4999 7.43 15.0699 9 16.9999 9C18.9299 9 20.4999 7.43 20.4999 5.5C20.4999 3.57 18.9299 2 16.9999 2C15.0699 2 13.4999 3.57 13.4999 5.5ZM14.9999 5.5C14.9999 4.395 15.8949 3.5 16.9999 3.5C18.1049 3.5 18.9999 4.395 18.9999 5.5C18.9999 6.605 18.1049 7.5 16.9999 7.5C15.8949 7.5 14.9999 6.605 14.9999 5.5ZM8.49988 12.4999C8.49988 14.4299 10.0699 15.9999 11.9999 15.9999C13.9299 15.9999 15.4999 14.4299 15.4999 12.4999C15.4999 10.5699 13.9299 8.99994 11.9999 8.99994C10.0699 8.99994 8.49988 10.5699 8.49988 12.4999ZM9.99988 12.4999C9.99988 11.3949 10.8949 10.4999 11.9999 10.4999C13.1049 10.4999 13.9999 11.3949 13.9999 12.4999C13.9999 13.6049 13.1049 14.4999 11.9999 14.4999C10.8949 14.4999 9.99988 13.6049 9.99988 12.4999ZM15.9199 19.9249L16.5299 22.1949V22.1899L17.9799 21.7999L17.3699 19.5349C17.0499 18.3349 15.9599 17.4949 14.7149 17.4949H9.2849C8.0449 17.4949 6.9499 18.3349 6.6299 19.5349L6.0199 21.8049L7.4699 22.1949L8.0799 19.9249C8.2249 19.3799 8.7199 18.9999 9.2849 18.9999H14.7149C15.2799 18.9999 15.7749 19.3799 15.9199 19.9249ZM20.4248 12.9249L21.1648 15.6949L22.6148 15.3049L21.8748 12.5399C21.5548 11.3399 20.4648 10.4999 19.2198 10.4999H17.0048V11.9999H19.2198C19.7848 11.9999 20.2798 12.3799 20.4248 12.9249ZM1.38477 15.305L2.83477 15.695V15.69L3.57477 12.92C3.71977 12.375 4.21477 11.995 4.77977 11.995H6.99477V10.495H4.77977C3.53977 10.495 2.44477 11.335 2.12477 12.535L1.38477 15.305Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$1i, 11, 1, 142);
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				add_location(svg, file$1i, 4, 0, 39);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1j.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1j($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('GroupIcon', slots, []);
		let { color } = $$props;

		$$self.$$.on_mount.push(function () {
			if (color === undefined && !('color' in $$props || $$self.$$.bound[$$self.$$.props['color']])) {
				console.warn("<GroupIcon> was created without expected prop 'color'");
			}
		});

		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GroupIcon> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class GroupIcon extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1j, create_fragment$1j, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "GroupIcon",
				options,
				id: create_fragment$1j.name
			});
		}

		get color() {
			throw new Error("<GroupIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<GroupIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/toggle.svelte generated by Svelte v4.2.19 */
	const file$1h = "src/lib/components/basic/toggle.svelte";

	function get_each_context$p(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[3] = list[i];
		return child_ctx;
	}

	// (29:4) {:else}
	function create_else_block$r(ctx) {
		let groupicon;
		let current;

		groupicon = new GroupIcon({
				props: {
					color: /*$selectedPage*/ ctx[0] === /*item*/ ctx[3]
					? 'white'
					: '#85889C'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(groupicon.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(groupicon, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const groupicon_changes = {};

				if (dirty & /*$selectedPage*/ 1) groupicon_changes.color = /*$selectedPage*/ ctx[0] === /*item*/ ctx[3]
				? 'white'
				: '#85889C';

				groupicon.$set(groupicon_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(groupicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(groupicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(groupicon, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$r.name,
			type: "else",
			source: "(29:4) {:else}",
			ctx
		});

		return block;
	}

	// (25:4) {#if item === "Folders"}
	function create_if_block$M(ctx) {
		let multiplefolders;
		let current;

		multiplefolders = new MultipleFolders({
				props: {
					color: /*$selectedPage*/ ctx[0] === 'Folders'
					? 'white'
					: '#85889C'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(multiplefolders.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(multiplefolders, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const multiplefolders_changes = {};

				if (dirty & /*$selectedPage*/ 1) multiplefolders_changes.color = /*$selectedPage*/ ctx[0] === 'Folders'
				? 'white'
				: '#85889C';

				multiplefolders.$set(multiplefolders_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(multiplefolders.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(multiplefolders.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(multiplefolders, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$M.name,
			type: "if",
			source: "(25:4) {#if item === \\\"Folders\\\"}",
			ctx
		});

		return block;
	}

	// (17:2) {#each ["Folders", "Groups"] as item}
	function create_each_block$p(ctx) {
		let button;
		let current_block_type_index;
		let if_block;
		let t0;
		let span;
		let t2;
		let button_class_value;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block$M, create_else_block$r];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*item*/ ctx[3] === "Folders") return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function click_handler() {
			return /*click_handler*/ ctx[2](/*item*/ ctx[3]);
		}

		const block = {
			c: function create() {
				button = element("button");
				if_block.c();
				t0 = space();
				span = element("span");
				span.textContent = `${/*item*/ ctx[3]}`;
				t2 = space();
				attr_dev(span, "class", "ml-2 text-base font-light");
				add_location(span, file$1h, 33, 4, 1195);

				attr_dev(button, "class", button_class_value = "transition-colors duration-75 ease-in w-1/2 px-3 py-1.5 text-lg flex justify-center items-center rounded-lg focus:outline-none " + (/*$selectedPage*/ ctx[0] === /*item*/ ctx[3]
				? 'bg-osvauld-sideListHighlight text-osvauld-plainwhite'
				: 'text-osvauld-quarzowhite') + "");

				add_location(button, file$1h, 19, 3, 656);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				if_blocks[current_block_type_index].m(button, null);
				append_dev(button, t0);
				append_dev(button, span);
				append_dev(button, t2);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", click_handler, false, false, false, false);
					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				if_block.p(ctx, dirty);

				if (!current || dirty & /*$selectedPage*/ 1 && button_class_value !== (button_class_value = "transition-colors duration-75 ease-in w-1/2 px-3 py-1.5 text-lg flex justify-center items-center rounded-lg focus:outline-none " + (/*$selectedPage*/ ctx[0] === /*item*/ ctx[3]
				? 'bg-osvauld-sideListHighlight text-osvauld-plainwhite'
				: 'text-osvauld-quarzowhite') + "")) {
					attr_dev(button, "class", button_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$p.name,
			type: "each",
			source: "(17:2) {#each [\\\"Folders\\\", \\\"Groups\\\"] as item}",
			ctx
		});

		return block;
	}

	function create_fragment$1i(ctx) {
		let div1;
		let div0;
		let current;
		let each_value = ensure_array_like_dev(["Folders", "Groups"]);
		let each_blocks = [];

		for (let i = 0; i < 2; i += 1) {
			each_blocks[i] = create_each_block$p(get_each_context$p(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div1 = element("div");
				div0 = element("div");

				for (let i = 0; i < 2; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(div0, "class", "inline-flex justify-center space-x-1 p-0.5 bg-osvauld-frameblack border border-osvauld-iconblack rounded-xl w-full");
				add_location(div0, file$1h, 15, 1, 480);
				attr_dev(div1, "class", "flex justify-center w-[90%]");
				add_location(div1, file$1h, 14, 0, 437);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, div0);

				for (let i = 0; i < 2; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div0, null);
					}
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*$selectedPage, select*/ 3) {
					each_value = ensure_array_like_dev(["Folders", "Groups"]);
					let i;

					for (i = 0; i < 2; i += 1) {
						const child_ctx = get_each_context$p(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$p(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div0, null);
						}
					}

					group_outros();

					for (i = 2; i < 2; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < 2; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < 2; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1i.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1i($$self, $$props, $$invalidate) {
		let $selectedPage;
		validate_store(selectedPage, 'selectedPage');
		component_subscribe($$self, selectedPage, $$value => $$invalidate(0, $selectedPage = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Toggle', slots, []);

		const select = async choice => {
			selectedPage.set(choice);
			selectedGroup.set(null);
			selectedFolder.set(null);
		};

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Toggle> was created with unknown prop '${key}'`);
		});

		const click_handler = item => select(item);

		$$self.$capture_state = () => ({
			selectedPage,
			selectedGroup,
			selectedFolder,
			MultipleFolders,
			GroupIcon,
			select,
			$selectedPage
		});

		return [$selectedPage, select, click_handler];
	}

	let Toggle$1 = class Toggle extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Toggle",
				options,
				id: create_fragment$1i.name
			});
		}
	};

	/* src/lib/components/basic/icons/userIcon.svelte generated by Svelte v4.2.19 */
	const file$1g = "src/lib/components/basic/icons/userIcon.svelte";

	function create_fragment$1h(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M6.50098 7.5C6.50098 10.535 8.96598 13 12.001 13C15.036 13 17.501 10.535 17.501 7.5C17.501 4.465 15.036 2 12.001 2C8.96598 2 6.50098 4.465 6.50098 7.5ZM8.00098 7.5C8.00098 5.295 9.79598 3.5 12.001 3.5C14.206 3.5 16.001 5.295 16.001 7.5C16.001 9.705 14.206 11.5 12.001 11.5C9.79598 11.5 8.00098 9.705 8.00098 7.5ZM18.5698 18.4139L19.5848 22.1989L21.0348 21.8089L20.0198 18.0239C19.4648 15.9539 17.5748 14.5039 15.4298 14.5039H8.56984C6.41984 14.5039 4.53484 15.9489 3.97984 18.0239L2.96484 21.8089L4.41484 22.1989L5.42984 18.4139C5.80984 16.9939 7.09984 16.0039 8.56984 16.0039H15.4298C16.8998 16.0039 18.1898 16.9939 18.5698 18.4139Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$1g, 11, 1, 142);
				attr_dev(svg, "width", "24");
				attr_dev(svg, "height", "24");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1g, 4, 0, 39);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1h.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1h($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UserIcon', slots, []);
		let { color } = $$props;

		$$self.$$.on_mount.push(function () {
			if (color === undefined && !('color' in $$props || $$self.$$.bound[$$self.$$.props['color']])) {
				console.warn("<UserIcon> was created without expected prop 'color'");
			}
		});

		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UserIcon> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class UserIcon extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1h, create_fragment$1h, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UserIcon",
				options,
				id: create_fragment$1h.name
			});
		}

		get color() {
			throw new Error("<UserIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<UserIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/editIcon.svelte generated by Svelte v4.2.19 */
	const file$1f = "src/lib/components/basic/icons/editIcon.svelte";

	function create_fragment$1g(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M18.4999 2C19.4349 2 20.3149 2.365 20.9749 3.025C21.6349 3.685 21.9999 4.565 21.9999 5.5C21.9999 6.435 21.6349 7.315 20.9749 7.975L7.8049 21.145L2.8749 21.99C2.8349 22 2.7899 22 2.7499 22C2.5549 22 2.3599 21.92 2.2199 21.78C2.0449 21.61 1.9699 21.365 2.0099 21.125L2.8549 16.195L16.0249 3.025C16.6849 2.365 17.5649 2 18.4999 2ZM3.66991 20.33L7.08491 19.745L16.3849 10.445L13.5549 7.615L4.2549 16.915L3.66991 20.33ZM14.6149 6.555L17.4449 9.385L19.9149 6.915C20.2899 6.535 20.4999 6.035 20.4999 5.5C20.4999 4.965 20.2949 4.465 19.9149 4.085C19.1549 3.33 17.8399 3.33 17.0849 4.085L14.6149 6.555ZM10.9999 20.4998H19.9999V21.9998H10.9999V20.4998Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$1f, 11, 1, 154);
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				add_location(svg, file$1f, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1g.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1g($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('EditIcon', slots, []);
		let { color = "#6E7681" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditIcon> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class EditIcon extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1g, create_fragment$1g, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "EditIcon",
				options,
				id: create_fragment$1g.name
			});
		}

		get color() {
			throw new Error("<EditIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<EditIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/userPlus.svelte generated by Svelte v4.2.19 */
	const file$1e = "src/lib/components/basic/icons/userPlus.svelte";

	function create_fragment$1f(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M10.5 13C13.535 13 16 10.535 16 7.5C16 4.465 13.535 2 10.5 2C7.465 2 5 4.465 5 7.5C5 10.535 7.465 13 10.5 13ZM10.5 3.5C12.705 3.5 14.5 5.295 14.5 7.5C14.5 9.705 12.705 11.5 10.5 11.5C8.295 11.5 6.5 9.705 6.5 7.5C6.5 5.295 8.295 3.5 10.5 3.5ZM13.4298 14.5H7.56984C5.42484 14.5 3.53484 15.95 2.97984 18.02L1.96484 21.805L3.41484 22.195L4.42984 18.41C4.80984 16.99 6.09984 16 7.56984 16H13.4298C14.8998 16 16.1898 16.99 16.5698 18.41L17.5848 22.195L19.0348 21.805L18.0198 18.02C17.4648 15.945 15.5798 14.5 13.4298 14.5ZM20.5 11.5H23V13H20.5V15.5H19V13H16.5V11.5H19V9H20.5V11.5Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$1e, 11, 1, 154);
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1e, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1f.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1f($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UserPlus', slots, []);
		let { color = "#A6B0BB" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UserPlus> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class UserPlus extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1f, create_fragment$1f, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UserPlus",
				options,
				id: create_fragment$1f.name
			});
		}

		get color() {
			throw new Error("<UserPlus>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<UserPlus>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/userCheck.svelte generated by Svelte v4.2.19 */
	const file$1d = "src/lib/components/basic/icons/userCheck.svelte";

	function create_fragment$1e(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M10.5 13C7.465 13 5 10.535 5 7.5C5 4.465 7.465 2 10.5 2C13.535 2 16 4.465 16 7.5C16 10.535 13.535 13 10.5 13ZM10.5 3.5C8.295 3.5 6.5 5.295 6.5 7.5C6.5 9.705 8.295 11.5 10.5 11.5C12.705 11.5 14.5 9.705 14.5 7.5C14.5 5.295 12.705 3.5 10.5 3.5ZM17.5848 22.195L16.5698 18.41C16.1898 16.99 14.8998 16 13.4298 16H7.56984C6.09984 16 4.80984 16.99 4.42984 18.41L3.41484 22.195L1.96484 21.805L2.97984 18.02C3.53484 15.945 5.41984 14.5 7.56984 14.5H13.4298C15.5748 14.5 17.4648 15.95 18.0198 18.02L19.0348 21.805L17.5848 22.195ZM17.3652 13.925C17.6102 14.17 17.9302 14.29 18.2502 14.29C18.5702 14.29 18.8902 14.17 19.1352 13.925L22.7802 10.28L21.7202 9.21997L18.2502 12.69L16.7802 11.22L15.7202 12.28L17.3652 13.925Z");
				attr_dev(path, "fill", "#A6E3A1");
				add_location(path, file$1d, 7, 1, 103);
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1d, 0, 0, 0);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1e.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1e($$self, $$props) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('UserCheck', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UserCheck> was created with unknown prop '${key}'`);
		});

		return [];
	}

	class UserCheck extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "UserCheck",
				options,
				id: create_fragment$1e.name
			});
		}
	}

	/* src/lib/components/basic/icons/tick.svelte generated by Svelte v4.2.19 */
	const file$1c = "src/lib/components/basic/icons/tick.svelte";

	function create_fragment$1d(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "d", "M8.74973 18.2898C8.42973 18.2898 8.10973 18.1698 7.86473 17.9248L3.21973 13.2748L4.27973 12.2148L8.74973 16.6848L19.7197 5.71484L20.7797 6.77484L9.63473 17.9198C9.38973 18.1648 9.06973 18.2848 8.74973 18.2848V18.2898Z");
				attr_dev(path, "fill", "#00FF00");
				add_location(path, file$1c, 7, 1, 103);
				attr_dev(svg, "width", "24");
				attr_dev(svg, "height", "24");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1c, 0, 0, 0);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1d.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1d($$self, $$props) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Tick', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tick> was created with unknown prop '${key}'`);
		});

		return [];
	}

	class Tick extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Tick",
				options,
				id: create_fragment$1d.name
			});
		}
	}

	/* src/lib/components/basic/icons/Menu.svelte generated by Svelte v4.2.19 */
	const file$1b = "src/lib/components/basic/icons/Menu.svelte";

	function create_fragment$1c(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M3.5 1.99853C3.5 2.82696 2.82843 3.49853 2 3.49853C1.17157 3.49853 0.5 2.82696 0.5 1.99853C0.5 1.17011 1.17157 0.498535 2 0.498535C2.82843 0.498535 3.5 1.17011 3.5 1.99853ZM8.99961 3.49853C9.82804 3.49853 10.4996 2.82696 10.4996 1.99853C10.4996 1.17011 9.82804 0.498535 8.99961 0.498535C8.17118 0.498535 7.49961 1.17011 7.49961 1.99853C7.49961 2.82696 8.17118 3.49853 8.99961 3.49853ZM15.9992 3.49853C16.8276 3.49853 17.4992 2.82696 17.4992 1.99853C17.4992 1.17011 16.8276 0.498535 15.9992 0.498535C15.1708 0.498535 14.4992 1.17011 14.4992 1.99853C14.4992 2.82696 15.1708 3.49853 15.9992 3.49853Z");
				attr_dev(path, "fill", "#85889C");
				add_location(path, file$1b, 7, 1, 101);
				attr_dev(svg, "width", "18");
				attr_dev(svg, "height", "4");
				attr_dev(svg, "viewBox", "0 0 18 4");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1b, 0, 0, 0);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1c.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1c($$self, $$props) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Menu', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Menu> was created with unknown prop '${key}'`);
		});

		return [];
	}

	class Menu extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Menu",
				options,
				id: create_fragment$1c.name
			});
		}
	}

	/* src/lib/components/basic/icons/folderIcon.svelte generated by Svelte v4.2.19 */
	const file$1a = "src/lib/components/basic/icons/folderIcon.svelte";

	function create_fragment$1b(ctx) {
		let svg;
		let path;
		let path_fill_value;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "d", "M19.25 21H4.75C3.235 21 2 19.765 2 18.25V5.75C2 4.235 3.235 3 4.75 3H9.56L12.06 5.5H19.25C20.765 5.5 22 6.735 22 8.25V18.25C22 19.765 20.765 21 19.25 21ZM4.75 4.5C4.06 4.5 3.5 5.06 3.5 5.75V18.25C3.5 18.94 4.06 19.5 4.75 19.5H19.25C19.94 19.5 20.5 18.94 20.5 18.25V8.25C20.5 7.56 19.94 7 19.25 7H11.44L8.94 4.5H4.75Z");
				attr_dev(path, "fill", path_fill_value = /*color*/ ctx[0] || '#85889C');
				add_location(path, file$1a, 11, 1, 142);
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$1a, 4, 0, 39);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1 && path_fill_value !== (path_fill_value = /*color*/ ctx[0] || '#85889C')) {
					attr_dev(path, "fill", path_fill_value);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1b.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1b($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('FolderIcon', slots, []);
		let { color } = $$props;

		$$self.$$.on_mount.push(function () {
			if (color === undefined && !('color' in $$props || $$self.$$.bound[$$self.$$.props['color']])) {
				console.warn("<FolderIcon> was created without expected prop 'color'");
			}
		});

		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FolderIcon> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class FolderIcon extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1b, create_fragment$1b, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "FolderIcon",
				options,
				id: create_fragment$1b.name
			});
		}

		get color() {
			throw new Error("<FolderIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<FolderIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/FolderShare.svelte generated by Svelte v4.2.19 */
	const file$19 = "src/lib/components/basic/icons/FolderShare.svelte";

	function create_fragment$1a(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "d", "M16.3141 15.6324L22.5456 9.50347L22.6246 9.4134C22.7415 9.25639 22.7979 9.06248 22.7834 8.86725C22.7689 8.67202 22.6844 8.48857 22.5456 8.35058L16.3141 2.22445L16.2282 2.15101C15.7294 1.77688 14.995 2.13716 14.995 2.8009V5.75241L14.6832 5.7732C9.74599 6.16396 6.85406 9.28869 6.16399 14.9561C6.0753 15.6836 6.90949 16.1395 7.44991 15.6573C9.43282 13.8864 11.4823 12.7862 13.6093 12.3455C13.9502 12.2748 14.2924 12.2208 14.6375 12.1834L14.995 12.1515V15.0559L15.0019 15.1695C15.085 15.7973 15.8458 16.0924 16.3141 15.6324ZM14.7843 7.15473L16.3807 7.04803V4.23093L21.1557 8.92564L16.3807 13.6231V10.6342L14.5017 10.8032H14.4906C12.1308 11.0568 9.90396 12.0019 7.80187 13.5774C8.2148 11.722 8.92012 10.3266 9.84714 9.32749C10.9973 8.0873 12.6047 7.32932 14.7843 7.15473ZM5.46422 3.38566C4.54545 3.38566 3.66431 3.75064 3.01465 4.40031C2.36498 5.04997 2 5.93111 2 6.84988V17.9354C2 18.8541 2.36498 19.7353 3.01465 20.3849C3.66431 21.0346 4.54545 21.3996 5.46422 21.3996H16.5497C17.4685 21.3996 18.3496 21.0346 18.9993 20.3849C19.6489 19.7353 20.0139 18.8541 20.0139 17.9354V16.5497C19.8595 16.5497 20.0139 16.5497 19.7829 16.5497C19.5258 16.5497 19.5393 16.5497 19.3556 16.5497C19.1718 16.5497 19.1288 16.5497 18.9303 16.5497C18.7815 16.5497 18.7589 16.5497 18.6282 16.5497V17.9354C18.6282 18.4866 18.4093 19.0153 18.0195 19.4051C17.6297 19.7949 17.101 20.0139 16.5497 20.0139H5.46422C4.91296 20.0139 4.38427 19.7949 3.99447 19.4051C3.60467 19.0153 3.38569 18.4866 3.38569 17.9354V6.84988C3.38569 6.29862 3.60467 5.76993 3.99447 5.38013C4.38427 4.99033 4.91296 4.77135 5.46422 4.77135H9.62128C9.62128 4.30271 9.62128 4.22798 9.62128 4.04423C9.62128 3.86047 9.62128 4.22798 9.62128 4.04423C9.62128 3.86047 9.62128 4.04423 9.62128 3.38566H5.46422Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$19, 12, 1, 180);
				attr_dev(svg, "width", /*size*/ ctx[1]);
				attr_dev(svg, "height", /*size*/ ctx[1]);
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$19, 5, 0, 69);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}

				if (dirty & /*size*/ 2) {
					attr_dev(svg, "width", /*size*/ ctx[1]);
				}

				if (dirty & /*size*/ 2) {
					attr_dev(svg, "height", /*size*/ ctx[1]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1a.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1a($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('FolderShare', slots, []);
		let { color = "#85889C" } = $$props;
		let { size } = $$props;

		$$self.$$.on_mount.push(function () {
			if (size === undefined && !('size' in $$props || $$self.$$.bound[$$self.$$.props['size']])) {
				console.warn("<FolderShare> was created without expected prop 'size'");
			}
		});

		const writable_props = ['color', 'size'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FolderShare> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
		};

		$$self.$capture_state = () => ({ color, size });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color, size];
	}

	class FolderShare extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1a, create_fragment$1a, safe_not_equal, { color: 0, size: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "FolderShare",
				options,
				id: create_fragment$1a.name
			});
		}

		get color() {
			throw new Error("<FolderShare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<FolderShare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get size() {
			throw new Error("<FolderShare>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set size(value) {
			throw new Error("<FolderShare>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/warning.svelte generated by Svelte v4.2.19 */
	const file$18 = "src/lib/components/basic/icons/warning.svelte";

	function create_fragment$19(ctx) {
		let svg;
		let path;
		let svg_class_value;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M3.33797 25.0004C2.81297 25.0004 2.34047 24.7262 2.07797 24.2712C1.81547 23.8162 1.80964 23.2737 2.07797 22.8129L12.7355 4.16371C12.9921 3.70871 13.4821 3.42871 14.0013 3.42871C14.5205 3.42871 15.0105 3.70871 15.2671 4.16371L25.9305 22.8187C26.193 23.2737 26.1871 23.822 25.9305 24.277C25.668 24.732 25.1955 25.0062 24.6705 25.0062L24.6646 25.0004H3.33797ZM3.84547 23.2504H24.163L14.0013 5.47038L3.83964 23.2504H3.84547ZM14.8763 17.417V11.0004H13.1263V17.417H14.8763ZM15.168 20.3337C15.168 20.978 14.6456 21.5004 14.0013 21.5004C13.357 21.5004 12.8346 20.978 12.8346 20.3337C12.8346 19.6894 13.357 19.167 14.0013 19.167C14.6456 19.167 15.168 19.6894 15.168 20.3337Z");
				add_location(path, file$18, 35, 1, 477);

				attr_dev(svg, "class", svg_class_value = "h-6 w-6 " + (/*copiedToClipboard*/ ctx[0]
				? 'animate-blink text-bright-red'
				: 'text-osvauld-dangerRed') + " svelte-1lgpg4n");

				attr_dev(svg, "fill", "#FF6A6A");
				attr_dev(svg, "viewBox", "0 0 28 29");
				attr_dev(svg, "stroke", "currentColor");
				add_location(svg, file$18, 27, 0, 307);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*copiedToClipboard*/ 1 && svg_class_value !== (svg_class_value = "h-6 w-6 " + (/*copiedToClipboard*/ ctx[0]
				? 'animate-blink text-bright-red'
				: 'text-osvauld-dangerRed') + " svelte-1lgpg4n")) {
					attr_dev(svg, "class", svg_class_value);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$19.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$19($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Warning', slots, []);
		let { copiedToClipboard = false } = $$props;
		const writable_props = ['copiedToClipboard'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Warning> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('copiedToClipboard' in $$props) $$invalidate(0, copiedToClipboard = $$props.copiedToClipboard);
		};

		$$self.$capture_state = () => ({ copiedToClipboard });

		$$self.$inject_state = $$props => {
			if ('copiedToClipboard' in $$props) $$invalidate(0, copiedToClipboard = $$props.copiedToClipboard);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [copiedToClipboard];
	}

	class Warning extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$19, create_fragment$19, safe_not_equal, { copiedToClipboard: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Warning",
				options,
				id: create_fragment$19.name
			});
		}

		get copiedToClipboard() {
			throw new Error("<Warning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set copiedToClipboard(value) {
			throw new Error("<Warning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/eyeScan.svelte generated by Svelte v4.2.19 */
	const file$17 = "src/lib/components/basic/icons/eyeScan.svelte";

	function create_fragment$18(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M4.5 7.5H3V5.75C3 4.235 4.235 3 5.75 3H7.5V4.5H5.75C5.06 4.5 4.5 5.06 4.5 5.75V7.5ZM3.33004 12.335C3.44004 12.565 6.19504 18 12 18V18.005C17.8 18.005 20.555 12.57 20.67 12.34L20.85 11.98L20.65 11.63C20.52 11.4 17.345 6 12 6C6.20004 6 3.44504 11.44 3.33004 11.67L3.16504 12L3.33004 12.335ZM12 16.5C7.90004 16.5 5.52004 13.095 4.86004 12.005C5.52004 10.91 7.90004 7.5 12 7.5C15.755 7.5 18.37 10.905 19.125 12.025C18.445 13.145 16.1 16.5 12 16.5ZM9 12C9 13.655 10.345 15 12 15C13.655 15 15 13.655 15 12C15 10.345 13.655 9 12 9C10.345 9 9 10.345 9 12ZM10.5 12C10.5 11.175 11.175 10.5 12 10.5C12.825 10.5 13.5 11.175 13.5 12C13.5 12.825 12.825 13.5 12 13.5C11.175 13.5 10.5 12.825 10.5 12ZM5.75 21H7.5V19.5H5.75C5.06 19.5 4.5 18.94 4.5 18.25V17H3V18.25C3 19.765 4.235 21 5.75 21ZM18.25 21H16.5V19.5H18.25C18.94 19.5 19.5 18.94 19.5 18.25V16.5H21V18.25C21 19.765 19.765 21 18.25 21ZM19.5 7.5H21V5.75C21 4.235 19.765 3 18.25 3H16.5V4.5H18.25C18.94 4.5 19.5 5.06 19.5 5.75V7.5Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$17, 11, 1, 154);
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$17, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$18.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$18($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('EyeScan', slots, []);
		let { color = "#F2F2F0" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EyeScan> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class EyeScan extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$18, create_fragment$18, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "EyeScan",
				options,
				id: create_fragment$18.name
			});
		}

		get color() {
			throw new Error("<EyeScan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<EyeScan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/fileText.svelte generated by Svelte v4.2.19 */
	const file$16 = "src/lib/components/basic/icons/fileText.svelte";

	function create_fragment$17(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M13.56 2H4V22H20V8.44L13.56 2ZM14 4.56L17.44 8H14V4.56ZM5.5 20.5V3.5H12.5V8.25C12.5 8.94 13.06 9.5 13.75 9.5H18.5V20.5H5.5ZM13 16H7.5V17.5H13V16ZM7.5 12.5H16.5V14H7.5V12.5Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$16, 11, 1, 154);
				attr_dev(svg, "width", "18");
				attr_dev(svg, "height", "18");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$16, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$17.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$17($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('FileText', slots, []);
		let { color = "#F2F2F0" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FileText> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class FileText extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$17, create_fragment$17, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "FileText",
				options,
				id: create_fragment$17.name
			});
		}

		get color() {
			throw new Error("<FileText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<FileText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/key.svelte generated by Svelte v4.2.19 */
	const file$15 = "src/lib/components/basic/icons/key.svelte";

	function create_fragment$16(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				attr_dev(path, "d", "M160 12a84.05 84.05 0 0 0-80.62 107.65l-55.87 55.86A12 12 0 0 0 20 184v40a12 12 0 0 0 12 12h40a12 12 0 0 0 12-12v-12h12a12 12 0 0 0 12-12v-12h12a12 12 0 0 0 8.49-3.51l7.86-7.87A84 84 0 1 0 160 12Zm0 144a59.58 59.58 0 0 1-22.1-4.2a12 12 0 0 0-13.22 2.55L115 164H96a12 12 0 0 0-12 12v12H72a12 12 0 0 0-12 12v12H44v-23l57.65-57.65a12 12 0 0 0 2.55-13.21A60 60 0 1 1 160 156Zm36-80a16 16 0 1 1-16-16a16 16 0 0 1 16 16Z");
				add_location(path, file$15, 10, 2, 173);
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "width", /*size*/ ctx[1]);
				attr_dev(svg, "height", /*size*/ ctx[1]);
				attr_dev(svg, "viewBox", "0 0 256 256");
				add_location(svg, file$15, 5, 0, 74);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}

				if (dirty & /*size*/ 2) {
					attr_dev(svg, "width", /*size*/ ctx[1]);
				}

				if (dirty & /*size*/ 2) {
					attr_dev(svg, "height", /*size*/ ctx[1]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$16.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$16($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Key', slots, []);
		let { color = "#CDD6F4" } = $$props;
		let { size = 16 } = $$props;
		const writable_props = ['color', 'size'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Key> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
		};

		$$self.$capture_state = () => ({ color, size });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color, size];
	}

	class Key extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$16, create_fragment$16, safe_not_equal, { color: 0, size: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Key",
				options,
				id: create_fragment$16.name
			});
		}

		get color() {
			throw new Error("<Key>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<Key>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get size() {
			throw new Error("<Key>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set size(value) {
			throw new Error("<Key>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/linkIcon.svelte generated by Svelte v4.2.19 */
	const file$14 = "src/lib/components/basic/icons/linkIcon.svelte";

	function create_fragment$15(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "d", "M12.5001 2.66602H6.3334V3.66602H11.6267L2.64673 12.646L3.3534 13.3527L12.3334 4.37268V9.66602H13.3334V3.49935C13.3334 3.03935 12.9601 2.66602 12.5001 2.66602Z");
				attr_dev(path, "fill", "#8B949E");
				add_location(path, file$14, 7, 1, 103);
				attr_dev(svg, "width", "24");
				attr_dev(svg, "height", "24");
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$14, 0, 0, 0);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$15.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$15($$self, $$props) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('LinkIcon', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LinkIcon> was created with unknown prop '${key}'`);
		});

		return [];
	}

	class LinkIcon extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$15, create_fragment$15, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "LinkIcon",
				options,
				id: create_fragment$15.name
			});
		}
	}

	/* src/lib/components/dashboard/components/Highlight.svelte generated by Svelte v4.2.19 */
	const file$13 = "src/lib/components/dashboard/components/Highlight.svelte";

	function get_each_context$o(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[4] = list[i];
		return child_ctx;
	}

	// (21:1) {:else}
	function create_else_block$q(ctx) {
		let t_value = /*part*/ ctx[4].text + "";
		let t;

		const block = {
			c: function create() {
				t = text(t_value);
			},
			m: function mount(target, anchor) {
				insert_dev(target, t, anchor);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*parts*/ 1 && t_value !== (t_value = /*part*/ ctx[4].text + "")) set_data_dev(t, t_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$q.name,
			type: "else",
			source: "(21:1) {:else}",
			ctx
		});

		return block;
	}

	// (17:1) {#if part.highlight}
	function create_if_block$L(ctx) {
		let span;
		let t_value = /*part*/ ctx[4].text + "";
		let t;

		const block = {
			c: function create() {
				span = element("span");
				t = text(t_value);
				attr_dev(span, "class", "bg-osvauld-quarzowhite text-osvauld-frameblack");
				add_location(span, file$13, 22, 2, 494);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				append_dev(span, t);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*parts*/ 1 && t_value !== (t_value = /*part*/ ctx[4].text + "")) set_data_dev(t, t_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$L.name,
			type: "if",
			source: "(17:1) {#if part.highlight}",
			ctx
		});

		return block;
	}

	// (16:0) {#each parts as part}
	function create_each_block$o(ctx) {
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (/*part*/ ctx[4].highlight) return create_if_block$L;
			return create_else_block$q;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
			},
			p: function update(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$o.name,
			type: "each",
			source: "(16:0) {#each parts as part}",
			ctx
		});

		return block;
	}

	function create_fragment$14(ctx) {
		let each_1_anchor;
		let each_value = ensure_array_like_dev(/*parts*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$o(get_each_context$o(ctx, each_value, i));
		}

		const block = {
			c: function create() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert_dev(target, each_1_anchor, anchor);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*parts*/ 1) {
					each_value = ensure_array_like_dev(/*parts*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$o(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$o(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$14.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$14($$self, $$props, $$invalidate) {
		let parts;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Highlight', slots, []);
		let { text = "" } = $$props;
		let { query = "" } = $$props;

		function highlightMatch(text, query) {
			const regex = new RegExp(`(${query})`, "gi");
			const parts = text.split(regex);

			return parts.map(part => regex.test(part)
			? { text: part, highlight: true }
			: { text: part, highlight: false });
		}

		const writable_props = ['text', 'query'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Highlight> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('text' in $$props) $$invalidate(1, text = $$props.text);
			if ('query' in $$props) $$invalidate(2, query = $$props.query);
		};

		$$self.$capture_state = () => ({ text, query, highlightMatch, parts });

		$$self.$inject_state = $$props => {
			if ('text' in $$props) $$invalidate(1, text = $$props.text);
			if ('query' in $$props) $$invalidate(2, query = $$props.query);
			if ('parts' in $$props) $$invalidate(0, parts = $$props.parts);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*query, text*/ 6) {
				$$invalidate(0, parts = query.length >= 3
				? highlightMatch(text, query)
				: [{ text, highlight: false }]);
			}
		};

		return [parts, text, query];
	}

	class Highlight extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$14, create_fragment$14, safe_not_equal, { text: 1, query: 2 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Highlight",
				options,
				id: create_fragment$14.name
			});
		}

		get text() {
			throw new Error("<Highlight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set text(value) {
			throw new Error("<Highlight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get query() {
			throw new Error("<Highlight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set query(value) {
			throw new Error("<Highlight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/import.svelte generated by Svelte v4.2.19 */
	const file$12 = "src/lib/components/basic/icons/import.svelte";

	function create_fragment$13(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M12.885 16.675C12.64 16.92 12.32 17.04 12 17.04C11.68 17.04 11.36 16.92 11.115 16.675L6.47 12.03L7.53 10.97L11.25 14.69V3H12.75V14.69L16.47 10.97L17.53 12.03L12.885 16.675ZM19.5 18.25V15.5H21V18.25C21 19.765 19.765 21 18.25 21H5.75C4.235 21 3 19.765 3 18.25V15.5H4.5V18.25C4.5 18.94 5.06 19.5 5.75 19.5H18.25C18.94 19.5 19.5 18.94 19.5 18.25Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$12, 12, 1, 185);
				attr_dev(svg, "width", /*size*/ ctx[1]);
				attr_dev(svg, "height", /*size*/ ctx[1]);
				attr_dev(svg, "viewBox", "0 0 24 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$12, 5, 0, 74);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}

				if (dirty & /*size*/ 2) {
					attr_dev(svg, "width", /*size*/ ctx[1]);
				}

				if (dirty & /*size*/ 2) {
					attr_dev(svg, "height", /*size*/ ctx[1]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$13.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$13($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Import', slots, []);
		let { color = "#6E7681" } = $$props;
		let { size = 32 } = $$props;
		const writable_props = ['color', 'size'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Import> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
		};

		$$self.$capture_state = () => ({ color, size });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
			if ('size' in $$props) $$invalidate(1, size = $$props.size);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color, size];
	}

	class Import extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$13, create_fragment$13, safe_not_equal, { color: 0, size: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Import",
				options,
				id: create_fragment$13.name
			});
		}

		get color() {
			throw new Error("<Import>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<Import>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get size() {
			throw new Error("<Import>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set size(value) {
			throw new Error("<Import>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	const credentialStore = writable([]);
	const selectedCredential = writable(null);
	const searchedCredential = writable(null);

	/*
	Adapted from https://github.com/mattdesl
	Distributed under MIT License https://github.com/mattdesl/eases/blob/master/LICENSE.md
	*/

	/**
	 * https://svelte.dev/docs/svelte-easing
	 * @param {number} t
	 * @returns {number}
	 */
	function cubicInOut(t) {
		return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
	}

	/**
	 * https://svelte.dev/docs/svelte-easing
	 * @param {number} t
	 * @returns {number}
	 */
	function cubicOut(t) {
		const f = t - 1.0;
		return f * f * f + 1.0;
	}

	/**
	 * Animates a `blur` filter alongside an element's opacity.
	 *
	 * https://svelte.dev/docs/svelte-transition#blur
	 * @param {Element} node
	 * @param {import('./public').BlurParams} [params]
	 * @returns {import('./public').TransitionConfig}
	 */
	function blur(
		node,
		{ delay = 0, duration = 400, easing = cubicInOut, amount = 5, opacity = 0 } = {}
	) {
		const style = getComputedStyle(node);
		const target_opacity = +style.opacity;
		const f = style.filter === 'none' ? '' : style.filter;
		const od = target_opacity * (1 - opacity);
		const [value, unit] = split_css_unit(amount);
		return {
			delay,
			duration,
			easing,
			css: (_t, u) => `opacity: ${target_opacity - od * u}; filter: ${f} blur(${u * value}${unit});`
		};
	}

	/**
	 * Animates the x and y positions and the opacity of an element. `in` transitions animate from the provided values, passed as parameters to the element's default values. `out` transitions animate from the element's default values to the provided values.
	 *
	 * https://svelte.dev/docs/svelte-transition#fly
	 * @param {Element} node
	 * @param {import('./public').FlyParams} [params]
	 * @returns {import('./public').TransitionConfig}
	 */
	function fly(
		node,
		{ delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}
	) {
		const style = getComputedStyle(node);
		const target_opacity = +style.opacity;
		const transform = style.transform === 'none' ? '' : style.transform;
		const od = target_opacity * (1 - opacity);
		const [xValue, xUnit] = split_css_unit(x);
		const [yValue, yUnit] = split_css_unit(y);
		return {
			delay,
			duration,
			easing,
			css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * xValue}${xUnit}, ${(1 - t) * yValue}${yUnit});
			opacity: ${target_opacity - od * u}`
		};
	}

	/**
	 * Slides an element in and out.
	 *
	 * https://svelte.dev/docs/svelte-transition#slide
	 * @param {Element} node
	 * @param {import('./public').SlideParams} [params]
	 * @returns {import('./public').TransitionConfig}
	 */
	function slide(node, { delay = 0, duration = 400, easing = cubicOut, axis = 'y' } = {}) {
		const style = getComputedStyle(node);
		const opacity = +style.opacity;
		const primary_property = axis === 'y' ? 'height' : 'width';
		const primary_property_value = parseFloat(style[primary_property]);
		const secondary_properties = axis === 'y' ? ['top', 'bottom'] : ['left', 'right'];
		const capitalized_secondary_properties = secondary_properties.map(
			(e) => `${e[0].toUpperCase()}${e.slice(1)}`
		);
		const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
		const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
		const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
		const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
		const border_width_start_value = parseFloat(
			style[`border${capitalized_secondary_properties[0]}Width`]
		);
		const border_width_end_value = parseFloat(
			style[`border${capitalized_secondary_properties[1]}Width`]
		);
		return {
			delay,
			duration,
			easing,
			css: (t) =>
				'overflow: hidden;' +
				`opacity: ${Math.min(t * 20, 1) * opacity};` +
				`${primary_property}: ${t * primary_property_value}px;` +
				`padding-${secondary_properties[0]}: ${t * padding_start_value}px;` +
				`padding-${secondary_properties[1]}: ${t * padding_end_value}px;` +
				`margin-${secondary_properties[0]}: ${t * margin_start_value}px;` +
				`margin-${secondary_properties[1]}: ${t * margin_end_value}px;` +
				`border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;` +
				`border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
		};
	}

	/**
	 * Animates the opacity and scale of an element. `in` transitions animate from an element's current (default) values to the provided values, passed as parameters. `out` transitions animate from the provided values to an element's default values.
	 *
	 * https://svelte.dev/docs/svelte-transition#scale
	 * @param {Element} node
	 * @param {import('./public').ScaleParams} [params]
	 * @returns {import('./public').TransitionConfig}
	 */
	function scale(
		node,
		{ delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 } = {}
	) {
		const style = getComputedStyle(node);
		const target_opacity = +style.opacity;
		const transform = style.transform === 'none' ? '' : style.transform;
		const sd = 1 - start;
		const od = target_opacity * (1 - opacity);
		return {
			delay,
			duration,
			easing,
			css: (_t, u) => `
			transform: ${transform} scale(${1 - sd * u});
			opacity: ${target_opacity - od * u}
		`
		};
	}

	/******************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
	/* global Reflect, Promise, SuppressedError, Symbol */


	typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
	    var e = new Error(message);
	    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
	};

	/**
	 * Sends a message to the backend.
	 * @example
	 * ```typescript
	 * import { invoke } from '@tauri-apps/api/core';
	 * await invoke('login', { user: 'tauri', password: 'poiwe3h4r5ip3yrhtew9ty' });
	 * ```
	 *
	 * @param cmd The command name.
	 * @param args The optional arguments to pass to the command.
	 * @param options The request options.
	 * @return A promise resolving or rejecting to the backend response.
	 *
	 * @since 1.0.0
	 */
	async function invoke(cmd, args = {}, options) {
	    return window.__TAURI_INTERNALS__.invoke(cmd, args, options);
	}

	// Copyright 2019-2023 Tauri Programme within The Commons Conservancy
	// SPDX-License-Identifier: Apache-2.0
	// SPDX-License-Identifier: MIT
	/**
	 * Read and write to the system clipboard.
	 *
	 * @module
	 */
	/**
	 * Writes plain text to the clipboard.
	 * @example
	 * ```typescript
	 * import { writeText, readText } from '@tauri-apps/plugin-clipboard-manager';
	 * await writeText('Tauri is awesome!');
	 * assert(await readText(), 'Tauri is awesome!');
	 * ```
	 *
	 * @returns A promise indicating the success or failure of the operation.
	 *
	 * @since 2.0.0
	 */
	async function writeText(text, opts) {
	    await invoke('plugin:clipboard-manager|write_text', {
	        label: opts?.label,
	        text
	    });
	}

	const setbackground = (type) => {
	    const typeToClassMap = {
	        reader: "bg-osvauld-readerOrange text-osvauld-readerText",
	        manager: "bg-osvauld-managerPurple text-osvauld-managerText",
	    };
	    return typeToClassMap[type] || "";
	};
	const getTokenAndBaseUrl = async () => {
	    const [token, baseUrl] = await Promise.all([
	        StorageService.getToken(),
	        StorageService.getBaseUrl(),
	    ]);
	    return { token, baseUrl };
	};
	const sendMessage = async (action, data = {}) => {
	    try {
	        const response = await browser.runtime.sendMessage({
	            action,
	            data,
	        });
	        return response;
	    }
	    catch (error) {
	        console.error("Error sending message:", error, "\ndata", data, "action\n", action);
	    }
	};
	const writeToClipboard = async (text) => {
	    const tauriEnv = isTauri();
	    if (tauriEnv) {
	        try {
	            await writeText(text);
	        }
	        catch (error) {
	            console.error("Error writing to clipboard:", error);
	        }
	    }
	    else {
	        navigator.clipboard.writeText(text);
	    }
	};
	function isTauri() {
	    // @ts-ignore
	    return typeof window.__TAURI__ !== 'undefined';
	}
	const searchObjects = (query, credentials) => {
	    const searchResults = [];
	    for (const credential of credentials) {
	        for (const prop in credential) {
	            if (typeof credential[prop] === "string" &&
	                credential[prop]
	                    .toLowerCase()
	                    .includes(query.toLowerCase())) {
	                searchResults.push(credential);
	                break;
	            }
	        }
	    }
	    return searchResults;
	};
	const clickOutside = (node) => {
	    const handleClick = (event) => {
	        if (node && !node.contains(event.target) && !event.defaultPrevented) {
	            node.dispatchEvent(new CustomEvent("clickedOutside", node));
	        }
	    };
	    document.addEventListener("click", handleClick, true);
	    return {
	        destroy() {
	            document.removeEventListener("click", handleClick, true);
	        },
	    };
	};
	const generatePassword = (length) => {
	    const lowercaseChars = "abcdefghijklmnopqrstuvwxyz";
	    const uppercaseChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	    const numberChars = "0123456789";
	    const symbolChars = "!@#$%^&*()_";
	    const charSet = lowercaseChars + uppercaseChars + numberChars + symbolChars;
	    const passwordArray = new Uint8Array(length); // For storing random bytes
	    window.crypto.getRandomValues(passwordArray);
	    let password = "";
	    for (let i = 0; i < length; i++) {
	        const randomIndex = passwordArray[i] % charSet.length;
	        password += charSet[randomIndex];
	    }
	    return password;
	};
	const transformAddCredentialPayload = (payload) => {
	    const fieldsMap = {};
	    payload.userFields.forEach((userField) => {
	        userField.fields.forEach((field) => {
	            const key = field.fieldName;
	            if (!fieldsMap[key]) {
	                fieldsMap[key] = {
	                    fieldName: field.fieldName,
	                    fieldType: field.fieldType,
	                    fieldValues: [],
	                };
	            }
	            fieldsMap[key].fieldValues.push({
	                userId: userField.userId,
	                fieldValue: field.fieldValue,
	            });
	        });
	    });
	    const transformedFields = Object.values(fieldsMap);
	    return {
	        name: payload.name,
	        description: payload.description,
	        folderId: payload.folderId,
	        credentialType: payload.credentialType,
	        domain: payload.domain,
	        fields: transformedFields,
	    };
	};
	const getDomain = (urlString) => {
	    let url;
	    try {
	        url = new URL(urlString);
	    }
	    catch (_) {
	        throw new Error("Invalid URL");
	    }
	    const hostname = url.hostname;
	    const parts = hostname.split(".");
	    let domain;
	    if (parts.length > 2) {
	        domain = parts.slice(-2).join(".");
	    }
	    else {
	        domain = hostname;
	    }
	    return domain;
	};

	const fetchCredentialsByFolder = async (folderId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    return fetch(`${baseUrl}/folder/${folderId}/credential`, {
	        headers,
	    }).then((response) => response.json());
	};
	const addCredential = async (payload) => {
	    const headers = new Headers();
	    const transformedPayload = transformAddCredentialPayload(payload);
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify(transformedPayload),
	    });
	    headers.append("Signature", signatureResponse.signature);
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/credential`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify(transformedPayload),
	    }).then((response) => response.json());
	    return response;
	};
	const updateCredential = async (payload, credentialId) => {
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify(payload),
	    });
	    const headers = new Headers();
	    headers.append("Signature", signatureResponse.signature);
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/credential/${credentialId}`, {
	        method: "PUT",
	        headers,
	        body: JSON.stringify(payload),
	    }).then((response) => response.json());
	    return response;
	};
	const fetchCredentialsFieldsByFolderId = async (folderId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("User-Agent", "Insomnia/2023.5.7");
	    const response = await fetch(`${baseUrl}/credentials/fields/${folderId}`, {
	        method: "GET",
	        headers,
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const shareCredentialsWithUsers = async (shareCredential) => {
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify(shareCredential),
	    });
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Signature", signatureResponse.signature);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/share-credentials/users`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify(shareCredential),
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const fetchCredentialsFieldsByIds = async (credentialIds) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/credentials/fields/`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify({ credentialIds }),
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const fetchAllUserUrls = async () => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    const response = await fetch(`${baseUrl}/urls`, {
	        method: "GET",
	        headers,
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const fetchSensitiveFieldsByCredentialId = async (credentialId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    const response = await fetch(`${baseUrl}/credential/${credentialId}/sensitive`, {
	        method: "GET",
	        headers,
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const getSearchFields = async () => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    const response = await fetch(`${baseUrl}/credentials/search`, {
	        method: "GET",
	        headers,
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const editUserPermissionForCredential = async (credentialId, userId, accessType) => {
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify({ userId, accessType }),
	    });
	    const headers = new Headers();
	    headers.append("Signature", signatureResponse.signature);
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/credential/${credentialId}/edit-user-access`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify({ userId, accessType }),
	    }).then((response) => response.json());
	    return response;
	};
	const editGroupPermissionForCredential = async (credentialId, groupId, accessType) => {
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify({ groupId, accessType }),
	    });
	    const headers = new Headers();
	    headers.append("Signature", signatureResponse.signature);
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/credential/${credentialId}/edit-group-access`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify({ groupId, accessType }),
	    }).then((response) => response.json());
	    return response;
	};
	const fetchCredentialUsersForDataSync = async (credentialId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/credential/${credentialId}/users-data-sync`, {
	        method: "GET",
	        headers,
	    }).then((response) => response.json());
	    return response;
	};
	const removeCredential = async (credentialId) => {
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: credentialId,
	    });
	    const headers = new Headers();
	    headers.append("Signature", signatureResponse.signature);
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/credential/${credentialId}`, {
	        method: "DELETE",
	        headers,
	    }).then((response) => response.json());
	    return response;
	};
	const shareCredentialsWithEnv = async (data) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify(data),
	    });
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    headers.append("Signature", signatureResponse.signature);
	    const response = await fetch(`${baseUrl}/share-credentials/environment`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify(data),
	    }).then((response) => response.json());
	    return response;
	};
	const editEnvCredentialField = async (data) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify(data),
	    });
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    headers.append("Signature", signatureResponse.signature);
	    const response = await fetch(`${baseUrl}/environment/edit-field-name`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify(data),
	    }).then((response) => response.json());
	    return response;
	};
	const getEnvFieldsByCredentialId = async (credentialId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    const response = await fetch(`${baseUrl}/environments/${credentialId}/fields`, {
	        method: "GET",
	        headers,
	    }).then((response) => response.json());
	    return response;
	};
	const getEnvsForCredential = async (credentialId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    const response = await fetch(`${baseUrl}/environments/${credentialId}`, {
	        method: "GET",
	        headers,
	    }).then((response) => response.json());
	    return response;
	};

	const fetchAllFolders = async () => {
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    const options = {
	        method: "GET",
	        headers: {
	            Authorization: `Bearer ${token}`,
	            "Content-Type": "application/json",
	        },
	    };
	    return fetch(`${baseUrl}/folders`, options).then((response) => response.json());
	};
	const fetchFolderUsers = async (folderId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    return fetch(`${baseUrl}/folder/${folderId}/users`, {
	        headers,
	    }).then((response) => response.json());
	};
	const fetchFolderUsersForDataSync = async (folderId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    return fetch(`${baseUrl}/folder/${folderId}/users-data-sync`, {
	        headers,
	    }).then((response) => response.json());
	};
	const fetchFolderGroups = async (folderId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    return await fetch(`${baseUrl}/folder/${folderId}/groups`, {
	        headers,
	    }).then((response) => response.json());
	};
	const createFolder = async (payload) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    console.log(token, baseUrl);
	    const response = await fetch(`${baseUrl}/folder`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify(payload),
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const renameFolder = async (payload, id) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    const response = await fetch(`${baseUrl}/folder/${id}`, {
	        method: "PUT",
	        headers,
	        body: JSON.stringify(payload),
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const shareFolderWithUsers = async (payload) => {
	    const headers = new Headers();
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify(payload),
	    });
	    headers.append("Signature", signatureResponse.signature);
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/share-folder/users`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify(payload),
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const shareFolderWithGroups = async (payload) => {
	    const headers = new Headers();
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify(payload),
	    });
	    headers.append("Signature", signatureResponse.signature);
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/share-folder/groups`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify(payload),
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const editFolderPermissionForUser = async (folderId, userId, accessType) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify({ accessType, userId }),
	    });
	    headers.append("Signature", signatureResponse.signature);
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/folder/${folderId}/edit-user-access`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify({ accessType, userId }),
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const editFolderPermissionForGroup = async (folderId, groupId, accessType) => {
	    const headers = new Headers();
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify({ accessType, groupId }),
	    });
	    headers.append("Signature", signatureResponse.signature);
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/folder/${folderId}/edit-group-access`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify({ accessType, groupId }),
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const removeFolder = async (folderId) => {
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: folderId,
	    });
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    const headers = new Headers();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    headers.append("Signature", signatureResponse.signature);
	    const response = await fetch(`${baseUrl}/folder/${folderId}`, {
	        method: "DELETE",
	        headers,
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const getEnvironments = async () => {
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    const headers = new Headers();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    return fetch(`${baseUrl}/user/environments`, {
	        headers,
	    }).then((response) => response.json());
	};
	const addEnvironment = async (name, cliUser) => {
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    const headers = new Headers();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const payload = {
	        name,
	        cliUser,
	    };
	    return fetch(`${baseUrl}/user/environment`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify(payload),
	    }).then((response) => response.json());
	};
	const fetchEnvFields = async (envId) => {
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    const headers = new Headers();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    return fetch(`${baseUrl}/user/environment/${envId}`, {
	        headers,
	    }).then((response) => response.json());
	};

	const fetchAllUserGroups = async () => {
	    // TODO: change store setting from here.
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    return fetch(`${baseUrl}/groups`, {
	        headers: {
	            Authorization: `Bearer ${token}`,
	        },
	    }).then((response) => response.json());
	};
	const fetchGroupUsers = async (id) => {
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    return await fetch(`${baseUrl}/group/${id}`, {
	        headers: {
	            Authorization: `Bearer ${token}`,
	        },
	    }).then((response) => response.json());
	};
	const createGroup = async (payload) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/group`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify(payload),
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const renameGroup = async (payload, id) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/group/${id}`, {
	        method: "PUT",
	        headers,
	        body: JSON.stringify(payload),
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	// TODO: add type for payload
	const addUserToGroup = async (payload) => {
	    const headers = new Headers();
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify(payload),
	    });
	    headers.append("Signature", signatureResponse.signature);
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/group/members`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify(payload),
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const fetchUsersByGroupIds = async (ids) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const responseJson = fetch(`${baseUrl}/groups/members`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify({ groupIds: ids }),
	    }).then((response) => response.json());
	    return responseJson;
	};
	const shareCredentialsWithGroups = async (payload) => {
	    const headers = new Headers();
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify(payload),
	    });
	    headers.append("Signature", signatureResponse.signature);
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/share-credentials/groups`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify(payload),
	    });
	    if (!response.ok) {
	        throw new Error(`HTTP error! status: ${response.status}`);
	    }
	    return response.json();
	};
	const fetchGroupsWithoutAccess = async (folderId) => {
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    return await fetch(`${baseUrl}/groups/without-access/${folderId}`, {
	        headers: {
	            Authorization: `Bearer ${token}`,
	        },
	    }).then((response) => response.json());
	};
	const fetchCredentialFieldsByGroupId = async (groupId) => {
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    return await fetch(`${baseUrl}/group/${groupId}/credential-fields`, {
	        headers: {
	            Authorization: `Bearer ${token}`,
	        },
	    }).then((response) => response.json());
	};
	const fetchUsersWithoutGroupAccess = async (groupId) => {
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    return await fetch(`${baseUrl}/groups/${groupId}/users/without-access`, {
	        headers: {
	            Authorization: `Bearer ${token}`,
	        },
	    }).then((response) => response.json());
	};
	const fetchCredentialGroups = async (credentialId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    return await fetch(`${baseUrl}/credential/${credentialId}/groups`, {
	        method: "GET",
	        headers,
	    }).then((response) => response.json());
	};
	const removeGroupFromFolder = async (folderId, groupId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    return await fetch(`${baseUrl}/folder/${folderId}/remove-group-access`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify({ groupIds: [groupId] }),
	    }).then((response) => response.json());
	};
	const removeGroupFromCredential = async (credentialId, groupId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    return await fetch(`${baseUrl}/credential/${credentialId}/remove-group-access`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify({ groupIds: [groupId] }),
	    }).then((response) => response.json());
	};
	const removeUserFromGroup = async (groupId, memberId) => {
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify({ memberId, groupId }),
	    });
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Signature", signatureResponse.signature);
	    return await fetch(`${baseUrl}/group/member`, {
	        method: "DELETE",
	        headers,
	        body: JSON.stringify({ memberId, groupId }),
	    }).then((response) => response.json());
	};
	const removeGroup = async (groupId) => {
	    const headers = new Headers();
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: groupId,
	    });
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Signature", signatureResponse.signature);
	    return await fetch(`${baseUrl}/group/${groupId}`, {
	        method: "DELETE",
	        headers,
	    }).then((response) => response.json());
	};

	const fetchSignedUpUsers = async () => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    return await fetch(`${baseUrl}/users/signed-up`, {
	        method: "GET",
	        headers,
	    }).then((response) => response.json());
	};
	// TODO: types for request and response
	const createUser = async (payload) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify(payload),
	    });
	    headers.append("Signature", signatureResponse.signature);
	    const response = await fetch(`${baseUrl}/user/`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify(payload),
	    }).then((response) => response.json());
	    return response;
	};
	const fetchCredentialUsers = async (credentialId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    return await fetch(`${baseUrl}/credential/${credentialId}/users`, {
	        method: "GET",
	        headers,
	    }).then((response) => response.json());
	};
	const removeUserFromFolder = async (folderId, userId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify({ userIds: [userId] }),
	    });
	    headers.append("Signature", signatureResponse.signature);
	    return await fetch(`${baseUrl}/folder/${folderId}/remove-user-access`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify({ userIds: [userId] }),
	    }).then((response) => response.json());
	};
	const removeUserFromCredential = async (credentialId, userId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    const signatureResponse = await sendMessage("hashAndSign", {
	        message: JSON.stringify({ userIds: [userId] }),
	    });
	    headers.append("Signature", signatureResponse.signature);
	    return await fetch(`${baseUrl}/credential/${credentialId}/remove-user-access`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify({ userIds: [userId] }),
	    }).then((response) => response.json());
	};
	const deleteUser = async (userId) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    return await fetch(`${baseUrl}/user/${userId}`, {
	        method: "DELETE",
	        headers,
	    }).then((response) => response.json());
	};
	const checkUserNameExists = async (username, name) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    return await fetch(`${baseUrl}/user/name-availability`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify({ username, name }),
	    }).then((response) => response.json());
	};
	const getUser = async () => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    return await fetch(`${baseUrl}/user`, {
	        method: "GET",
	        headers,
	    }).then((response) => response.json());
	};
	const fetchAllUsers = async () => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    return await fetch(`${baseUrl}/users/all`, {
	        method: "GET",
	        headers,
	    }).then((response) => response.json());
	};
	const addCliUser = async (data) => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    headers.append("Content-Type", "application/json");
	    const response = await fetch(`${baseUrl}/user/cli-user`, {
	        method: "POST",
	        headers,
	        body: JSON.stringify(data),
	    }).then((response) => response.json());
	    return response;
	};
	const fetchCliUsers = async () => {
	    const headers = new Headers();
	    const { token, baseUrl } = await getTokenAndBaseUrl();
	    headers.append("Authorization", `Bearer ${token}`);
	    return await fetch(`${baseUrl}/user/cli-users`, {
	        method: "GET",
	        headers,
	    }).then((response) => response.json());
	};

	const initiateAuth = async (signedText, publicKey) => {
	    const { baseUrl } = await getTokenAndBaseUrl();
	    return await fetch(`${baseUrl}/user/verify`, {
	        method: "POST",
	        body: JSON.stringify({ signature: signedText, publicKey: publicKey }),
	    }).then((res) => res.json());
	};
	const createChallenge = async (publicKey) => {
	    const { baseUrl } = await getTokenAndBaseUrl();
	    return await fetch(`${baseUrl}/user/challenge`, {
	        method: "POST",
	        body: JSON.stringify({ publicKey: publicKey }),
	    }).then((res) => res.json());
	};
	const getRegsitrationChallenge = async (username, tempPassword) => {
	    const { baseUrl } = await getTokenAndBaseUrl();
	    return await fetch(`${baseUrl}/user/temp-login`, {
	        method: "POST",
	        body: JSON.stringify({ username, tempPassword }),
	    }).then((res) => res.json());
	};
	const finalRegistration = async (username, signature, deviceKey, encryptionKey) => {
	    const { baseUrl } = await getTokenAndBaseUrl();
	    return await fetch(`${baseUrl}/user/register`, {
	        method: "POST",
	        body: JSON.stringify({ username, signature, deviceKey, encryptionKey }),
	    }).then((res) => res.json());
	};

	const setFolderStore = async () => {
	    const responseJson = await fetchAllFolders();
	    const sortedData = responseJson.data.sort((a, b) => a.name.localeCompare(b.name));
	    const selectedFolderValue = get_store_value(selectedFolder);
	    if (!selectedFolderValue) {
	        const storedFolder = LocalStorageService.get("selectedFolder", true);
	        console.log("storedFolder", storedFolder);
	        if (storedFolder && storedFolder != "undefined") {
	            for (const folder of sortedData) {
	                if (folder.id === storedFolder.id) {
	                    selectedFolder.set(folder);
	                    console.log(selectedFolder);
	                    if (folder.type === "private") {
	                        selectedSection.set("PrivateFolders");
	                    }
	                    return;
	                }
	            }
	        }
	    }
	    console.log(sortedData);
	    folderStore.set(sortedData);
	};
	const setGroupStore = async () => {
	    const responseJson = await fetchAllUserGroups();
	    const sortedData = responseJson.data.sort((a, b) => a.name.localeCompare(b.name));
	    groupStore.set(sortedData);
	};
	const setCredentialStore = async () => {
	    const selectedFolderValue = get_store_value(selectedFolder);
	    if (!selectedFolderValue) {
	        return;
	    }
	    const responseJson = await fetchCredentialsByFolder(selectedFolderValue.id);
	    if (!responseJson.data) {
	        credentialStore.set([]);
	        return;
	    }
	    const response = await sendMessage("decryptMeta", responseJson.data);
	    credentialStore.set(response);
	};
	const setEnvStore = async () => {
	    const responseJson = await getEnvironments();
	    const envs = responseJson.data;
	    envStore.set(envs);
	};
	const getUserDetails = async () => {
	    const accountDetails = LocalStorageService.get("user", true);
	    let user;
	    if (accountDetails == null) {
	        const userJson = await getUser();
	        user = userJson.data;
	        LocalStorageService.set("user", user, true);
	    }
	    else {
	        user = accountDetails;
	    }
	    return user;
	};

	/* src/lib/components/dashboard/Toggle.svelte generated by Svelte v4.2.19 */
	const file$11 = "src/lib/components/dashboard/Toggle.svelte";

	function get_each_context$n(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[5] = list[i];
		return child_ctx;
	}

	// (31:4) {:else}
	function create_else_block$p(ctx) {
		let span;
		let usericon;
		let current;

		usericon = new UserIcon({
				props: {
					color: /*selectedItem*/ ctx[1] === 'Users'
					? 'white'
					: '#85889C'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				span = element("span");
				create_component(usericon.$$.fragment);
				attr_dev(span, "class", "scale-[0.80]");
				add_location(span, file$11, 35, 5, 1080);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				mount_component(usericon, span, null);
				current = true;
			},
			p: function update(ctx, dirty) {
				const usericon_changes = {};

				if (dirty & /*selectedItem*/ 2) usericon_changes.color = /*selectedItem*/ ctx[1] === 'Users'
				? 'white'
				: '#85889C';

				usericon.$set(usericon_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(usericon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(usericon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				destroy_component(usericon);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$p.name,
			type: "else",
			source: "(31:4) {:else}",
			ctx
		});

		return block;
	}

	// (25:4) {#if item === "Groups" || item === "shared"}
	function create_if_block$K(ctx) {
		let span;
		let groupicon;
		let current;

		groupicon = new GroupIcon({
				props: {
					color: /*selectedItem*/ ctx[1] === 'Groups'
					? 'white'
					: '#85889C'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				span = element("span");
				create_component(groupicon.$$.fragment);
				attr_dev(span, "class", "scale-100");
				add_location(span, file$11, 29, 5, 934);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				mount_component(groupicon, span, null);
				current = true;
			},
			p: function update(ctx, dirty) {
				const groupicon_changes = {};

				if (dirty & /*selectedItem*/ 2) groupicon_changes.color = /*selectedItem*/ ctx[1] === 'Groups'
				? 'white'
				: '#85889C';

				groupicon.$set(groupicon_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(groupicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(groupicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				destroy_component(groupicon);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$K.name,
			type: "if",
			source: "(25:4) {#if item === \\\"Groups\\\" || item === \\\"shared\\\"}",
			ctx
		});

		return block;
	}

	// (16:2) {#each tabs as item}
	function create_each_block$n(ctx) {
		let button;
		let current_block_type_index;
		let if_block;
		let t0;
		let span;
		let t1_value = /*item*/ ctx[5] + "";
		let t1;
		let span_class_value;
		let t2;
		let button_class_value;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block$K, create_else_block$p];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*item*/ ctx[5] === "Groups" || /*item*/ ctx[5] === "shared") return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function click_handler() {
			return /*click_handler*/ ctx[3](/*item*/ ctx[5]);
		}

		const block = {
			c: function create() {
				button = element("button");
				if_block.c();
				t0 = space();
				span = element("span");
				t1 = text(t1_value);
				t2 = space();

				attr_dev(span, "class", span_class_value = /*item*/ ctx[5] === 'Groups' || /*item*/ ctx[5] === 'shared'
				? 'ml-2'
				: 'ml-0');

				add_location(span, file$11, 41, 4, 1224);

				attr_dev(button, "class", button_class_value = "w-1/2 px-6 py-1.5 flex justify-center items-center rounded-lg focus:outline-none transition-colors duration-75 ease-in " + (/*selectedItem*/ ctx[1] === /*item*/ ctx[5]
				? 'bg-osvauld-sideListHighlight text-osvauld-plainwhite'
				: 'text-osvauld-quarzowhite') + "");

				attr_dev(button, "type", "button");
				add_location(button, file$11, 20, 3, 557);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				if_blocks[current_block_type_index].m(button, null);
				append_dev(button, t0);
				append_dev(button, span);
				append_dev(span, t1);
				append_dev(button, t2);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", click_handler, false, false, false, false);
					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(button, t0);
				}

				if ((!current || dirty & /*tabs*/ 1) && t1_value !== (t1_value = /*item*/ ctx[5] + "")) set_data_dev(t1, t1_value);

				if (!current || dirty & /*tabs*/ 1 && span_class_value !== (span_class_value = /*item*/ ctx[5] === 'Groups' || /*item*/ ctx[5] === 'shared'
				? 'ml-2'
				: 'ml-0')) {
					attr_dev(span, "class", span_class_value);
				}

				if (!current || dirty & /*selectedItem, tabs*/ 3 && button_class_value !== (button_class_value = "w-1/2 px-6 py-1.5 flex justify-center items-center rounded-lg focus:outline-none transition-colors duration-75 ease-in " + (/*selectedItem*/ ctx[1] === /*item*/ ctx[5]
				? 'bg-osvauld-sideListHighlight text-osvauld-plainwhite'
				: 'text-osvauld-quarzowhite') + "")) {
					attr_dev(button, "class", button_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$n.name,
			type: "each",
			source: "(16:2) {#each tabs as item}",
			ctx
		});

		return block;
	}

	function create_fragment$12(ctx) {
		let div1;
		let div0;
		let current;
		let each_value = ensure_array_like_dev(/*tabs*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$n(get_each_context$n(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div1 = element("div");
				div0 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(div0, "class", "inline-flex w-full justify-center space-x-1 p-0.5 bg-osvauld-frameblack border border-osvauld-iconblack rounded-xl font-normal text-sm");
				add_location(div0, file$11, 16, 1, 378);
				attr_dev(div1, "class", "flex my-2 w-full justify-center items-center");
				add_location(div1, file$11, 15, 0, 318);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, div0);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div0, null);
					}
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*selectedItem, tabs, select*/ 7) {
					each_value = ensure_array_like_dev(/*tabs*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$n(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$n(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div0, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$12.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$12($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Toggle', slots, []);
		let { tabs = ["Groups", "Users"] } = $$props;
		const dispatch = createEventDispatcher();
		let selectedItem = tabs[0];

		const select = item => {
			$$invalidate(1, selectedItem = item);
			dispatch("select", item);
		};

		const writable_props = ['tabs'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Toggle> was created with unknown prop '${key}'`);
		});

		const click_handler = item => select(item);

		$$self.$$set = $$props => {
			if ('tabs' in $$props) $$invalidate(0, tabs = $$props.tabs);
		};

		$$self.$capture_state = () => ({
			GroupIcon,
			UserIcon,
			createEventDispatcher,
			tabs,
			dispatch,
			selectedItem,
			select
		});

		$$self.$inject_state = $$props => {
			if ('tabs' in $$props) $$invalidate(0, tabs = $$props.tabs);
			if ('selectedItem' in $$props) $$invalidate(1, selectedItem = $$props.selectedItem);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [tabs, selectedItem, select, click_handler];
	}

	class Toggle extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$12, create_fragment$12, safe_not_equal, { tabs: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Toggle",
				options,
				id: create_fragment$12.name
			});
		}

		get tabs() {
			throw new Error("<Toggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set tabs(value) {
			throw new Error("<Toggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/folders/FolderEditor.svelte generated by Svelte v4.2.19 */

	const { Error: Error_1$a, console: console_1$4 } = globals;
	const file$10 = "src/lib/components/dashboard/folders/FolderEditor.svelte";

	// (87:1) {#if addFolder}
	function create_if_block$J(ctx) {
		let toggle;
		let current;

		toggle = new Toggle({
				props: { tabs: ['shared', 'private'] },
				$$inline: true
			});

		toggle.$on("select", /*toggleSelect*/ ctx[7]);

		const block = {
			c: function create() {
				create_component(toggle.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(toggle, target, anchor);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(toggle.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(toggle.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(toggle, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$J.name,
			type: "if",
			source: "(87:1) {#if addFolder}",
			ctx
		});

		return block;
	}

	function create_fragment$11(ctx) {
		let form;
		let div0;
		let span;
		let t0_value = (/*addFolder*/ ctx[2] ? "Create Folder" : "Rename Folder") + "";
		let t0;
		let t1;
		let button0;
		let closepanel;
		let t2;
		let t3;
		let div1;
		let t4;
		let label0;
		let t5_value = (/*addFolder*/ ctx[2] ? "Name:" : "Folder Name") + "";
		let t5;
		let t6;
		let input;
		let t7;
		let label1;
		let t9;
		let textarea;
		let t10;
		let div2;
		let t11;
		let div3;
		let button1;
		let t13;
		let button2;

		let t14_value = (/*$showFolderRenameDrawer*/ ctx[3]
		? "Save Changes"
		: "Add Folder") + "";

		let t14;
		let button2_disabled_value;
		let form_intro;
		let form_outro;
		let current;
		let mounted;
		let dispose;
		closepanel = new ClosePanel({ $$inline: true });
		let if_block = /*addFolder*/ ctx[2] && create_if_block$J(ctx);

		const block = {
			c: function create() {
				form = element("form");
				div0 = element("div");
				span = element("span");
				t0 = text(t0_value);
				t1 = space();
				button0 = element("button");
				create_component(closepanel.$$.fragment);
				t2 = space();
				if (if_block) if_block.c();
				t3 = space();
				div1 = element("div");
				div1.innerHTML = ``;
				t4 = space();
				label0 = element("label");
				t5 = text(t5_value);
				t6 = space();
				input = element("input");
				t7 = space();
				label1 = element("label");
				label1.textContent = "Description:";
				t9 = space();
				textarea = element("textarea");
				t10 = space();
				div2 = element("div");
				div2.innerHTML = ``;
				t11 = space();
				div3 = element("div");
				button1 = element("button");
				button1.textContent = "Cancel";
				t13 = space();
				button2 = element("button");
				t14 = text(t14_value);
				attr_dev(span, "class", "text-[21px] font-medium text-osvauld-quarzowhite");
				add_location(span, file$10, 91, 2, 2445);
				attr_dev(button0, "class", "cursor-pointer p-2");
				attr_dev(button0, "type", "button");
				add_location(button0, file$10, 93, 2, 2569);
				attr_dev(div0, "class", "flex justify-between items-center w-full");
				add_location(div0, file$10, 90, 1, 2388);
				attr_dev(div1, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div1, file$10, 103, 1, 2802);
				attr_dev(label0, "for", "name");
				attr_dev(label0, "class", "font-bold text-base text-osvauld-textActive");
				add_location(label0, file$10, 107, 1, 2897);
				attr_dev(input, "id", "name");
				attr_dev(input, "type", "text");
				input.required = true;
				attr_dev(input, "class", "py-1 rounded-sm items-center text-base bg-osvauld-frameblack border-osvauld-iconblack w-[95%] h-10 mx-2 focus:border-osvauld-iconblack focus:ring-0 form-input");
				attr_dev(input, "autocomplete", "off");
				add_location(input, file$10, 109, 1, 3017);
				attr_dev(label1, "for", "description");
				attr_dev(label1, "class", "font-bold text-base text-osvauld-textActive");
				add_location(label1, file$10, 118, 1, 3294);
				attr_dev(textarea, "id", "description");
				attr_dev(textarea, "class", "py-1 rounded-sm items-center text-base bg-osvauld-frameblack border-osvauld-iconblack w-[95%] h-20 mx-2 focus:border-osvauld-iconblack focus:ring-0 form-textarea");
				add_location(textarea, file$10, 120, 1, 3396);
				attr_dev(div2, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div2, file$10, 125, 1, 3641);
				attr_dev(button1, "class", "text-osvauld-fadedCancel font-medium text-base py-[5px] px-[15px] rounded-md hover:text-osvauld-quarzowhite hover:bg-osvauld-cancelBackground");
				attr_dev(button1, "type", "button");
				add_location(button1, file$10, 130, 2, 3795);
				attr_dev(button2, "class", "border border-osvauld-iconblack py-[5px] px-[15px] text-base font-medium text-osvauld-textActive rounded-md hover:bg-osvauld-carolinablue hover:border-osvauld-carolinablue hover:text-osvauld-frameblack");
				attr_dev(button2, "type", "submit");
				button2.disabled = button2_disabled_value = !/*name*/ ctx[0];
				add_location(button2, file$10, 134, 2, 4034);
				attr_dev(div3, "class", "flex justify-end items-center gap-4 w-full");
				add_location(div3, file$10, 129, 1, 3736);
				attr_dev(form, "class", "p-4 bg-osvauld-frameblack border border-osvauld-activeBorder rounded-3xl w-[32rem] h-[25rem] flex flex-col items-start justify-center gap-3");
				add_location(form, file$10, 85, 0, 2139);
			},
			l: function claim(nodes) {
				throw new Error_1$a("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, form, anchor);
				append_dev(form, div0);
				append_dev(div0, span);
				append_dev(span, t0);
				append_dev(div0, t1);
				append_dev(div0, button0);
				mount_component(closepanel, button0, null);
				append_dev(form, t2);
				if (if_block) if_block.m(form, null);
				append_dev(form, t3);
				append_dev(form, div1);
				append_dev(form, t4);
				append_dev(form, label0);
				append_dev(label0, t5);
				append_dev(form, t6);
				append_dev(form, input);
				set_input_value(input, /*name*/ ctx[0]);
				append_dev(form, t7);
				append_dev(form, label1);
				append_dev(form, t9);
				append_dev(form, textarea);
				set_input_value(textarea, /*description*/ ctx[1]);
				append_dev(form, t10);
				append_dev(form, div2);
				append_dev(form, t11);
				append_dev(form, div3);
				append_dev(div3, button1);
				append_dev(div3, t13);
				append_dev(div3, button2);
				append_dev(button2, t14);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", prevent_default(/*handleClose*/ ctx[6]), false, true, false, false),
						action_destroyer(autofocus$5.call(null, input)),
						listen_dev(input, "input", /*input_input_handler*/ ctx[8]),
						listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[9]),
						listen_dev(button1, "click", prevent_default(/*handleClose*/ ctx[6]), false, true, false, false),
						listen_dev(
							form,
							"submit",
							prevent_default(function () {
								if (is_function(/*addFolder*/ ctx[2]
								? /*addFolderFunc*/ ctx[5]
								: /*renameFolderFunc*/ ctx[4])) (/*addFolder*/ ctx[2]
								? /*addFolderFunc*/ ctx[5]
								: /*renameFolderFunc*/ ctx[4]).apply(this, arguments);
							}),
							false,
							true,
							false,
							false
						)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, [dirty]) {
				ctx = new_ctx;
				if ((!current || dirty & /*addFolder*/ 4) && t0_value !== (t0_value = (/*addFolder*/ ctx[2] ? "Create Folder" : "Rename Folder") + "")) set_data_dev(t0, t0_value);

				if (/*addFolder*/ ctx[2]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*addFolder*/ 4) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$J(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(form, t3);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}

				if ((!current || dirty & /*addFolder*/ 4) && t5_value !== (t5_value = (/*addFolder*/ ctx[2] ? "Name:" : "Folder Name") + "")) set_data_dev(t5, t5_value);

				if (dirty & /*name*/ 1 && input.value !== /*name*/ ctx[0]) {
					set_input_value(input, /*name*/ ctx[0]);
				}

				if (dirty & /*description*/ 2) {
					set_input_value(textarea, /*description*/ ctx[1]);
				}

				if ((!current || dirty & /*$showFolderRenameDrawer*/ 8) && t14_value !== (t14_value = (/*$showFolderRenameDrawer*/ ctx[3]
				? "Save Changes"
				: "Add Folder") + "")) set_data_dev(t14, t14_value);

				if (!current || dirty & /*name*/ 1 && button2_disabled_value !== (button2_disabled_value = !/*name*/ ctx[0])) {
					prop_dev(button2, "disabled", button2_disabled_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closepanel.$$.fragment, local);
				transition_in(if_block);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (form_outro) form_outro.end(1);
						form_intro = create_in_transition(form, fly, {});
						form_intro.start();
					});
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(closepanel.$$.fragment, local);
				transition_out(if_block);
				if (form_intro) form_intro.invalidate();

				if (local) {
					form_outro = create_out_transition(form, fly, {});
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(form);
				}

				destroy_component(closepanel);
				if (if_block) if_block.d();
				if (detaching && form_outro) form_outro.end();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$11.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function autofocus$5(node) {
		node.focus();
	}

	function instance$11($$self, $$props, $$invalidate) {
		let $folderStore;
		let $selectedFolder;
		let $showFolderRenameDrawer;
		validate_store(folderStore, 'folderStore');
		component_subscribe($$self, folderStore, $$value => $$invalidate(11, $folderStore = $$value));
		validate_store(selectedFolder, 'selectedFolder');
		component_subscribe($$self, selectedFolder, $$value => $$invalidate(12, $selectedFolder = $$value));
		validate_store(showFolderRenameDrawer, 'showFolderRenameDrawer');
		component_subscribe($$self, showFolderRenameDrawer, $$value => $$invalidate(3, $showFolderRenameDrawer = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('FolderEditor', slots, []);
		let { name = "" } = $$props;
		let { description = "" } = $$props;
		let { addFolder = true } = $$props;
		let selectedTab = "shared";

		const renameFolderFunc = async () => {
			const payload = { name, description };

			if ($selectedFolder == undefined) {
				showFolderRenameDrawer.set(false);
				throw new Error("folder not selected");
			}

			const renameResponse = await renameFolder(payload, $selectedFolder.id);
			await setFolderStore();
			showFolderRenameDrawer.set(false);

			const actionMessage = renameResponse.success
			? "Folder Successfully Renamed"
			: "Failed to Rename folder";

			toastStore.set({
				type: renameResponse.success,
				message: actionMessage,
				show: true
			});
		};

		const addFolderFunc = async () => {
			const payload = {
				name,
				description,
				sharedFolder: selectedTab === "shared"
			};

			const folderResponse = await createFolder(payload);
			await setFolderStore();

			for (const folder of $folderStore) {
				if (folder.id == folderResponse.data.folderId) {
					selectedFolder.set(folder);
					break;
				}
			}

			showAddFolderDrawer.set(false);

			const actionMessage = folderResponse.success
			? "Folder Successfully Created"
			: "Failed to Create folder";

			toastStore.set({
				type: folderResponse.success,
				message: actionMessage,
				show: true
			});
		};

		const handleClose = () => {
			showFolderRenameDrawer.set(false);
			showAddFolderDrawer.set(false);
		};

		const toggleSelect = e => {
			selectedTab = e.detail;
		};

		onMount(() => {
			console.log("mounted");
		});

		const writable_props = ['name', 'description', 'addFolder'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$4.warn(`<FolderEditor> was created with unknown prop '${key}'`);
		});

		function input_input_handler() {
			name = this.value;
			$$invalidate(0, name);
		}

		function textarea_input_handler() {
			description = this.value;
			$$invalidate(1, description);
		}

		$$self.$$set = $$props => {
			if ('name' in $$props) $$invalidate(0, name = $$props.name);
			if ('description' in $$props) $$invalidate(1, description = $$props.description);
			if ('addFolder' in $$props) $$invalidate(2, addFolder = $$props.addFolder);
		};

		$$self.$capture_state = () => ({
			createFolder,
			renameFolder,
			showAddFolderDrawer,
			folderStore,
			selectedFolder,
			toastStore,
			showFolderRenameDrawer,
			ClosePanel,
			setFolderStore,
			fly,
			Toggle,
			onMount,
			name,
			description,
			addFolder,
			selectedTab,
			autofocus: autofocus$5,
			renameFolderFunc,
			addFolderFunc,
			handleClose,
			toggleSelect,
			$folderStore,
			$selectedFolder,
			$showFolderRenameDrawer
		});

		$$self.$inject_state = $$props => {
			if ('name' in $$props) $$invalidate(0, name = $$props.name);
			if ('description' in $$props) $$invalidate(1, description = $$props.description);
			if ('addFolder' in $$props) $$invalidate(2, addFolder = $$props.addFolder);
			if ('selectedTab' in $$props) selectedTab = $$props.selectedTab;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			name,
			description,
			addFolder,
			$showFolderRenameDrawer,
			renameFolderFunc,
			addFolderFunc,
			handleClose,
			toggleSelect,
			input_input_handler,
			textarea_input_handler
		];
	}

	class FolderEditor extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$11, create_fragment$11, safe_not_equal, { name: 0, description: 1, addFolder: 2 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "FolderEditor",
				options,
				id: create_fragment$11.name
			});
		}

		get name() {
			throw new Error_1$a("<FolderEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set name(value) {
			throw new Error_1$a("<FolderEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get description() {
			throw new Error_1$a("<FolderEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set description(value) {
			throw new Error_1$a("<FolderEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get addFolder() {
			throw new Error_1$a("<FolderEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set addFolder(value) {
			throw new Error_1$a("<FolderEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/folderAdd.svelte generated by Svelte v4.2.19 */
	const file$$ = "src/lib/components/basic/icons/folderAdd.svelte";

	function create_fragment$10(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "fill-rule", "evenodd");
				attr_dev(path, "clip-rule", "evenodd");
				attr_dev(path, "d", "M12.06 5.5H19.25C20.765 5.5 22 6.735 22 8.25V18.25C22 19.765 20.765 21 19.25 21H4.75C3.235 21 2 19.765 2 18.25V5.75C2 4.235 3.235 3 4.75 3H9.56L12.06 5.5ZM19.25 19.5C19.94 19.5 20.5 18.94 20.5 18.25V8.25C20.5 7.56 19.94 7 19.25 7H11.44L8.94 4.5H4.75C4.06 4.5 3.5 5.06 3.5 5.75V18.25C3.5 18.94 4.06 19.5 4.75 19.5H19.25ZM11.25 9.75H12.75V12.5H15.5V14H12.75V16.75H11.25V14H8.5V12.5H11.25V9.75Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$$, 11, 1, 154);
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 25 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$$, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$10.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$10($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('FolderAdd', slots, []);
		let { color = "#85889C" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FolderAdd> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class FolderAdd extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$10, create_fragment$10, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "FolderAdd",
				options,
				id: create_fragment$10.name
			});
		}

		get color() {
			throw new Error("<FolderAdd>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<FolderAdd>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/environmentAdd.svelte generated by Svelte v4.2.19 */
	const file$_ = "src/lib/components/basic/icons/environmentAdd.svelte";

	function create_fragment$$(ctx) {
		let svg;
		let path0;
		let path1;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path0 = svg_element("path");
				path1 = svg_element("path");
				attr_dev(path0, "d", "M2.59143 12.1226V11.8774C4.02714 11.7239 4.73 10.952 4.73 9.46995V6.76611C4.73 5.12004 5.28714 4.45198 6.66429 4.45198H7.05429V3H6.51714C4.21429 3 3.12857 4.14202 3.12857 6.53891V8.83198C3.12857 10.4781 2.59143 11.0227 1 11.0227V12.9773C2.59143 12.9773 3.12857 13.5219 3.12857 15.168V17.4611C3.12857 19.858 4.21286 21 6.51714 21H7.05429V19.5495H6.66429C5.28714 19.5495 4.73 18.8815 4.73 17.2354V14.5301C4.73 13.0495 4.02714 12.2776 2.59143 12.1226ZM21.4086 11.8774V12.1226C19.9729 12.2776 19.27 13.0495 19.27 14.5301V17.2354C19.27 18.8815 18.7129 19.5495 17.3357 19.5495H16.9457V21H17.4829C19.7871 21 20.8714 19.858 20.8714 17.4611V15.168C20.8714 13.5219 21.4086 12.9773 23 12.9773V11.0227C21.4086 11.0227 20.8714 10.4781 20.8714 8.83198V6.53891C20.8714 4.14202 19.7857 3 17.4829 3H16.9457V4.45047H17.3357C18.7129 4.45047 19.27 5.11853 19.27 6.76461V9.46995C19.27 10.9505 19.9729 11.7224 21.4086 11.8774Z");
				attr_dev(path0, "fill", /*color*/ ctx[0]);
				add_location(path0, file$_, 11, 1, 154);
				attr_dev(path1, "d", "M12.75 8.75H11.25V11.5H8.5V13H11.25V15.75H12.75V13H15.5V11.5H12.75V8.75Z");
				attr_dev(path1, "fill", /*color*/ ctx[0]);
				add_location(path1, file$_, 15, 1, 1099);
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 25 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$_, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path0);
				append_dev(svg, path1);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path0, "fill", /*color*/ ctx[0]);
				}

				if (dirty & /*color*/ 1) {
					attr_dev(path1, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$$.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$$($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('EnvironmentAdd', slots, []);
		let { color = "#BFC0CC" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EnvironmentAdd> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class EnvironmentAdd extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$$, create_fragment$$, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "EnvironmentAdd",
				options,
				id: create_fragment$$.name
			});
		}

		get color() {
			throw new Error("<EnvironmentAdd>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<EnvironmentAdd>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/icons/existingEnvironment.svelte generated by Svelte v4.2.19 */
	const file$Z = "src/lib/components/basic/icons/existingEnvironment.svelte";

	function create_fragment$_(ctx) {
		let svg;
		let path;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				path = svg_element("path");
				attr_dev(path, "d", "M2.59143 12.1226V11.8774C4.02714 11.7239 4.73 10.952 4.73 9.46995V6.76611C4.73 5.12004 5.28714 4.45198 6.66429 4.45198H7.05429V3H6.51714C4.21429 3 3.12857 4.14202 3.12857 6.53891V8.83198C3.12857 10.4781 2.59143 11.0227 1 11.0227V12.9773C2.59143 12.9773 3.12857 13.5219 3.12857 15.168V17.4611C3.12857 19.858 4.21286 21 6.51714 21H7.05429V19.5495H6.66429C5.28714 19.5495 4.73 18.8815 4.73 17.2354V14.5301C4.73 13.0495 4.02714 12.2776 2.59143 12.1226ZM21.4086 11.8774V12.1226C19.9729 12.2776 19.27 13.0495 19.27 14.5301V17.2354C19.27 18.8815 18.7129 19.5495 17.3357 19.5495H16.9457V21H17.4829C19.7871 21 20.8714 19.858 20.8714 17.4611V15.168C20.8714 13.5219 21.4086 12.9773 23 12.9773V11.0227C21.4086 11.0227 20.8714 10.4781 20.8714 8.83198V6.53891C20.8714 4.14202 19.7857 3 17.4829 3H16.9457V4.45047H17.3357C18.7129 4.45047 19.27 5.11853 19.27 6.76461V9.46995C19.27 10.9505 19.9729 11.7224 21.4086 11.8774Z");
				attr_dev(path, "fill", /*color*/ ctx[0]);
				add_location(path, file$Z, 11, 1, 154);
				attr_dev(svg, "width", "20");
				attr_dev(svg, "height", "20");
				attr_dev(svg, "viewBox", "0 0 25 24");
				attr_dev(svg, "fill", "none");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				add_location(svg, file$Z, 4, 0, 51);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, path);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 1) {
					attr_dev(path, "fill", /*color*/ ctx[0]);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$_.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$_($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ExistingEnvironment', slots, []);
		let { color = "#85889C" } = $$props;
		const writable_props = ['color'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ExistingEnvironment> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		$$self.$capture_state = () => ({ color });

		$$self.$inject_state = $$props => {
			if ('color' in $$props) $$invalidate(0, color = $$props.color);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [color];
	}

	class ExistingEnvironment extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$_, create_fragment$_, safe_not_equal, { color: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ExistingEnvironment",
				options,
				id: create_fragment$_.name
			});
		}

		get color() {
			throw new Error("<ExistingEnvironment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<ExistingEnvironment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/folders/FolderSideList.svelte generated by Svelte v4.2.19 */

	const { console: console_1$3 } = globals;
	const file$Y = "src/lib/components/dashboard/folders/FolderSideList.svelte";

	function get_each_context$m(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[34] = list[i];
		return child_ctx;
	}

	function get_each_context_1$7(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[37] = list[i];
		return child_ctx;
	}

	function get_each_context_2$1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[37] = list[i];
		return child_ctx;
	}

	// (77:1) {#if $showAddFolderDrawer}
	function create_if_block_6$7(ctx) {
		let button1;
		let button0;
		let foldereditor;
		let current;
		let mounted;
		let dispose;
		foldereditor = new FolderEditor({ $$inline: true });

		const block = {
			c: function create() {
				button1 = element("button");
				button0 = element("button");
				create_component(foldereditor.$$.fragment);
				attr_dev(button0, "class", "p-6 rounded");
				add_location(button0, file$Y, 107, 3, 2999);
				attr_dev(button1, "class", "fixed inset-0 flex items-center justify-center z-50 backdrop-filter backdrop-blur-[2px]");
				add_location(button1, file$Y, 104, 2, 2861);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button1, anchor);
				append_dev(button1, button0);
				mount_component(foldereditor, button0, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*click_handler*/ ctx[18]), false, false, true, false),
						listen_dev(button1, "click", /*closeModal*/ ctx[13], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(foldereditor.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(foldereditor.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button1);
				}

				destroy_component(foldereditor);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_6$7.name,
			type: "if",
			source: "(77:1) {#if $showAddFolderDrawer}",
			ctx
		});

		return block;
	}

	// (86:1) {#if $showFolderRenameDrawer && $selectedFolder}
	function create_if_block_5$9(ctx) {
		let button1;
		let button0;
		let foldereditor;
		let current;
		let mounted;
		let dispose;

		foldereditor = new FolderEditor({
				props: {
					name: /*$selectedFolder*/ ctx[0]?.name,
					description: /*$selectedFolder*/ ctx[0]?.description,
					addFolder: false
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				button1 = element("button");
				button0 = element("button");
				create_component(foldereditor.$$.fragment);
				attr_dev(button0, "class", "p-6 rounded");
				add_location(button0, file$Y, 116, 3, 3296);
				attr_dev(button1, "class", "fixed inset-0 flex items-center justify-center z-50 backdrop-filter backdrop-blur-[2px]");
				add_location(button1, file$Y, 113, 2, 3158);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button1, anchor);
				append_dev(button1, button0);
				mount_component(foldereditor, button0, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*click_handler_1*/ ctx[17]), false, false, true, false),
						listen_dev(button1, "click", /*closeModal*/ ctx[13], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const foldereditor_changes = {};
				if (dirty[0] & /*$selectedFolder*/ 1) foldereditor_changes.name = /*$selectedFolder*/ ctx[0]?.name;
				if (dirty[0] & /*$selectedFolder*/ 1) foldereditor_changes.description = /*$selectedFolder*/ ctx[0]?.description;
				foldereditor.$set(foldereditor_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(foldereditor.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(foldereditor.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button1);
				}

				destroy_component(foldereditor);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_5$9.name,
			type: "if",
			source: "(86:1) {#if $showFolderRenameDrawer && $selectedFolder}",
			ctx
		});

		return block;
	}

	// (102:3) {#if folder.type === "shared" && folder.name}
	function create_if_block_3$g(ctx) {
		let li;
		let button;
		let foldericon;
		let t0;
		let span1;
		let t1_value = /*folder*/ ctx[37].name + "";
		let t1;
		let t2;
		let span0;
		let t3_value = /*$credentialStore*/ ctx[7]?.length + "";
		let t3;
		let span0_class_value;
		let span1_class_value;
		let t4;
		let div;
		let div_class_value;
		let t5;
		let li_class_value;
		let current;
		let mounted;
		let dispose;

		foldericon = new FolderIcon({
				props: {
					color: /*$selectedFolder*/ ctx[0]?.id == /*folder*/ ctx[37].id || /*hoveringFolderId*/ ctx[4] === /*folder*/ ctx[37].id
					? '#F2F2F0'
					: '#85889C'
				},
				$$inline: true
			});

		let if_block = /*folder*/ ctx[37].accessType === "manager" && create_if_block_4$a(ctx);

		function click_handler_3() {
			return /*click_handler_3*/ ctx[22](/*folder*/ ctx[37]);
		}

		function mouseenter_handler_1() {
			return /*mouseenter_handler_1*/ ctx[23](/*folder*/ ctx[37]);
		}

		const block = {
			c: function create() {
				li = element("li");
				button = element("button");
				create_component(foldericon.$$.fragment);
				t0 = space();
				span1 = element("span");
				t1 = text(t1_value);
				t2 = space();
				span0 = element("span");
				t3 = text(t3_value);
				t4 = space();
				div = element("div");
				if (if_block) if_block.c();
				t5 = space();

				attr_dev(span0, "class", span0_class_value = "ml-2 text-osvauld-fieldText font-light absolute right-0 " + (/*$selectedFolder*/ ctx[0]?.id === /*folder*/ ctx[37].id
				? 'visible delay-200'
				: 'invisible'));

				add_location(span0, file$Y, 149, 7, 4775);

				attr_dev(span1, "class", span1_class_value = "ml-2 text-base font-light overflow-hidden text-ellipsis whitespace-nowrap text-left relative inline-block min-w-[2rem] max-w-[9rem] pr-6 " + (/*$selectedFolder*/ ctx[0]?.id == /*folder*/ ctx[37].id || /*hoveringFolderId*/ ctx[4] === /*folder*/ ctx[37].id
				? 'text-osvauld-sideListTextActive'
				: 'text-osvauld-fieldText'));

				add_location(span1, file$Y, 143, 6, 4432);

				attr_dev(div, "class", div_class_value = "relative z-100 ml-auto flex justify-center items-center " + (/*$selectedFolder*/ ctx[0]?.id == /*folder*/ ctx[37].id || /*hoveringFolderId*/ ctx[4] === /*folder*/ ctx[37].id
				? 'visible'
				: 'invisible'));

				add_location(div, file$Y, 155, 6, 5006);
				attr_dev(button, "class", "w-full p-2 text-lg rounded-2xl flex items-center cursor-pointer");
				add_location(button, file$Y, 135, 5, 4124);

				attr_dev(li, "class", li_class_value = "" + ((/*$selectedFolder*/ ctx[0]?.id == /*folder*/ ctx[37].id
				? 'bg-osvauld-fieldActive rounded-lg text-osvauld-sideListTextActive'
				: 'hover:bg-osvauld-fieldActive text-osvauld-fieldText') + " rounded-md my-0.5 pl-3 pr-3 mr-1 flex items-center"));

				add_location(li, file$Y, 129, 4, 3762);
			},
			m: function mount(target, anchor) {
				insert_dev(target, li, anchor);
				append_dev(li, button);
				mount_component(foldericon, button, null);
				append_dev(button, t0);
				append_dev(button, span1);
				append_dev(span1, t1);
				append_dev(span1, t2);
				append_dev(span1, span0);
				append_dev(span0, t3);
				append_dev(button, t4);
				append_dev(button, div);
				if (if_block) if_block.m(div, null);
				append_dev(li, t5);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "click", click_handler_3, false, false, false, false),
						listen_dev(li, "mouseenter", mouseenter_handler_1, false, false, false, false),
						listen_dev(li, "mouseleave", /*mouseleave_handler_1*/ ctx[24], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const foldericon_changes = {};

				if (dirty[0] & /*$selectedFolder, $folderStore, hoveringFolderId*/ 19) foldericon_changes.color = /*$selectedFolder*/ ctx[0]?.id == /*folder*/ ctx[37].id || /*hoveringFolderId*/ ctx[4] === /*folder*/ ctx[37].id
				? '#F2F2F0'
				: '#85889C';

				foldericon.$set(foldericon_changes);
				if ((!current || dirty[0] & /*$folderStore*/ 2) && t1_value !== (t1_value = /*folder*/ ctx[37].name + "")) set_data_dev(t1, t1_value);
				if ((!current || dirty[0] & /*$credentialStore*/ 128) && t3_value !== (t3_value = /*$credentialStore*/ ctx[7]?.length + "")) set_data_dev(t3, t3_value);

				if (!current || dirty[0] & /*$selectedFolder, $folderStore*/ 3 && span0_class_value !== (span0_class_value = "ml-2 text-osvauld-fieldText font-light absolute right-0 " + (/*$selectedFolder*/ ctx[0]?.id === /*folder*/ ctx[37].id
				? 'visible delay-200'
				: 'invisible'))) {
					attr_dev(span0, "class", span0_class_value);
				}

				if (!current || dirty[0] & /*$selectedFolder, $folderStore, hoveringFolderId*/ 19 && span1_class_value !== (span1_class_value = "ml-2 text-base font-light overflow-hidden text-ellipsis whitespace-nowrap text-left relative inline-block min-w-[2rem] max-w-[9rem] pr-6 " + (/*$selectedFolder*/ ctx[0]?.id == /*folder*/ ctx[37].id || /*hoveringFolderId*/ ctx[4] === /*folder*/ ctx[37].id
				? 'text-osvauld-sideListTextActive'
				: 'text-osvauld-fieldText'))) {
					attr_dev(span1, "class", span1_class_value);
				}

				if (/*folder*/ ctx[37].accessType === "manager") {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*$folderStore*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_4$a(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(div, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}

				if (!current || dirty[0] & /*$selectedFolder, $folderStore, hoveringFolderId*/ 19 && div_class_value !== (div_class_value = "relative z-100 ml-auto flex justify-center items-center " + (/*$selectedFolder*/ ctx[0]?.id == /*folder*/ ctx[37].id || /*hoveringFolderId*/ ctx[4] === /*folder*/ ctx[37].id
				? 'visible'
				: 'invisible'))) {
					attr_dev(div, "class", div_class_value);
				}

				if (!current || dirty[0] & /*$selectedFolder, $folderStore*/ 3 && li_class_value !== (li_class_value = "" + ((/*$selectedFolder*/ ctx[0]?.id == /*folder*/ ctx[37].id
				? 'bg-osvauld-fieldActive rounded-lg text-osvauld-sideListTextActive'
				: 'hover:bg-osvauld-fieldActive text-osvauld-fieldText') + " rounded-md my-0.5 pl-3 pr-3 mr-1 flex items-center"))) {
					attr_dev(li, "class", li_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(foldericon.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(foldericon.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(li);
				}

				destroy_component(foldericon);
				if (if_block) if_block.d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$g.name,
			type: "if",
			source: "(102:3) {#if folder.type === \\\"shared\\\" && folder.name}",
			ctx
		});

		return block;
	}

	// (134:7) {#if folder.accessType === "manager"}
	function create_if_block_4$a(ctx) {
		let button;
		let menu;
		let current;
		let mounted;
		let dispose;
		menu = new Menu({ $$inline: true });

		function click_handler_2(...args) {
			return /*click_handler_2*/ ctx[21](/*folder*/ ctx[37], ...args);
		}

		const block = {
			c: function create() {
				button = element("button");
				create_component(menu.$$.fragment);
				attr_dev(button, "class", "p-2");
				add_location(button, file$Y, 161, 8, 5255);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				mount_component(menu, button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", click_handler_2, false, false, false, false);
					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(menu.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(menu.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(menu);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_4$a.name,
			type: "if",
			source: "(134:7) {#if folder.accessType === \\\"manager\\\"}",
			ctx
		});

		return block;
	}

	// (101:2) {#each $folderStore as folder}
	function create_each_block_2$1(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*folder*/ ctx[37].type === "shared" && /*folder*/ ctx[37].name && create_if_block_3$g(ctx);

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (/*folder*/ ctx[37].type === "shared" && /*folder*/ ctx[37].name) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*$folderStore*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_3$g(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block_2$1.name,
			type: "each",
			source: "(101:2) {#each $folderStore as folder}",
			ctx
		});

		return block;
	}

	// (178:1) {#if $selectedSection === "PrivateFolders"}
	function create_if_block_1$w(ctx) {
		let div;
		let ul;
		let div_transition;
		let current;
		let each_value_1 = ensure_array_like_dev(/*$folderStore*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div = element("div");
				ul = element("ul");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(ul, "class", "overflow-y-scroll w-full overflow-x-hidden scrollbar-thin min-h-[8rem] my-2");
				add_location(ul, file$Y, 206, 3, 6457);
				attr_dev(div, "class", "w-[90%]");
				add_location(div, file$Y, 205, 2, 6383);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, ul);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(ul, null);
					}
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*$selectedFolder, $folderStore, hoveringFolderId, selectFolder, openFolderMenu, $credentialStore*/ 18579) {
					each_value_1 = ensure_array_like_dev(/*$folderStore*/ ctx[1]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$7(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1$7(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(ul, null);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { delay: 0, duration: 100 }, true);
						div_transition.run(1);
					});
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				if (local) {
					if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { delay: 0, duration: 100 }, false);
					div_transition.run(0);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_each(each_blocks, detaching);
				if (detaching && div_transition) div_transition.end();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$w.name,
			type: "if",
			source: "(178:1) {#if $selectedSection === \\\"PrivateFolders\\\"}",
			ctx
		});

		return block;
	}

	// (183:5) {#if folder.type === "private"}
	function create_if_block_2$m(ctx) {
		let li;
		let button1;
		let foldericon;
		let t0;
		let span1;
		let t1_value = /*folder*/ ctx[37].name + "";
		let t1;
		let t2;
		let span0;
		let t3_value = /*$credentialStore*/ ctx[7]?.length + "";
		let t3;
		let span0_class_value;
		let span1_class_value;
		let t4;
		let div;
		let button0;
		let menu;
		let div_class_value;
		let t5;
		let li_class_value;
		let current;
		let mounted;
		let dispose;

		foldericon = new FolderIcon({
				props: {
					color: /*$selectedFolder*/ ctx[0]?.id == /*folder*/ ctx[37].id || /*hoveringFolderId*/ ctx[4] === /*folder*/ ctx[37].id
					? '#F2F2F0'
					: '#85889C'
				},
				$$inline: true
			});

		menu = new Menu({ $$inline: true });

		function click_handler_5(...args) {
			return /*click_handler_5*/ ctx[26](/*folder*/ ctx[37], ...args);
		}

		function click_handler_6() {
			return /*click_handler_6*/ ctx[27](/*folder*/ ctx[37]);
		}

		function mouseenter_handler_2() {
			return /*mouseenter_handler_2*/ ctx[28](/*folder*/ ctx[37]);
		}

		const block = {
			c: function create() {
				li = element("li");
				button1 = element("button");
				create_component(foldericon.$$.fragment);
				t0 = space();
				span1 = element("span");
				t1 = text(t1_value);
				t2 = space();
				span0 = element("span");
				t3 = text(t3_value);
				t4 = space();
				div = element("div");
				button0 = element("button");
				create_component(menu.$$.fragment);
				t5 = space();

				attr_dev(span0, "class", span0_class_value = "ml-2 text-osvauld-fieldText font-light absolute right-0 " + (/*$selectedFolder*/ ctx[0]?.id === /*folder*/ ctx[37].id
				? 'visible delay-200'
				: 'invisible'));

				add_location(span0, file$Y, 230, 9, 7683);

				attr_dev(span1, "class", span1_class_value = "ml-2 text-base font-light overflow-hidden text-ellipsis whitespace-nowrap text-left relative inline-block min-w-[2rem] max-w-[9rem] pr-6 " + (/*$selectedFolder*/ ctx[0]?.id == /*folder*/ ctx[37].id || /*hoveringFolderId*/ ctx[4] === /*folder*/ ctx[37].id
				? 'text-osvauld-sideListTextActive'
				: 'text-osvauld-fieldText'));

				add_location(span1, file$Y, 224, 8, 7328);
				attr_dev(button0, "class", "p-2");
				add_location(button0, file$Y, 241, 9, 8138);

				attr_dev(div, "class", div_class_value = "relative z-100 ml-auto flex justify-center items-center " + (/*$selectedFolder*/ ctx[0]?.id == /*folder*/ ctx[37].id || /*hoveringFolderId*/ ctx[4] === /*folder*/ ctx[37].id
				? 'visible'
				: 'invisible'));

				add_location(div, file$Y, 236, 8, 7925);
				attr_dev(button1, "class", "w-full p-2 text-lg rounded-2xl flex items-center cursor-pointer");
				add_location(button1, file$Y, 216, 7, 7003);

				attr_dev(li, "class", li_class_value = "" + ((/*$selectedFolder*/ ctx[0]?.id === /*folder*/ ctx[37].id
				? 'bg-osvauld-fieldActive rounded-lg text-osvauld-sideListTextActive'
				: 'hover:bg-osvauld-fieldActive text-osvauld-fieldText') + " rounded-md my-0.5 pl-3 pr-3 mr-1 flex items-center"));

				add_location(li, file$Y, 210, 6, 6628);
			},
			m: function mount(target, anchor) {
				insert_dev(target, li, anchor);
				append_dev(li, button1);
				mount_component(foldericon, button1, null);
				append_dev(button1, t0);
				append_dev(button1, span1);
				append_dev(span1, t1);
				append_dev(span1, t2);
				append_dev(span1, span0);
				append_dev(span0, t3);
				append_dev(button1, t4);
				append_dev(button1, div);
				append_dev(div, button0);
				mount_component(menu, button0, null);
				append_dev(li, t5);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", click_handler_5, false, false, false, false),
						listen_dev(button1, "click", click_handler_6, false, false, false, false),
						listen_dev(li, "mouseenter", mouseenter_handler_2, false, false, false, false),
						listen_dev(li, "mouseleave", /*mouseleave_handler_2*/ ctx[29], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const foldericon_changes = {};

				if (dirty[0] & /*$selectedFolder, $folderStore, hoveringFolderId*/ 19) foldericon_changes.color = /*$selectedFolder*/ ctx[0]?.id == /*folder*/ ctx[37].id || /*hoveringFolderId*/ ctx[4] === /*folder*/ ctx[37].id
				? '#F2F2F0'
				: '#85889C';

				foldericon.$set(foldericon_changes);
				if ((!current || dirty[0] & /*$folderStore*/ 2) && t1_value !== (t1_value = /*folder*/ ctx[37].name + "")) set_data_dev(t1, t1_value);
				if ((!current || dirty[0] & /*$credentialStore*/ 128) && t3_value !== (t3_value = /*$credentialStore*/ ctx[7]?.length + "")) set_data_dev(t3, t3_value);

				if (!current || dirty[0] & /*$selectedFolder, $folderStore*/ 3 && span0_class_value !== (span0_class_value = "ml-2 text-osvauld-fieldText font-light absolute right-0 " + (/*$selectedFolder*/ ctx[0]?.id === /*folder*/ ctx[37].id
				? 'visible delay-200'
				: 'invisible'))) {
					attr_dev(span0, "class", span0_class_value);
				}

				if (!current || dirty[0] & /*$selectedFolder, $folderStore, hoveringFolderId*/ 19 && span1_class_value !== (span1_class_value = "ml-2 text-base font-light overflow-hidden text-ellipsis whitespace-nowrap text-left relative inline-block min-w-[2rem] max-w-[9rem] pr-6 " + (/*$selectedFolder*/ ctx[0]?.id == /*folder*/ ctx[37].id || /*hoveringFolderId*/ ctx[4] === /*folder*/ ctx[37].id
				? 'text-osvauld-sideListTextActive'
				: 'text-osvauld-fieldText'))) {
					attr_dev(span1, "class", span1_class_value);
				}

				if (!current || dirty[0] & /*$selectedFolder, $folderStore, hoveringFolderId*/ 19 && div_class_value !== (div_class_value = "relative z-100 ml-auto flex justify-center items-center " + (/*$selectedFolder*/ ctx[0]?.id == /*folder*/ ctx[37].id || /*hoveringFolderId*/ ctx[4] === /*folder*/ ctx[37].id
				? 'visible'
				: 'invisible'))) {
					attr_dev(div, "class", div_class_value);
				}

				if (!current || dirty[0] & /*$selectedFolder, $folderStore*/ 3 && li_class_value !== (li_class_value = "" + ((/*$selectedFolder*/ ctx[0]?.id === /*folder*/ ctx[37].id
				? 'bg-osvauld-fieldActive rounded-lg text-osvauld-sideListTextActive'
				: 'hover:bg-osvauld-fieldActive text-osvauld-fieldText') + " rounded-md my-0.5 pl-3 pr-3 mr-1 flex items-center"))) {
					attr_dev(li, "class", li_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(foldericon.$$.fragment, local);
				transition_in(menu.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(foldericon.$$.fragment, local);
				transition_out(menu.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(li);
				}

				destroy_component(foldericon);
				destroy_component(menu);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$m.name,
			type: "if",
			source: "(183:5) {#if folder.type === \\\"private\\\"}",
			ctx
		});

		return block;
	}

	// (182:4) {#each $folderStore as folder}
	function create_each_block_1$7(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*folder*/ ctx[37].type === "private" && create_if_block_2$m(ctx);

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (/*folder*/ ctx[37].type === "private") {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*$folderStore*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_2$m(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block_1$7.name,
			type: "each",
			source: "(182:4) {#each $folderStore as folder}",
			ctx
		});

		return block;
	}

	// (255:1) {#if $selectedSection === "Environments"}
	function create_if_block$I(ctx) {
		let div;
		let ul;
		let div_transition;
		let current;
		let each_value = ensure_array_like_dev(/*$envStore*/ ctx[9]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$m(get_each_context$m(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div = element("div");
				ul = element("ul");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(ul, "class", "overflow-y-scroll w-full overflow-x-hidden scrollbar-thin min-h-[4rem] max-h-[8.5rem] pl-0");
				add_location(ul, file$Y, 283, 3, 9337);
				attr_dev(div, "class", "w-[90%]");
				add_location(div, file$Y, 282, 2, 9263);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, ul);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(ul, null);
					}
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*$selectedEnv, $envStore, hoveringEnvId, selectEnv*/ 34336) {
					each_value = ensure_array_like_dev(/*$envStore*/ ctx[9]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$m(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$m(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(ul, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { delay: 0, duration: 100 }, true);
						div_transition.run(1);
					});
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				if (local) {
					if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { delay: 0, duration: 100 }, false);
					div_transition.run(0);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_each(each_blocks, detaching);
				if (detaching && div_transition) div_transition.end();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$I.name,
			type: "if",
			source: "(255:1) {#if $selectedSection === \\\"Environments\\\"}",
			ctx
		});

		return block;
	}

	// (259:4) {#each $envStore as env}
	function create_each_block$m(ctx) {
		let li;
		let button;
		let existingenvironment;
		let t0;
		let span;
		let t1_value = /*env*/ ctx[34].name + "";
		let t1;
		let span_class_value;
		let t2;
		let li_class_value;
		let current;
		let mounted;
		let dispose;

		existingenvironment = new ExistingEnvironment({
				props: {
					color: /*$selectedEnv*/ ctx[10]?.id == /*env*/ ctx[34].id || /*hoveringEnvId*/ ctx[5] === /*env*/ ctx[34].id
					? '#F2F2F0'
					: '#85889C'
				},
				$$inline: true
			});

		function click_handler_8() {
			return /*click_handler_8*/ ctx[31](/*env*/ ctx[34]);
		}

		function mouseenter_handler_3() {
			return /*mouseenter_handler_3*/ ctx[32](/*env*/ ctx[34]);
		}

		const block = {
			c: function create() {
				li = element("li");
				button = element("button");
				create_component(existingenvironment.$$.fragment);
				t0 = space();
				span = element("span");
				t1 = text(t1_value);
				t2 = space();

				attr_dev(span, "class", span_class_value = "ml-2 text-base font-light overflow-hidden text-ellipsis whitespace-nowrap text-left inline-block w-[8rem] " + (/*$selectedEnv*/ ctx[10]?.id == /*env*/ ctx[34].id || /*hoveringEnvId*/ ctx[5] === /*env*/ ctx[34].id
				? 'text-osvauld-sideListTextActive'
				: 'text-osvauld-fieldText'));

				add_location(span, file$Y, 302, 7, 10164);
				attr_dev(button, "class", "w-full p-2 text-lg rounded-2xl flex items-center");
				add_location(button, file$Y, 293, 6, 9877);

				attr_dev(li, "class", li_class_value = "" + ((/*$selectedEnv*/ ctx[10]?.id == /*env*/ ctx[34].id
				? 'bg-osvauld-fieldActive rounded-lg text-osvauld-sideListTextActive'
				: 'hover:bg-osvauld-fieldActive text-osvauld-fieldText') + " rounded-md my-1 pl-3 pr-3 mr-1 flex items-center transition-colors duration-0 ease-in"));

				add_location(li, file$Y, 286, 5, 9479);
			},
			m: function mount(target, anchor) {
				insert_dev(target, li, anchor);
				append_dev(li, button);
				mount_component(existingenvironment, button, null);
				append_dev(button, t0);
				append_dev(button, span);
				append_dev(span, t1);
				append_dev(li, t2);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "click", click_handler_8, false, false, false, false),
						listen_dev(li, "mouseenter", mouseenter_handler_3, false, false, false, false),
						listen_dev(li, "mouseleave", /*mouseleave_handler_3*/ ctx[33], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const existingenvironment_changes = {};

				if (dirty[0] & /*$selectedEnv, $envStore, hoveringEnvId*/ 1568) existingenvironment_changes.color = /*$selectedEnv*/ ctx[10]?.id == /*env*/ ctx[34].id || /*hoveringEnvId*/ ctx[5] === /*env*/ ctx[34].id
				? '#F2F2F0'
				: '#85889C';

				existingenvironment.$set(existingenvironment_changes);
				if ((!current || dirty[0] & /*$envStore*/ 512) && t1_value !== (t1_value = /*env*/ ctx[34].name + "")) set_data_dev(t1, t1_value);

				if (!current || dirty[0] & /*$selectedEnv, $envStore, hoveringEnvId*/ 1568 && span_class_value !== (span_class_value = "ml-2 text-base font-light overflow-hidden text-ellipsis whitespace-nowrap text-left inline-block w-[8rem] " + (/*$selectedEnv*/ ctx[10]?.id == /*env*/ ctx[34].id || /*hoveringEnvId*/ ctx[5] === /*env*/ ctx[34].id
				? 'text-osvauld-sideListTextActive'
				: 'text-osvauld-fieldText'))) {
					attr_dev(span, "class", span_class_value);
				}

				if (!current || dirty[0] & /*$selectedEnv, $envStore*/ 1536 && li_class_value !== (li_class_value = "" + ((/*$selectedEnv*/ ctx[10]?.id == /*env*/ ctx[34].id
				? 'bg-osvauld-fieldActive rounded-lg text-osvauld-sideListTextActive'
				: 'hover:bg-osvauld-fieldActive text-osvauld-fieldText') + " rounded-md my-1 pl-3 pr-3 mr-1 flex items-center transition-colors duration-0 ease-in"))) {
					attr_dev(li, "class", li_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(existingenvironment.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(existingenvironment.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(li);
				}

				destroy_component(existingenvironment);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$m.name,
			type: "each",
			source: "(259:4) {#each $envStore as env}",
			ctx
		});

		return block;
	}

	function create_fragment$Z(ctx) {
		let div3;
		let button0;
		let span0;
		let t1;
		let add;
		let t2;
		let t3;
		let t4;
		let div0;
		let t5;
		let ul;
		let t6;
		let div1;
		let t7;
		let button1;
		let t8;
		let span2;
		let folderadd;
		let t9;
		let span1;
		let rightarrow0;
		let span1_class_value;
		let button1_class_value;
		let t10;
		let t11;
		let div2;
		let t12;
		let button2;
		let t13;
		let span4;
		let environmentadd;
		let t14;
		let span3;
		let rightarrow1;
		let span3_class_value;
		let button2_class_value;
		let t15;
		let current;
		let mounted;
		let dispose;

		add = new Add({
				props: { color: /*iconColor*/ ctx[3] },
				$$inline: true
			});

		let if_block0 = /*$showAddFolderDrawer*/ ctx[2] && create_if_block_6$7(ctx);
		let if_block1 = /*$showFolderRenameDrawer*/ ctx[6] && /*$selectedFolder*/ ctx[0] && create_if_block_5$9(ctx);
		let each_value_2 = ensure_array_like_dev(/*$folderStore*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value_2.length; i += 1) {
			each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		folderadd = new FolderAdd({
				props: {
					color: /*$selectedSection*/ ctx[8] === 'PrivateFolders'
					? '#F2F2F0'
					: '#85889C'
				},
				$$inline: true
			});

		rightarrow0 = new RightArrow({
				props: {
					color: /*$selectedSection*/ ctx[8] === 'PrivateFolders'
					? '#F2F2F0'
					: '#85889C'
				},
				$$inline: true
			});

		let if_block2 = /*$selectedSection*/ ctx[8] === "PrivateFolders" && create_if_block_1$w(ctx);

		environmentadd = new EnvironmentAdd({
				props: {
					color: /*$selectedSection*/ ctx[8] === 'Environments'
					? '#F2F2F0'
					: '#85889C'
				},
				$$inline: true
			});

		rightarrow1 = new RightArrow({
				props: {
					color: /*$selectedSection*/ ctx[8] === 'Environments'
					? '#F2F2F0'
					: '#85889C'
				},
				$$inline: true
			});

		let if_block3 = /*$selectedSection*/ ctx[8] === "Environments" && create_if_block$I(ctx);

		const block = {
			c: function create() {
				div3 = element("div");
				button0 = element("button");
				span0 = element("span");
				span0.textContent = "Create new folder";
				t1 = space();
				create_component(add.$$.fragment);
				t2 = space();
				if (if_block0) if_block0.c();
				t3 = space();
				if (if_block1) if_block1.c();
				t4 = space();
				div0 = element("div");
				t5 = space();
				ul = element("ul");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t6 = space();
				div1 = element("div");
				t7 = space();
				button1 = element("button");
				t8 = text("Private Folders ");
				span2 = element("span");
				create_component(folderadd.$$.fragment);
				t9 = space();
				span1 = element("span");
				create_component(rightarrow0.$$.fragment);
				t10 = space();
				if (if_block2) if_block2.c();
				t11 = space();
				div2 = element("div");
				t12 = space();
				button2 = element("button");
				t13 = text("Environments ");
				span4 = element("span");
				create_component(environmentadd.$$.fragment);
				t14 = space();
				span3 = element("span");
				create_component(rightarrow1.$$.fragment);
				t15 = space();
				if (if_block3) if_block3.c();
				attr_dev(span0, "class", "mr-1 text-base font-normal");
				add_location(span0, file$Y, 100, 2, 2724);
				attr_dev(button0, "class", "w-[90%] bg-osvauld-frameblack border border-osvauld-iconblack text-osvauld-sheffieldgrey hover:bg-osvauld-carolinablue hover:text-osvauld-ninjablack whitespace-nowrap rounded-lg py-1.5 px-2 mb-4 flex justify-center items-center");
				add_location(button0, file$Y, 95, 1, 2353);
				attr_dev(div0, "class", "border-b border-osvauld-iconblack my-1 w-[90%]");
				add_location(div0, file$Y, 124, 1, 3515);
				attr_dev(ul, "class", "overflow-y-scroll w-[90%] overflow-x-hidden scrollbar-thin min-h-[8rem] -pl-3");
				add_location(ul, file$Y, 125, 1, 3583);
				attr_dev(div1, "class", "border-b border-osvauld-iconblack my-1 w-[90%] mt-auto");
				add_location(div1, file$Y, 175, 1, 5507);

				attr_dev(span1, "class", span1_class_value = /*$selectedSection*/ ctx[8] === 'PrivateFolders'
				? 'rotate-90 transition-all'
				: 'rotate-0');

				add_location(span1, file$Y, 192, 3, 6084);
				attr_dev(span2, "class", "flex");
				add_location(span2, file$Y, 187, 19, 5958);

				attr_dev(button1, "class", button1_class_value = "w-[90%] py-2 flex justify-between items-center px-2 rounded-md " + (/*$selectedSection*/ ctx[8] === 'PrivateFolders'
				? 'bg-osvauld-sideListHighlight text-osvauld-sideListTextActive'
				: 'text-osvauld-fieldText'));

				add_location(button1, file$Y, 176, 1, 5583);
				attr_dev(div2, "class", "border-b border-osvauld-iconblack my-1 w-[90%] mt-0");
				add_location(div2, file$Y, 257, 1, 8412);

				attr_dev(span3, "class", span3_class_value = /*$selectedSection*/ ctx[8] === 'Environments'
				? 'rotate-90 transition-all'
				: 'rotate-0');

				add_location(span3, file$Y, 270, 3, 8971);
				attr_dev(span4, "class", "flex");
				add_location(span4, file$Y, 267, 16, 8852);

				attr_dev(button2, "class", button2_class_value = "w-[90%] py-2 flex justify-between items-center my-1.5 pl-2 px-2 rounded-md " + (/*$selectedSection*/ ctx[8] === 'Environments'
				? 'bg-osvauld-sideListHighlight text-osvauld-sideListTextActive'
				: 'text-osvauld-fieldText'));

				add_location(button2, file$Y, 258, 1, 8485);
				attr_dev(div3, "class", "h-full w-full flex flex-col justify-start items-center");
				add_location(div3, file$Y, 94, 0, 2283);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div3, anchor);
				append_dev(div3, button0);
				append_dev(button0, span0);
				append_dev(button0, t1);
				mount_component(add, button0, null);
				append_dev(div3, t2);
				if (if_block0) if_block0.m(div3, null);
				append_dev(div3, t3);
				if (if_block1) if_block1.m(div3, null);
				append_dev(div3, t4);
				append_dev(div3, div0);
				append_dev(div3, t5);
				append_dev(div3, ul);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(ul, null);
					}
				}

				append_dev(div3, t6);
				append_dev(div3, div1);
				append_dev(div3, t7);
				append_dev(div3, button1);
				append_dev(button1, t8);
				append_dev(button1, span2);
				mount_component(folderadd, span2, null);
				append_dev(span2, t9);
				append_dev(span2, span1);
				mount_component(rightarrow0, span1, null);
				append_dev(div3, t10);
				if (if_block2) if_block2.m(div3, null);
				append_dev(div3, t11);
				append_dev(div3, div2);
				append_dev(div3, t12);
				append_dev(div3, button2);
				append_dev(button2, t13);
				append_dev(button2, span4);
				mount_component(environmentadd, span4, null);
				append_dev(span4, t14);
				append_dev(span4, span3);
				mount_component(rightarrow1, span3, null);
				append_dev(div3, t15);
				if (if_block3) if_block3.m(div3, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "mouseenter", /*mouseenter_handler*/ ctx[19], false, false, false, false),
						listen_dev(button0, "mouseleave", /*mouseleave_handler*/ ctx[20], false, false, false, false),
						listen_dev(button0, "click", /*openModal*/ ctx[12], false, false, false, false),
						listen_dev(button1, "click", /*click_handler_4*/ ctx[25], false, false, false, false),
						listen_dev(button2, "click", /*click_handler_7*/ ctx[30], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const add_changes = {};
				if (dirty[0] & /*iconColor*/ 8) add_changes.color = /*iconColor*/ ctx[3];
				add.$set(add_changes);

				if (/*$showAddFolderDrawer*/ ctx[2]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*$showAddFolderDrawer*/ 4) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_6$7(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div3, t3);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*$showFolderRenameDrawer*/ ctx[6] && /*$selectedFolder*/ ctx[0]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*$showFolderRenameDrawer, $selectedFolder*/ 65) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_5$9(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div3, t4);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (dirty[0] & /*$selectedFolder, $folderStore, hoveringFolderId, selectFolder, openFolderMenu, $credentialStore*/ 18579) {
					each_value_2 = ensure_array_like_dev(/*$folderStore*/ ctx[1]);
					let i;

					for (i = 0; i < each_value_2.length; i += 1) {
						const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_2$1(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(ul, null);
						}
					}

					group_outros();

					for (i = each_value_2.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				const folderadd_changes = {};

				if (dirty[0] & /*$selectedSection*/ 256) folderadd_changes.color = /*$selectedSection*/ ctx[8] === 'PrivateFolders'
				? '#F2F2F0'
				: '#85889C';

				folderadd.$set(folderadd_changes);
				const rightarrow0_changes = {};

				if (dirty[0] & /*$selectedSection*/ 256) rightarrow0_changes.color = /*$selectedSection*/ ctx[8] === 'PrivateFolders'
				? '#F2F2F0'
				: '#85889C';

				rightarrow0.$set(rightarrow0_changes);

				if (!current || dirty[0] & /*$selectedSection*/ 256 && span1_class_value !== (span1_class_value = /*$selectedSection*/ ctx[8] === 'PrivateFolders'
				? 'rotate-90 transition-all'
				: 'rotate-0')) {
					attr_dev(span1, "class", span1_class_value);
				}

				if (!current || dirty[0] & /*$selectedSection*/ 256 && button1_class_value !== (button1_class_value = "w-[90%] py-2 flex justify-between items-center px-2 rounded-md " + (/*$selectedSection*/ ctx[8] === 'PrivateFolders'
				? 'bg-osvauld-sideListHighlight text-osvauld-sideListTextActive'
				: 'text-osvauld-fieldText'))) {
					attr_dev(button1, "class", button1_class_value);
				}

				if (/*$selectedSection*/ ctx[8] === "PrivateFolders") {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty[0] & /*$selectedSection*/ 256) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_1$w(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(div3, t11);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				const environmentadd_changes = {};

				if (dirty[0] & /*$selectedSection*/ 256) environmentadd_changes.color = /*$selectedSection*/ ctx[8] === 'Environments'
				? '#F2F2F0'
				: '#85889C';

				environmentadd.$set(environmentadd_changes);
				const rightarrow1_changes = {};

				if (dirty[0] & /*$selectedSection*/ 256) rightarrow1_changes.color = /*$selectedSection*/ ctx[8] === 'Environments'
				? '#F2F2F0'
				: '#85889C';

				rightarrow1.$set(rightarrow1_changes);

				if (!current || dirty[0] & /*$selectedSection*/ 256 && span3_class_value !== (span3_class_value = /*$selectedSection*/ ctx[8] === 'Environments'
				? 'rotate-90 transition-all'
				: 'rotate-0')) {
					attr_dev(span3, "class", span3_class_value);
				}

				if (!current || dirty[0] & /*$selectedSection*/ 256 && button2_class_value !== (button2_class_value = "w-[90%] py-2 flex justify-between items-center my-1.5 pl-2 px-2 rounded-md " + (/*$selectedSection*/ ctx[8] === 'Environments'
				? 'bg-osvauld-sideListHighlight text-osvauld-sideListTextActive'
				: 'text-osvauld-fieldText'))) {
					attr_dev(button2, "class", button2_class_value);
				}

				if (/*$selectedSection*/ ctx[8] === "Environments") {
					if (if_block3) {
						if_block3.p(ctx, dirty);

						if (dirty[0] & /*$selectedSection*/ 256) {
							transition_in(if_block3, 1);
						}
					} else {
						if_block3 = create_if_block$I(ctx);
						if_block3.c();
						transition_in(if_block3, 1);
						if_block3.m(div3, null);
					}
				} else if (if_block3) {
					group_outros();

					transition_out(if_block3, 1, 1, () => {
						if_block3 = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(add.$$.fragment, local);
				transition_in(if_block0);
				transition_in(if_block1);

				for (let i = 0; i < each_value_2.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(folderadd.$$.fragment, local);
				transition_in(rightarrow0.$$.fragment, local);
				transition_in(if_block2);
				transition_in(environmentadd.$$.fragment, local);
				transition_in(rightarrow1.$$.fragment, local);
				transition_in(if_block3);
				current = true;
			},
			o: function outro(local) {
				transition_out(add.$$.fragment, local);
				transition_out(if_block0);
				transition_out(if_block1);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(folderadd.$$.fragment, local);
				transition_out(rightarrow0.$$.fragment, local);
				transition_out(if_block2);
				transition_out(environmentadd.$$.fragment, local);
				transition_out(rightarrow1.$$.fragment, local);
				transition_out(if_block3);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div3);
				}

				destroy_component(add);
				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				destroy_each(each_blocks, detaching);
				destroy_component(folderadd);
				destroy_component(rightarrow0);
				if (if_block2) if_block2.d();
				destroy_component(environmentadd);
				destroy_component(rightarrow1);
				if (if_block3) if_block3.d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$Z.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$Z($$self, $$props, $$invalidate) {
		let $selectedFolder;
		let $folderStore;
		let $showAddFolderDrawer;
		let $showFolderRenameDrawer;
		let $credentialStore;
		let $selectedSection;
		let $envStore;
		let $selectedEnv;
		validate_store(selectedFolder, 'selectedFolder');
		component_subscribe($$self, selectedFolder, $$value => $$invalidate(0, $selectedFolder = $$value));
		validate_store(folderStore, 'folderStore');
		component_subscribe($$self, folderStore, $$value => $$invalidate(1, $folderStore = $$value));
		validate_store(showAddFolderDrawer, 'showAddFolderDrawer');
		component_subscribe($$self, showAddFolderDrawer, $$value => $$invalidate(2, $showAddFolderDrawer = $$value));
		validate_store(showFolderRenameDrawer, 'showFolderRenameDrawer');
		component_subscribe($$self, showFolderRenameDrawer, $$value => $$invalidate(6, $showFolderRenameDrawer = $$value));
		validate_store(credentialStore, 'credentialStore');
		component_subscribe($$self, credentialStore, $$value => $$invalidate(7, $credentialStore = $$value));
		validate_store(selectedSection, 'selectedSection');
		component_subscribe($$self, selectedSection, $$value => $$invalidate(8, $selectedSection = $$value));
		validate_store(envStore, 'envStore');
		component_subscribe($$self, envStore, $$value => $$invalidate(9, $envStore = $$value));
		validate_store(selectedEnv, 'selectedEnv');
		component_subscribe($$self, selectedEnv, $$value => $$invalidate(10, $selectedEnv = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('FolderSideList', slots, []);
		let iconColor = "#6E7681";
		let hoveringFolderId = null;
		let hoveringEnvId = null;

		const selectFolder = async (folder, section) => {
			try {
				selectedFolder.set(folder);
				selectedEnv.set(null);
				selectedSection.set(section);
				credentialStore.set([]);
			} catch(error) {
				console.error(error);
			}
		};

		const openModal = () => {
			console.log("openModal", get_store_value(showAddFolderDrawer));
			showAddFolderDrawer.set(true);
			console.log(get_store_value(showAddFolderDrawer));
		};

		const closeModal = () => {
			showAddFolderDrawer.set(false);
		};

		const openFolderMenu = (e, folderId, folderName, type) => {
			buttonRef.set(e.currentTarget);

			modalManager.set({
				id: folderId,
				name: folderName,
				type: "Folder",
				private: type === "private"
			});

			showMoreOptions.set(true);
		};

		const selectEnv = env => {
			selectedEnv.set(env);
			selectedFolder.set(null);
			selectedSection.set("Environments");
			credentialStore.set([]);
		};

		const selectSection = section => {
			selectedSection.set(section);
			selectedFolder.set(null);
			selectedEnv.set(null);
			credentialStore.set([]);
		};

		onMount(async () => {
			await setFolderStore();
			await setEnvStore();

			if (!$selectedFolder) {
				selectedSection.set("SharedFolders");
			}
		}); // selectSection("SharedFolders");

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<FolderSideList> was created with unknown prop '${key}'`);
		});

		function click_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		const mouseenter_handler = () => $$invalidate(3, iconColor = '#000');
		const mouseleave_handler = () => $$invalidate(3, iconColor = '#6E7681');

		const click_handler_2 = (folder, e) => {
			openFolderMenu(e, folder.id, folder.name, folder.type);
		};

		const click_handler_3 = folder => selectFolder(folder, 'SharedFolders');
		const mouseenter_handler_1 = folder => $$invalidate(4, hoveringFolderId = folder.id);
		const mouseleave_handler_1 = () => $$invalidate(4, hoveringFolderId = null);

		const click_handler_4 = () => selectSection($selectedSection === 'PrivateFolders'
		? 'SharedFolders'
		: 'PrivateFolders');

		const click_handler_5 = (folder, e) => {
			openFolderMenu(e, folder.id, folder.name, folder.type);
		};

		const click_handler_6 = folder => selectFolder(folder, 'PrivateFolders');
		const mouseenter_handler_2 = folder => $$invalidate(4, hoveringFolderId = folder.id);
		const mouseleave_handler_2 = () => $$invalidate(4, hoveringFolderId = null);

		const click_handler_7 = () => selectSection($selectedSection === 'Environments'
		? 'SharedFolders'
		: 'Environments');

		const click_handler_8 = env => {
			selectEnv(env);
		};

		const mouseenter_handler_3 = env => $$invalidate(5, hoveringEnvId = env.id);
		const mouseleave_handler_3 = () => $$invalidate(5, hoveringEnvId = null);

		$$self.$capture_state = () => ({
			slide,
			FolderEditor,
			showAddFolderDrawer,
			folderStore,
			selectedFolder,
			buttonRef,
			showMoreOptions,
			modalManager,
			credentialStore,
			envStore,
			selectedEnv,
			selectedSection,
			showFolderRenameDrawer,
			Menu,
			FolderIcon,
			Add,
			RightArrow,
			onMount,
			setFolderStore,
			setEnvStore,
			FolderAdd,
			EnvironmentAdd,
			ExistingEnvironment,
			get: get_store_value,
			iconColor,
			hoveringFolderId,
			hoveringEnvId,
			selectFolder,
			openModal,
			closeModal,
			openFolderMenu,
			selectEnv,
			selectSection,
			$selectedFolder,
			$folderStore,
			$showAddFolderDrawer,
			$showFolderRenameDrawer,
			$credentialStore,
			$selectedSection,
			$envStore,
			$selectedEnv
		});

		$$self.$inject_state = $$props => {
			if ('iconColor' in $$props) $$invalidate(3, iconColor = $$props.iconColor);
			if ('hoveringFolderId' in $$props) $$invalidate(4, hoveringFolderId = $$props.hoveringFolderId);
			if ('hoveringEnvId' in $$props) $$invalidate(5, hoveringEnvId = $$props.hoveringEnvId);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*$showAddFolderDrawer*/ 4) {
				console.log("showAddFolderDrawer changed:", $showAddFolderDrawer);
			}

			if ($$self.$$.dirty[0] & /*$selectedFolder*/ 1) {
				console.log("selectedFolder changed:", $selectedFolder);
			}

			if ($$self.$$.dirty[0] & /*$folderStore*/ 2) {
				console.log("folderStore changed:", $folderStore);
			}
		};

		return [
			$selectedFolder,
			$folderStore,
			$showAddFolderDrawer,
			iconColor,
			hoveringFolderId,
			hoveringEnvId,
			$showFolderRenameDrawer,
			$credentialStore,
			$selectedSection,
			$envStore,
			$selectedEnv,
			selectFolder,
			openModal,
			closeModal,
			openFolderMenu,
			selectEnv,
			selectSection,
			click_handler_1,
			click_handler,
			mouseenter_handler,
			mouseleave_handler,
			click_handler_2,
			click_handler_3,
			mouseenter_handler_1,
			mouseleave_handler_1,
			click_handler_4,
			click_handler_5,
			click_handler_6,
			mouseenter_handler_2,
			mouseleave_handler_2,
			click_handler_7,
			click_handler_8,
			mouseenter_handler_3,
			mouseleave_handler_3
		];
	}

	class FolderSideList extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {}, null, [-1, -1]);

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "FolderSideList",
				options,
				id: create_fragment$Z.name
			});
		}
	}

	/* src/lib/components/dashboard/groups/GroupEditor.svelte generated by Svelte v4.2.19 */

	const { Error: Error_1$9 } = globals;
	const file$X = "src/lib/components/dashboard/groups/GroupEditor.svelte";

	function create_fragment$Y(ctx) {
		let form;
		let div0;
		let span;
		let t0_value = (/*rename*/ ctx[1] ? "Rename Group" : "Create Group") + "";
		let t0;
		let t1;
		let button0;
		let closepanel;
		let t2;
		let div1;
		let t3;
		let label;
		let t5;
		let input;
		let t6;
		let div2;
		let t7;
		let div3;
		let button1;
		let t9;
		let button2;
		let t10_value = (/*rename*/ ctx[1] ? "Save Changes" : "Add Group") + "";
		let t10;
		let button2_disabled_value;
		let current;
		let mounted;
		let dispose;
		closepanel = new ClosePanel({ $$inline: true });

		const block = {
			c: function create() {
				form = element("form");
				div0 = element("div");
				span = element("span");
				t0 = text(t0_value);
				t1 = space();
				button0 = element("button");
				create_component(closepanel.$$.fragment);
				t2 = space();
				div1 = element("div");
				t3 = space();
				label = element("label");
				label.textContent = "Name:";
				t5 = space();
				input = element("input");
				t6 = space();
				div2 = element("div");
				t7 = space();
				div3 = element("div");
				button1 = element("button");
				button1.textContent = "Cancel";
				t9 = space();
				button2 = element("button");
				t10 = text(t10_value);
				attr_dev(span, "class", "text-[21px] font-medium text-osvauld-quarzowhite");
				add_location(span, file$X, 74, 2, 2045);
				attr_dev(button0, "class", "cursor-pointer p-2");
				attr_dev(button0, "type", "button");
				add_location(button0, file$X, 77, 2, 2167);
				attr_dev(div0, "class", "flex justify-between items-center w-full");
				add_location(div0, file$X, 73, 1, 1988);
				attr_dev(div1, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div1, file$X, 85, 1, 2308);
				attr_dev(label, "for", "name");
				attr_dev(label, "class", "font-bold text-base text-osvauld-textActive");
				add_location(label, file$X, 89, 1, 2403);
				attr_dev(input, "id", "name");
				attr_dev(input, "type", "text");
				input.required = true;
				attr_dev(input, "class", "py-1 rounded-md items-center text-base bg-osvauld-frameblack border-osvauld-iconblack w-[95%] h-10 mx-2 focus:border-osvauld-iconblack focus:ring-0 form-input");
				attr_dev(input, "autocomplete", "off");
				add_location(input, file$X, 92, 1, 2493);
				attr_dev(div2, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div2, file$X, 102, 1, 2771);
				attr_dev(button1, "class", "text-osvauld-fadedCancel font-medium text-base py-[5px] px-[15px] rounded-md hover:text-osvauld-quarzowhite hover:bg-osvauld-cancelBackground");
				attr_dev(button1, "type", "button");
				add_location(button1, file$X, 107, 2, 2925);
				attr_dev(button2, "class", "border border-osvauld-iconblack py-[5px] px-[15px] text-base font-medium text-osvauld-textActive rounded-md hover:bg-osvauld-carolinablue hover:border-osvauld-carolinablue hover:text-osvauld-frameblack");
				attr_dev(button2, "type", "submit");
				button2.disabled = button2_disabled_value = /*name*/ ctx[0] === '';
				add_location(button2, file$X, 112, 2, 3167);
				attr_dev(div3, "class", "flex justify-end items-center gap-4 w-full");
				add_location(div3, file$X, 106, 1, 2866);
				attr_dev(form, "class", "p-4 bg-osvauld-frameblack border border-osvauld-activeBorder rounded-3xl w-[32rem] h-[17rem] flex flex-col items-start justify-center gap-3");
				add_location(form, file$X, 69, 0, 1760);
			},
			l: function claim(nodes) {
				throw new Error_1$9("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, form, anchor);
				append_dev(form, div0);
				append_dev(div0, span);
				append_dev(span, t0);
				append_dev(div0, t1);
				append_dev(div0, button0);
				mount_component(closepanel, button0, null);
				append_dev(form, t2);
				append_dev(form, div1);
				append_dev(form, t3);
				append_dev(form, label);
				append_dev(form, t5);
				append_dev(form, input);
				set_input_value(input, /*name*/ ctx[0]);
				append_dev(form, t6);
				append_dev(form, div2);
				append_dev(form, t7);
				append_dev(form, div3);
				append_dev(div3, button1);
				append_dev(div3, t9);
				append_dev(div3, button2);
				append_dev(button2, t10);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", prevent_default(/*handleClose*/ ctx[4]), false, true, false, false),
						action_destroyer(autofocus$4.call(null, input)),
						listen_dev(input, "input", /*input_input_handler*/ ctx[5]),
						listen_dev(button1, "click", prevent_default(/*handleClose*/ ctx[4]), false, true, false, false),
						listen_dev(
							form,
							"submit",
							prevent_default(function () {
								if (is_function(/*rename*/ ctx[1]
								? /*renameGroupFunc*/ ctx[2]
								: /*addGroupFunc*/ ctx[3])) (/*rename*/ ctx[1]
								? /*renameGroupFunc*/ ctx[2]
								: /*addGroupFunc*/ ctx[3]).apply(this, arguments);
							}),
							false,
							true,
							false,
							false
						)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, [dirty]) {
				ctx = new_ctx;
				if ((!current || dirty & /*rename*/ 2) && t0_value !== (t0_value = (/*rename*/ ctx[1] ? "Rename Group" : "Create Group") + "")) set_data_dev(t0, t0_value);

				if (dirty & /*name*/ 1 && input.value !== /*name*/ ctx[0]) {
					set_input_value(input, /*name*/ ctx[0]);
				}

				if ((!current || dirty & /*rename*/ 2) && t10_value !== (t10_value = (/*rename*/ ctx[1] ? "Save Changes" : "Add Group") + "")) set_data_dev(t10, t10_value);

				if (!current || dirty & /*name*/ 1 && button2_disabled_value !== (button2_disabled_value = /*name*/ ctx[0] === '')) {
					prop_dev(button2, "disabled", button2_disabled_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closepanel.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(closepanel.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(form);
				}

				destroy_component(closepanel);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$Y.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function autofocus$4(node) {
		node.focus();
	}

	function instance$Y($$self, $$props, $$invalidate) {
		let $groupStore;
		let $selectedGroup;
		validate_store(groupStore, 'groupStore');
		component_subscribe($$self, groupStore, $$value => $$invalidate(6, $groupStore = $$value));
		validate_store(selectedGroup, 'selectedGroup');
		component_subscribe($$self, selectedGroup, $$value => $$invalidate(7, $selectedGroup = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('GroupEditor', slots, []);
		let { name = "" } = $$props;
		let { rename = false } = $$props;

		const renameGroupFunc = async () => {
			const payload = { name };

			if ($selectedGroup === null) {
				showRenameGroupDrawer.set(false);
				throw new Error("Group not selected");
			}

			const groupResponse = await renameGroup(payload, $selectedGroup.groupId);
			await setGroupStore();

			const actionMessage = groupResponse.success
			? "Group Successfully Renamed"
			: "Failed to Rename group";

			toastStore.set({
				type: groupResponse.success,
				message: actionMessage,
				show: true
			});

			showRenameGroupDrawer.set(false);
		};

		const addGroupFunc = async () => {
			const payload = { name };
			const groupResponse = await createGroup(payload);
			await setGroupStore();

			for (const group of $groupStore) {
				if (group.groupId === groupResponse.data.groupId) {
					selectedGroup.set(group);
					break;
				}
			}

			showAddGroupDrawer.set(false);

			const actionMessage = groupResponse.success
			? "Group Successfully Created"
			: "Failed to Create group";

			toastStore.set({
				type: groupResponse.success,
				message: actionMessage,
				show: true
			});
		};

		const handleClose = () => {
			showAddGroupDrawer.set(false);
			showRenameGroupDrawer.set(false);
		};

		const writable_props = ['name', 'rename'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GroupEditor> was created with unknown prop '${key}'`);
		});

		function input_input_handler() {
			name = this.value;
			$$invalidate(0, name);
		}

		$$self.$$set = $$props => {
			if ('name' in $$props) $$invalidate(0, name = $$props.name);
			if ('rename' in $$props) $$invalidate(1, rename = $$props.rename);
		};

		$$self.$capture_state = () => ({
			createGroup,
			renameGroup,
			selectedGroup,
			showAddGroupDrawer,
			showRenameGroupDrawer,
			ClosePanel,
			groupStore,
			toastStore,
			setGroupStore,
			name,
			rename,
			renameGroupFunc,
			addGroupFunc,
			autofocus: autofocus$4,
			handleClose,
			$groupStore,
			$selectedGroup
		});

		$$self.$inject_state = $$props => {
			if ('name' in $$props) $$invalidate(0, name = $$props.name);
			if ('rename' in $$props) $$invalidate(1, rename = $$props.rename);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [name, rename, renameGroupFunc, addGroupFunc, handleClose, input_input_handler];
	}

	class GroupEditor extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$Y, create_fragment$Y, safe_not_equal, { name: 0, rename: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "GroupEditor",
				options,
				id: create_fragment$Y.name
			});
		}

		get name() {
			throw new Error_1$9("<GroupEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set name(value) {
			throw new Error_1$9("<GroupEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get rename() {
			throw new Error_1$9("<GroupEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set rename(value) {
			throw new Error_1$9("<GroupEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/groups/GroupSideList.svelte generated by Svelte v4.2.19 */
	const file$W = "src/lib/components/dashboard/groups/GroupSideList.svelte";

	function get_each_context$l(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[27] = list[i];
		child_ctx[29] = i;
		return child_ctx;
	}

	// (60:1) {#if $showAddGroupDrawer}
	function create_if_block_3$f(ctx) {
		let button;
		let groupeditor;
		let current;
		let mounted;
		let dispose;
		groupeditor = new GroupEditor({ $$inline: true });
		groupeditor.$on("close", /*closeModal*/ ctx[10]);

		const block = {
			c: function create() {
				button = element("button");
				create_component(groupeditor.$$.fragment);
				attr_dev(button, "class", "fixed inset-0 flex items-center justify-center z-50 backdrop-filter backdrop-blur-[2px]");
				add_location(button, file$W, 80, 2, 2136);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				mount_component(groupeditor, button, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "click", stop_propagation(/*click_handler*/ ctx[15]), false, false, true, false),
						listen_dev(button, "keydown", stop_propagation(/*keydown_handler*/ ctx[16]), false, false, true, false)
					];

					mounted = true;
				}
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(groupeditor.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(groupeditor.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(groupeditor);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$f.name,
			type: "if",
			source: "(60:1) {#if $showAddGroupDrawer}",
			ctx
		});

		return block;
	}

	// (69:1) {#if $showRenameGroupDrawer && $selectedGroup}
	function create_if_block_2$l(ctx) {
		let button;
		let groupeditor;
		let current;
		let mounted;
		let dispose;

		groupeditor = new GroupEditor({
				props: {
					rename: true,
					name: /*$selectedGroup*/ ctx[5].name
				},
				$$inline: true
			});

		groupeditor.$on("close", /*closeModal*/ ctx[10]);

		const block = {
			c: function create() {
				button = element("button");
				create_component(groupeditor.$$.fragment);
				attr_dev(button, "class", "fixed inset-0 flex items-center justify-center z-50 backdrop-filter backdrop-blur-[2px]");
				add_location(button, file$W, 89, 2, 2417);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				mount_component(groupeditor, button, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "click", stop_propagation(/*click_handler_1*/ ctx[13]), false, false, true, false),
						listen_dev(button, "keydown", stop_propagation(/*keydown_handler_1*/ ctx[14]), false, false, true, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const groupeditor_changes = {};
				if (dirty & /*$selectedGroup*/ 32) groupeditor_changes.name = /*$selectedGroup*/ ctx[5].name;
				groupeditor.$set(groupeditor_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(groupeditor.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(groupeditor.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(groupeditor);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$l.name,
			type: "if",
			source: "(69:1) {#if $showRenameGroupDrawer && $selectedGroup}",
			ctx
		});

		return block;
	}

	// (85:2) {#if adminStatus}
	function create_if_block_1$v(ctx) {
		let li;
		let button;
		let groupicon;
		let t0;
		let span;
		let li_class_value;
		let current;
		let mounted;
		let dispose;

		groupicon = new GroupIcon({
				props: {
					color: /*$allUsersSelected*/ ctx[6] || /*hoveringIndex*/ ctx[1] === 999
					? 'white'
					: '#85889C'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				li = element("li");
				button = element("button");
				create_component(groupicon.$$.fragment);
				t0 = space();
				span = element("span");
				span.textContent = "All users";
				attr_dev(span, "class", "ml-2 text-base font-light");
				add_location(span, file$W, 121, 5, 3426);
				attr_dev(button, "class", "w-full p-2 text-lg rounded-2xl flex items-center cursor-pointer");
				add_location(button, file$W, 112, 4, 3167);

				attr_dev(li, "class", li_class_value = "" + ((/*$allUsersSelected*/ ctx[6] || /*hoveringIndex*/ ctx[1] === 999
				? 'bg-osvauld-fieldActive text-osvauld-sideListTextActive'
				: 'hover:bg-osvauld-fieldActive text-osvauld-fieldText') + " rounded-md pl-3 my-0.5 mr-1 pr-3 flex items-center"));

				add_location(li, file$W, 105, 3, 2820);
			},
			m: function mount(target, anchor) {
				insert_dev(target, li, anchor);
				append_dev(li, button);
				mount_component(groupicon, button, null);
				append_dev(button, t0);
				append_dev(button, span);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "click", /*click_handler_3*/ ctx[20], false, false, false, false),
						listen_dev(li, "mouseenter", /*mouseenter_handler_1*/ ctx[21], false, false, false, false),
						listen_dev(li, "mouseleave", /*mouseleave_handler_1*/ ctx[22], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const groupicon_changes = {};

				if (dirty & /*$allUsersSelected, hoveringIndex*/ 66) groupicon_changes.color = /*$allUsersSelected*/ ctx[6] || /*hoveringIndex*/ ctx[1] === 999
				? 'white'
				: '#85889C';

				groupicon.$set(groupicon_changes);

				if (!current || dirty & /*$allUsersSelected, hoveringIndex*/ 66 && li_class_value !== (li_class_value = "" + ((/*$allUsersSelected*/ ctx[6] || /*hoveringIndex*/ ctx[1] === 999
				? 'bg-osvauld-fieldActive text-osvauld-sideListTextActive'
				: 'hover:bg-osvauld-fieldActive text-osvauld-fieldText') + " rounded-md pl-3 my-0.5 mr-1 pr-3 flex items-center"))) {
					attr_dev(li, "class", li_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(groupicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(groupicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(li);
				}

				destroy_component(groupicon);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$v.name,
			type: "if",
			source: "(85:2) {#if adminStatus}",
			ctx
		});

		return block;
	}

	// (138:5) {#if group.accessType === "admin"}
	function create_if_block$H(ctx) {
		let button;
		let menu;
		let current;
		let mounted;
		let dispose;
		menu = new Menu({ $$inline: true });

		function click_handler_5(...args) {
			return /*click_handler_5*/ ctx[24](/*group*/ ctx[27], ...args);
		}

		const block = {
			c: function create() {
				button = element("button");
				create_component(menu.$$.fragment);
				attr_dev(button, "class", "p-2");
				add_location(button, file$W, 158, 6, 4731);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				mount_component(menu, button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", prevent_default(click_handler_5), false, true, false, false);
					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(menu.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(menu.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(menu);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$H.name,
			type: "if",
			source: "(138:5) {#if group.accessType === \\\"admin\\\"}",
			ctx
		});

		return block;
	}

	// (106:2) {#each $groupStore as group, index}
	function create_each_block$l(ctx) {
		let li;
		let button;
		let groupicon;
		let t0;
		let span;
		let t1_value = /*group*/ ctx[27].name + "";
		let t1;
		let t2;
		let div;
		let div_class_value;
		let t3;
		let li_class_value;
		let current;
		let mounted;
		let dispose;

		groupicon = new GroupIcon({
				props: {
					color: /*$selectedGroup*/ ctx[5] && /*$selectedGroup*/ ctx[5].groupId === /*group*/ ctx[27].groupId || /*hoveringIndex*/ ctx[1] === /*index*/ ctx[29]
					? 'white'
					: '#85889C'
				},
				$$inline: true
			});

		function click_handler_4() {
			return /*click_handler_4*/ ctx[23](/*group*/ ctx[27]);
		}

		let if_block = /*group*/ ctx[27].accessType === "admin" && create_if_block$H(ctx);

		function mouseenter_handler_2() {
			return /*mouseenter_handler_2*/ ctx[25](/*index*/ ctx[29]);
		}

		const block = {
			c: function create() {
				li = element("li");
				button = element("button");
				create_component(groupicon.$$.fragment);
				t0 = space();
				span = element("span");
				t1 = text(t1_value);
				t2 = space();
				div = element("div");
				if (if_block) if_block.c();
				t3 = space();
				attr_dev(span, "class", "ml-2 text-base font-light overflow-hidden text-ellipsis whitespace-nowrap text-left inline-block w-[8rem]");
				add_location(span, file$W, 145, 5, 4300);
				attr_dev(button, "class", "w-full p-2 text-lg rounded-2xl flex items-center cursor-pointer");
				add_location(button, file$W, 134, 4, 3984);

				attr_dev(div, "class", div_class_value = "relative z-100 flex justify-center items-center " + (/*$selectedGroup*/ ctx[5] && /*$selectedGroup*/ ctx[5].groupId === /*group*/ ctx[27].groupId || /*hoveringIndex*/ ctx[1] === /*index*/ ctx[29]
				? 'visible'
				: 'hidden'));

				add_location(div, file$W, 150, 4, 4477);

				attr_dev(li, "class", li_class_value = "" + ((/*$selectedGroup*/ ctx[5] && /*$selectedGroup*/ ctx[5].groupId === /*group*/ ctx[27].groupId || /*hoveringIndex*/ ctx[1] === /*index*/ ctx[29]
				? 'bg-osvauld-fieldActive text-osvauld-sideListTextActive'
				: 'hover:bg-osvauld-fieldActive text-osvauld-fieldText') + " rounded-md pl-3 my-0.5 pr-3 mr-1 flex items-center transition-colors duration-100"));

				add_location(li, file$W, 126, 3, 3555);
			},
			m: function mount(target, anchor) {
				insert_dev(target, li, anchor);
				append_dev(li, button);
				mount_component(groupicon, button, null);
				append_dev(button, t0);
				append_dev(button, span);
				append_dev(span, t1);
				append_dev(li, t2);
				append_dev(li, div);
				if (if_block) if_block.m(div, null);
				append_dev(li, t3);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "click", click_handler_4, false, false, false, false),
						listen_dev(li, "mouseenter", mouseenter_handler_2, false, false, false, false),
						listen_dev(li, "mouseleave", /*mouseleave_handler_2*/ ctx[26], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const groupicon_changes = {};

				if (dirty & /*$selectedGroup, $groupStore, hoveringIndex*/ 162) groupicon_changes.color = /*$selectedGroup*/ ctx[5] && /*$selectedGroup*/ ctx[5].groupId === /*group*/ ctx[27].groupId || /*hoveringIndex*/ ctx[1] === /*index*/ ctx[29]
				? 'white'
				: '#85889C';

				groupicon.$set(groupicon_changes);
				if ((!current || dirty & /*$groupStore*/ 128) && t1_value !== (t1_value = /*group*/ ctx[27].name + "")) set_data_dev(t1, t1_value);

				if (/*group*/ ctx[27].accessType === "admin") {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*$groupStore*/ 128) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$H(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(div, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}

				if (!current || dirty & /*$selectedGroup, $groupStore, hoveringIndex*/ 162 && div_class_value !== (div_class_value = "relative z-100 flex justify-center items-center " + (/*$selectedGroup*/ ctx[5] && /*$selectedGroup*/ ctx[5].groupId === /*group*/ ctx[27].groupId || /*hoveringIndex*/ ctx[1] === /*index*/ ctx[29]
				? 'visible'
				: 'hidden'))) {
					attr_dev(div, "class", div_class_value);
				}

				if (!current || dirty & /*$selectedGroup, $groupStore, hoveringIndex*/ 162 && li_class_value !== (li_class_value = "" + ((/*$selectedGroup*/ ctx[5] && /*$selectedGroup*/ ctx[5].groupId === /*group*/ ctx[27].groupId || /*hoveringIndex*/ ctx[1] === /*index*/ ctx[29]
				? 'bg-osvauld-fieldActive text-osvauld-sideListTextActive'
				: 'hover:bg-osvauld-fieldActive text-osvauld-fieldText') + " rounded-md pl-3 my-0.5 pr-3 mr-1 flex items-center transition-colors duration-100"))) {
					attr_dev(li, "class", li_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(groupicon.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(groupicon.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(li);
				}

				destroy_component(groupicon);
				if (if_block) if_block.d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$l.name,
			type: "each",
			source: "(106:2) {#each $groupStore as group, index}",
			ctx
		});

		return block;
	}

	function create_fragment$X(ctx) {
		let div;
		let button;
		let span;
		let t1;
		let add;
		let t2;
		let t3;
		let t4;
		let ul;
		let t5;
		let current;
		let mounted;
		let dispose;

		add = new Add({
				props: { color: /*iconColor*/ ctx[2] },
				$$inline: true
			});

		let if_block0 = /*$showAddGroupDrawer*/ ctx[3] && create_if_block_3$f(ctx);
		let if_block1 = /*$showRenameGroupDrawer*/ ctx[4] && /*$selectedGroup*/ ctx[5] && create_if_block_2$l(ctx);
		let if_block2 = /*adminStatus*/ ctx[0] && create_if_block_1$v(ctx);
		let each_value = ensure_array_like_dev(/*$groupStore*/ ctx[7]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$l(get_each_context$l(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div = element("div");
				button = element("button");
				span = element("span");
				span.textContent = "Create new group";
				t1 = space();
				create_component(add.$$.fragment);
				t2 = space();
				if (if_block0) if_block0.c();
				t3 = space();
				if (if_block1) if_block1.c();
				t4 = space();
				ul = element("ul");
				if (if_block2) if_block2.c();
				t5 = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(span, "class", "mr-1 text-base font-normal");
				add_location(span, file$W, 76, 2, 2001);
				attr_dev(button, "class", "w-[90%] bg-osvauld-frameblack border border-osvauld-iconblack text-osvauld-sheffieldgrey hover:bg-osvauld-carolinablue hover:text-osvauld-ninjablack whitespace-nowrap rounded-lg py-1.5 px-2 mb-4 flex justify-center items-center font-normal");
				add_location(button, file$W, 70, 1, 1601);
				attr_dev(ul, "class", "h-full w-full overflow-y-scroll overflow-x-hidden scrollbar-thin -pl-3");
				add_location(ul, file$W, 101, 1, 2709);
				attr_dev(div, "class", "h-full flex w-full flex-col justify-start items-center");
				add_location(div, file$W, 69, 0, 1531);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, button);
				append_dev(button, span);
				append_dev(button, t1);
				mount_component(add, button, null);
				append_dev(div, t2);
				if (if_block0) if_block0.m(div, null);
				append_dev(div, t3);
				if (if_block1) if_block1.m(div, null);
				append_dev(div, t4);
				append_dev(div, ul);
				if (if_block2) if_block2.m(ul, null);
				append_dev(ul, t5);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(ul, null);
					}
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "mouseenter", /*mouseenter_handler*/ ctx[17], false, false, false, false),
						listen_dev(button, "mouseleave", /*mouseleave_handler*/ ctx[18], false, false, false, false),
						listen_dev(button, "click", /*click_handler_2*/ ctx[19], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				const add_changes = {};
				if (dirty & /*iconColor*/ 4) add_changes.color = /*iconColor*/ ctx[2];
				add.$set(add_changes);

				if (/*$showAddGroupDrawer*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*$showAddGroupDrawer*/ 8) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_3$f(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div, t3);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*$showRenameGroupDrawer*/ ctx[4] && /*$selectedGroup*/ ctx[5]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*$showRenameGroupDrawer, $selectedGroup*/ 48) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_2$l(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div, t4);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*adminStatus*/ ctx[0]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*adminStatus*/ 1) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_1$v(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(ul, t5);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (dirty & /*$selectedGroup, $groupStore, hoveringIndex, showMoreOptionsHandler, selectGroup*/ 4514) {
					each_value = ensure_array_like_dev(/*$groupStore*/ ctx[7]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$l(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$l(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(ul, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(add.$$.fragment, local);
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(add.$$.fragment, local);
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(add);
				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				destroy_each(each_blocks, detaching);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$X.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$X($$self, $$props, $$invalidate) {
		let $showAddGroupDrawer;
		let $showRenameGroupDrawer;
		let $selectedGroup;
		let $allUsersSelected;
		let $groupStore;
		validate_store(showAddGroupDrawer, 'showAddGroupDrawer');
		component_subscribe($$self, showAddGroupDrawer, $$value => $$invalidate(3, $showAddGroupDrawer = $$value));
		validate_store(showRenameGroupDrawer, 'showRenameGroupDrawer');
		component_subscribe($$self, showRenameGroupDrawer, $$value => $$invalidate(4, $showRenameGroupDrawer = $$value));
		validate_store(selectedGroup, 'selectedGroup');
		component_subscribe($$self, selectedGroup, $$value => $$invalidate(5, $selectedGroup = $$value));
		validate_store(allUsersSelected, 'allUsersSelected');
		component_subscribe($$self, allUsersSelected, $$value => $$invalidate(6, $allUsersSelected = $$value));
		validate_store(groupStore, 'groupStore');
		component_subscribe($$self, groupStore, $$value => $$invalidate(7, $groupStore = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('GroupSideList', slots, []);
		let adminStatus = false;
		let hoveringIndex = null;
		let iconColor = "#6E7681"; //sheffieldgrey:

		const selectGroup = group => {
			allUsersSelected.set(false);
			selectedGroup.set(group);
		};

		const openModal = type => {
			if (type === "group") {
				showAddGroupDrawer.set(true);
			} else if (type === "user") {
				showAddUserDrawer.set(true);
			}
		};

		const closeModal = () => {
			showAddGroupDrawer.set(false);
		};

		const selectingAllUsers = () => {
			selectedGroup.set(null);
			allUsersSelected.set(true);
		};

		const showMoreOptionsHandler = (e, group) => {
			selectedGroup.set(group);
			buttonRef.set(e.target);

			modalManager.set({
				id: group.groupId,
				name: group.name,
				type: "Group",
				private: false
			});

			showMoreGroupOptions.set(true);
		};

		onMount(async () => {
			await setGroupStore();
			const userDetails = await getUserDetails();

			if (userDetails.type === "admin" || userDetails.type === "superadmin") {
				$$invalidate(0, adminStatus = true);
			}
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GroupSideList> was created with unknown prop '${key}'`);
		});

		function click_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		function keydown_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function keydown_handler(event) {
			bubble.call(this, $$self, event);
		}

		const mouseenter_handler = () => $$invalidate(2, iconColor = '#000');
		const mouseleave_handler = () => $$invalidate(2, iconColor = '#6E7681');
		const click_handler_2 = () => openModal('group');
		const click_handler_3 = () => selectingAllUsers();
		const mouseenter_handler_1 = () => $$invalidate(1, hoveringIndex = 999);
		const mouseleave_handler_1 = () => $$invalidate(1, hoveringIndex = null);
		const click_handler_4 = group => selectGroup(group);

		const click_handler_5 = (group, e) => {
			showMoreOptionsHandler(e, group);
		};

		const mouseenter_handler_2 = index => $$invalidate(1, hoveringIndex = index);
		const mouseleave_handler_2 = () => $$invalidate(1, hoveringIndex = null);

		$$self.$capture_state = () => ({
			GroupEditor,
			groupStore,
			selectedGroup,
			showAddGroupDrawer,
			showAddUserDrawer,
			allUsersSelected,
			showMoreGroupOptions,
			buttonRef,
			modalManager,
			showRenameGroupDrawer,
			Add,
			GroupIcon,
			Menu,
			onMount,
			setGroupStore,
			getUserDetails,
			adminStatus,
			hoveringIndex,
			iconColor,
			selectGroup,
			openModal,
			closeModal,
			selectingAllUsers,
			showMoreOptionsHandler,
			$showAddGroupDrawer,
			$showRenameGroupDrawer,
			$selectedGroup,
			$allUsersSelected,
			$groupStore
		});

		$$self.$inject_state = $$props => {
			if ('adminStatus' in $$props) $$invalidate(0, adminStatus = $$props.adminStatus);
			if ('hoveringIndex' in $$props) $$invalidate(1, hoveringIndex = $$props.hoveringIndex);
			if ('iconColor' in $$props) $$invalidate(2, iconColor = $$props.iconColor);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			adminStatus,
			hoveringIndex,
			iconColor,
			$showAddGroupDrawer,
			$showRenameGroupDrawer,
			$selectedGroup,
			$allUsersSelected,
			$groupStore,
			selectGroup,
			openModal,
			closeModal,
			selectingAllUsers,
			showMoreOptionsHandler,
			click_handler_1,
			keydown_handler_1,
			click_handler,
			keydown_handler,
			mouseenter_handler,
			mouseleave_handler,
			click_handler_2,
			click_handler_3,
			mouseenter_handler_1,
			mouseleave_handler_1,
			click_handler_4,
			click_handler_5,
			mouseenter_handler_2,
			mouseleave_handler_2
		];
	}

	class GroupSideList extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$X, create_fragment$X, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "GroupSideList",
				options,
				id: create_fragment$X.name
			});
		}
	}

	/* src/lib/components/dashboard/SideList.svelte generated by Svelte v4.2.19 */

	const { console: console_1$2 } = globals;

	// (9:37) 
	function create_if_block_1$u(ctx) {
		let groupsidelist;
		let current;
		groupsidelist = new GroupSideList({ $$inline: true });

		const block = {
			c: function create() {
				create_component(groupsidelist.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(groupsidelist, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(groupsidelist.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(groupsidelist.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(groupsidelist, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$u.name,
			type: "if",
			source: "(9:37) ",
			ctx
		});

		return block;
	}

	// (7:0) {#if $selectedPage === "Folders"}
	function create_if_block$G(ctx) {
		let foldersidelist;
		let current;
		foldersidelist = new FolderSideList({ $$inline: true });

		const block = {
			c: function create() {
				create_component(foldersidelist.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(foldersidelist, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(foldersidelist.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(foldersidelist.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(foldersidelist, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$G.name,
			type: "if",
			source: "(7:0) {#if $selectedPage === \\\"Folders\\\"}",
			ctx
		});

		return block;
	}

	function create_fragment$W(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block$G, create_if_block_1$u];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*$selectedPage*/ ctx[0] === "Folders") return 0;
			if (/*$selectedPage*/ ctx[0] === "Groups") return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(target, anchor);
				}

				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index !== previous_block_index) {
					if (if_block) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];

						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block.c();
						}

						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					} else {
						if_block = null;
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d(detaching);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$W.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$W($$self, $$props, $$invalidate) {
		let $selectedPage;
		validate_store(selectedPage, 'selectedPage');
		component_subscribe($$self, selectedPage, $$value => $$invalidate(0, $selectedPage = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('SideList', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<SideList> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({
			selectedPage,
			FolderSideList,
			GroupSideList,
			$selectedPage
		});

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$selectedPage*/ 1) {
				console.log($selectedPage, "changed");
			}
		};

		return [$selectedPage];
	}

	class SideList extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$W, create_fragment$W, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "SideList",
				options,
				id: create_fragment$W.name
			});
		}
	}

	/* src/lib/components/dashboard/LeftContainer.svelte generated by Svelte v4.2.19 */
	const file$V = "src/lib/components/dashboard/LeftContainer.svelte";

	function create_fragment$V(ctx) {
		let div0;
		let logo;
		let t0;
		let div1;
		let toggle;
		let t1;
		let div2;
		let sidelist;
		let current;
		logo = new Logo({ $$inline: true });
		toggle = new Toggle$1({ $$inline: true });
		sidelist = new SideList({ $$inline: true });

		const block = {
			c: function create() {
				div0 = element("div");
				create_component(logo.$$.fragment);
				t0 = space();
				div1 = element("div");
				create_component(toggle.$$.fragment);
				t1 = space();
				div2 = element("div");
				create_component(sidelist.$$.fragment);
				attr_dev(div0, "class", "flex justify-center items-center h-[6rem] scale-[0.8]");
				add_location(div0, file$V, 5, 0, 111);
				attr_dev(div1, "class", "flex justify-center items-center w-full");
				add_location(div1, file$V, 9, 0, 197);
				attr_dev(div2, "class", "scroll-m-0 h-[82%] w-full scroll-smooth justify-center flex items-center mt-6");
				add_location(div2, file$V, 12, 0, 270);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div0, anchor);
				mount_component(logo, div0, null);
				insert_dev(target, t0, anchor);
				insert_dev(target, div1, anchor);
				mount_component(toggle, div1, null);
				insert_dev(target, t1, anchor);
				insert_dev(target, div2, anchor);
				mount_component(sidelist, div2, null);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(logo.$$.fragment, local);
				transition_in(toggle.$$.fragment, local);
				transition_in(sidelist.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(logo.$$.fragment, local);
				transition_out(toggle.$$.fragment, local);
				transition_out(sidelist.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div0);
					detach_dev(t0);
					detach_dev(div1);
					detach_dev(t1);
					detach_dev(div2);
				}

				destroy_component(logo);
				destroy_component(toggle);
				destroy_component(sidelist);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$V.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$V($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('LeftContainer', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LeftContainer> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({ Logo, Toggle: Toggle$1, SideList });
		return [];
	}

	class LeftContainer extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$V, create_fragment$V, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "LeftContainer",
				options,
				id: create_fragment$V.name
			});
		}
	}

	/* src/lib/components/dashboard/components/Loader.svelte generated by Svelte v4.2.19 */
	const file$U = "src/lib/components/dashboard/components/Loader.svelte";

	function create_fragment$U(ctx) {
		let div1;
		let div0;

		const block = {
			c: function create() {
				div1 = element("div");
				div0 = element("div");
				attr_dev(div0, "class", "spinner svelte-15gwnn8");
				add_location(div0, file$U, 38, 1, 629);
				attr_dev(div1, "class", "loader svelte-15gwnn8");
				set_style(div1, "--color", /*color*/ ctx[1]);
				set_style(div1, "--duration", /*duration*/ ctx[2] + "s");
				set_style(div1, "width", /*size*/ ctx[0] + "px");
				set_style(div1, "height", /*size*/ ctx[0] + "px");
				add_location(div1, file$U, 34, 0, 518);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, div0);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*color*/ 2) {
					set_style(div1, "--color", /*color*/ ctx[1]);
				}

				if (dirty & /*duration*/ 4) {
					set_style(div1, "--duration", /*duration*/ ctx[2] + "s");
				}

				if (dirty & /*size*/ 1) {
					set_style(div1, "width", /*size*/ ctx[0] + "px");
				}

				if (dirty & /*size*/ 1) {
					set_style(div1, "height", /*size*/ ctx[0] + "px");
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$U.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$U($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Loader', slots, []);
		let { size = 24 } = $$props;
		let { color = "#000" } = $$props;
		let { duration = 1 } = $$props;
		const writable_props = ['size', 'color', 'duration'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Loader> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('size' in $$props) $$invalidate(0, size = $$props.size);
			if ('color' in $$props) $$invalidate(1, color = $$props.color);
			if ('duration' in $$props) $$invalidate(2, duration = $$props.duration);
		};

		$$self.$capture_state = () => ({ size, color, duration });

		$$self.$inject_state = $$props => {
			if ('size' in $$props) $$invalidate(0, size = $$props.size);
			if ('color' in $$props) $$invalidate(1, color = $$props.color);
			if ('duration' in $$props) $$invalidate(2, duration = $$props.duration);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [size, color, duration];
	}

	class Loader extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$U, create_fragment$U, safe_not_equal, { size: 0, color: 1, duration: 2 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Loader",
				options,
				id: create_fragment$U.name
			});
		}

		get size() {
			throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set size(value) {
			throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get color() {
			throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set color(value) {
			throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get duration() {
			throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set duration(value) {
			throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/credentials/AddLoginFields.svelte generated by Svelte v4.2.19 */
	const file$T = "src/lib/components/dashboard/credentials/AddLoginFields.svelte";

	// (85:3) {#if index === hoveredIndex}
	function create_if_block$F(ctx) {
		let span;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = "Sensitive";
				attr_dev(span, "class", "absolute top-[-3.75rem] left-[-1.5625rem] bg-osvauld-iconblack rounded-lg p-3 text-sm text-osvauld-dusklabel triangle svelte-15xqw5a");
				add_location(span, file$T, 92, 4, 2704);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$F.name,
			type: "if",
			source: "(85:3) {#if index === hoveredIndex}",
			ctx
		});

		return block;
	}

	function create_fragment$T(ctx) {
		let div3;
		let div2;
		let input0;
		let input0_id_value;
		let input0_required_value;
		let t0;
		let input1;
		let input1_id_value;
		let input1_required_value;
		let t1;
		let div0;
		let label;
		let span2;
		let span0;
		let span0_class_value;
		let t2;
		let span1;
		let input2;
		let input2_id_value;
		let span1_class_value;
		let label_for_value;
		let t3;
		let div0_class_value;
		let t4;
		let div1;
		let button;
		let binicon;
		let current;
		let mounted;
		let dispose;
		let if_block = /*index*/ ctx[1] === /*hoveredIndex*/ ctx[2] && create_if_block$F(ctx);
		binicon = new BinIcon({ $$inline: true });

		const block = {
			c: function create() {
				div3 = element("div");
				div2 = element("div");
				input0 = element("input");
				t0 = space();
				input1 = element("input");
				t1 = space();
				div0 = element("div");
				label = element("label");
				span2 = element("span");
				span0 = element("span");
				t2 = space();
				span1 = element("span");
				input2 = element("input");
				t3 = space();
				if (if_block) if_block.c();
				t4 = space();
				div1 = element("div");
				button = element("button");
				create_component(binicon.$$.fragment);
				attr_dev(input0, "class", "py-1 pr-10 rounded-lg items-center text-base bg-osvauld-frameblack border-osvauld-iconblack w-[16rem] h-10 mx-2 focus:border-osvauld-iconblack focus:ring-0");
				attr_dev(input0, "id", input0_id_value = `key-${/*index*/ ctx[1]}`);
				attr_dev(input0, "type", "text");
				attr_dev(input0, "placeholder", "Enter field name");
				input0.required = input0_required_value = /*field*/ ctx[0].fieldName !== 'TOTP';
				add_location(input0, file$T, 36, 2, 814);
				attr_dev(input1, "class", "py-1 pr-10 rounded-lg items-center text-base bg-osvauld-frameblack border-osvauld-iconblack w-[16rem] h-10 mx-2 focus:border-osvauld-iconblack focus:ring-0");
				attr_dev(input1, "id", input1_id_value = `value-${/*index*/ ctx[1]}`);
				attr_dev(input1, "type", "text");
				attr_dev(input1, "placeholder", "Enter value");
				attr_dev(input1, "autocomplete", "off");
				input1.required = input1_required_value = /*field*/ ctx[0].fieldName !== 'TOTP';
				add_location(input1, file$T, 46, 2, 1189);

				attr_dev(span0, "class", span0_class_value = "block w-10 h-6 " + (/*field*/ ctx[0].sensitive
				? 'bg-osvauld-carolinablue'
				: 'bg-osvauld-placeholderblack') + " rounded-full shadow-inner");

				add_location(span0, file$T, 71, 5, 1972);
				attr_dev(input2, "type", "checkbox");
				attr_dev(input2, "id", input2_id_value = `toggle-${/*index*/ ctx[1]}`);
				attr_dev(input2, "class", "absolute opacity-0 w-0 h-0");
				add_location(input2, file$T, 81, 6, 2432);

				attr_dev(span1, "class", span1_class_value = "absolute block w-4 h-4 mt-1 ml-1 rounded-full shadow inset-y-0 left-0 focus-within:shadow-outline transform transition-transform duration-300 ease-in-out " + (/*field*/ ctx[0].sensitive
				? 'bg-osvauld-plainwhite translate-x-full'
				: 'bg-osvauld-chalkwhite'));

				add_location(span1, file$T, 76, 5, 2144);
				attr_dev(span2, "class", "relative");
				add_location(span2, file$T, 70, 4, 1943);
				attr_dev(label, "for", label_for_value = `toggle-${/*index*/ ctx[1]}`);
				attr_dev(label, "class", "inline-flex items-center cursor-pointer");
				add_location(label, file$T, 66, 3, 1845);
				attr_dev(div0, "role", "button");
				attr_dev(div0, "tabindex", "0");

				attr_dev(div0, "class", div0_class_value = "flex items-center justify-center " + (/*index*/ ctx[1] === /*hoveredIndex*/ ctx[2]
				? 'relative'
				: ''));

				add_location(div0, file$T, 57, 2, 1584);
				attr_dev(button, "class", "rounded-md pr-2 pl-2 bg-osvauld-frameblack text-osvauld-quarzowhite flex justify-center items-center ml-5");
				attr_dev(button, "type", "button");
				add_location(button, file$T, 99, 3, 2940);
				attr_dev(div1, "class", "flex items-center justify-center");
				add_location(div1, file$T, 98, 2, 2890);
				attr_dev(div2, "class", "flex items-center justify-between px-4 py-1.5");
				add_location(div2, file$T, 35, 1, 752);
				attr_dev(div3, "class", "field-container rounded-sm transition relative");
				add_location(div3, file$T, 34, 0, 690);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div3, anchor);
				append_dev(div3, div2);
				append_dev(div2, input0);
				set_input_value(input0, /*field*/ ctx[0].fieldName);
				append_dev(div2, t0);
				append_dev(div2, input1);
				set_input_value(input1, /*field*/ ctx[0].fieldValue);
				append_dev(div2, t1);
				append_dev(div2, div0);
				append_dev(div0, label);
				append_dev(label, span2);
				append_dev(span2, span0);
				append_dev(span2, t2);
				append_dev(span2, span1);
				append_dev(span1, input2);
				input2.checked = /*field*/ ctx[0].sensitive;
				append_dev(div0, t3);
				if (if_block) if_block.m(div0, null);
				append_dev(div2, t4);
				append_dev(div2, div1);
				append_dev(div1, button);
				mount_component(binicon, button, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(input0, "input", /*input0_input_handler*/ ctx[6]),
						listen_dev(input0, "change", /*change_handler*/ ctx[7], false, false, false, false),
						listen_dev(input1, "input", /*input1_input_handler*/ ctx[8]),
						listen_dev(input1, "change", /*change_handler_1*/ ctx[9], false, false, false, false),
						listen_dev(input2, "change", /*input2_change_handler*/ ctx[10]),
						listen_dev(input2, "change", /*change_handler_2*/ ctx[11], false, false, false, false),
						listen_dev(div0, "mouseenter", /*mouseenter_handler*/ ctx[12], false, false, false, false),
						listen_dev(div0, "mouseleave", /*mouseleave_handler*/ ctx[13], false, false, false, false),
						listen_dev(button, "click", /*click_handler*/ ctx[14], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (!current || dirty & /*index*/ 2 && input0_id_value !== (input0_id_value = `key-${/*index*/ ctx[1]}`)) {
					attr_dev(input0, "id", input0_id_value);
				}

				if (!current || dirty & /*field*/ 1 && input0_required_value !== (input0_required_value = /*field*/ ctx[0].fieldName !== 'TOTP')) {
					prop_dev(input0, "required", input0_required_value);
				}

				if (dirty & /*field*/ 1 && input0.value !== /*field*/ ctx[0].fieldName) {
					set_input_value(input0, /*field*/ ctx[0].fieldName);
				}

				if (!current || dirty & /*index*/ 2 && input1_id_value !== (input1_id_value = `value-${/*index*/ ctx[1]}`)) {
					attr_dev(input1, "id", input1_id_value);
				}

				if (!current || dirty & /*field*/ 1 && input1_required_value !== (input1_required_value = /*field*/ ctx[0].fieldName !== 'TOTP')) {
					prop_dev(input1, "required", input1_required_value);
				}

				if (dirty & /*field*/ 1 && input1.value !== /*field*/ ctx[0].fieldValue) {
					set_input_value(input1, /*field*/ ctx[0].fieldValue);
				}

				if (!current || dirty & /*field*/ 1 && span0_class_value !== (span0_class_value = "block w-10 h-6 " + (/*field*/ ctx[0].sensitive
				? 'bg-osvauld-carolinablue'
				: 'bg-osvauld-placeholderblack') + " rounded-full shadow-inner")) {
					attr_dev(span0, "class", span0_class_value);
				}

				if (!current || dirty & /*index*/ 2 && input2_id_value !== (input2_id_value = `toggle-${/*index*/ ctx[1]}`)) {
					attr_dev(input2, "id", input2_id_value);
				}

				if (dirty & /*field*/ 1) {
					input2.checked = /*field*/ ctx[0].sensitive;
				}

				if (!current || dirty & /*field*/ 1 && span1_class_value !== (span1_class_value = "absolute block w-4 h-4 mt-1 ml-1 rounded-full shadow inset-y-0 left-0 focus-within:shadow-outline transform transition-transform duration-300 ease-in-out " + (/*field*/ ctx[0].sensitive
				? 'bg-osvauld-plainwhite translate-x-full'
				: 'bg-osvauld-chalkwhite'))) {
					attr_dev(span1, "class", span1_class_value);
				}

				if (!current || dirty & /*index*/ 2 && label_for_value !== (label_for_value = `toggle-${/*index*/ ctx[1]}`)) {
					attr_dev(label, "for", label_for_value);
				}

				if (/*index*/ ctx[1] === /*hoveredIndex*/ ctx[2]) {
					if (if_block) ; else {
						if_block = create_if_block$F(ctx);
						if_block.c();
						if_block.m(div0, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (!current || dirty & /*index, hoveredIndex*/ 6 && div0_class_value !== (div0_class_value = "flex items-center justify-center " + (/*index*/ ctx[1] === /*hoveredIndex*/ ctx[2]
				? 'relative'
				: ''))) {
					attr_dev(div0, "class", div0_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(binicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(binicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div3);
				}

				if (if_block) if_block.d();
				destroy_component(binicon);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$T.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$T($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('AddLoginFields', slots, []);
		let { field } = $$props;
		let { index } = $$props;
		let { hoveredIndex } = $$props;
		const dispatch = createEventDispatcher();

		const sensitiveLabelMaker = (index, identifier) => {
			dispatch("select", { index, identifier });
		};

		const removeEventDispatcher = index => {
			dispatch("remove", index);
		};

		$$self.$$.on_mount.push(function () {
			if (field === undefined && !('field' in $$props || $$self.$$.bound[$$self.$$.props['field']])) {
				console.warn("<AddLoginFields> was created without expected prop 'field'");
			}

			if (index === undefined && !('index' in $$props || $$self.$$.bound[$$self.$$.props['index']])) {
				console.warn("<AddLoginFields> was created without expected prop 'index'");
			}

			if (hoveredIndex === undefined && !('hoveredIndex' in $$props || $$self.$$.bound[$$self.$$.props['hoveredIndex']])) {
				console.warn("<AddLoginFields> was created without expected prop 'hoveredIndex'");
			}
		});

		const writable_props = ['field', 'index', 'hoveredIndex'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AddLoginFields> was created with unknown prop '${key}'`);
		});

		function input0_input_handler() {
			field.fieldName = this.value;
			$$invalidate(0, field);
		}

		const change_handler = () => dispatch('change');

		function input1_input_handler() {
			field.fieldValue = this.value;
			$$invalidate(0, field);
		}

		const change_handler_1 = () => dispatch('change');

		function input2_change_handler() {
			field.sensitive = this.checked;
			$$invalidate(0, field);
		}

		const change_handler_2 = () => dispatch('change');
		const mouseenter_handler = () => sensitiveLabelMaker(index, true);
		const mouseleave_handler = () => sensitiveLabelMaker(index, false);
		const click_handler = () => removeEventDispatcher(index);

		$$self.$$set = $$props => {
			if ('field' in $$props) $$invalidate(0, field = $$props.field);
			if ('index' in $$props) $$invalidate(1, index = $$props.index);
			if ('hoveredIndex' in $$props) $$invalidate(2, hoveredIndex = $$props.hoveredIndex);
		};

		$$self.$capture_state = () => ({
			BinIcon,
			createEventDispatcher,
			field,
			index,
			hoveredIndex,
			dispatch,
			sensitiveLabelMaker,
			removeEventDispatcher
		});

		$$self.$inject_state = $$props => {
			if ('field' in $$props) $$invalidate(0, field = $$props.field);
			if ('index' in $$props) $$invalidate(1, index = $$props.index);
			if ('hoveredIndex' in $$props) $$invalidate(2, hoveredIndex = $$props.hoveredIndex);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			field,
			index,
			hoveredIndex,
			dispatch,
			sensitiveLabelMaker,
			removeEventDispatcher,
			input0_input_handler,
			change_handler,
			input1_input_handler,
			change_handler_1,
			input2_change_handler,
			change_handler_2,
			mouseenter_handler,
			mouseleave_handler,
			click_handler
		];
	}

	class AddLoginFields extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$T, create_fragment$T, safe_not_equal, { field: 0, index: 1, hoveredIndex: 2 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "AddLoginFields",
				options,
				id: create_fragment$T.name
			});
		}

		get field() {
			throw new Error("<AddLoginFields>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set field(value) {
			throw new Error("<AddLoginFields>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get index() {
			throw new Error("<AddLoginFields>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set index(value) {
			throw new Error("<AddLoginFields>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get hoveredIndex() {
			throw new Error("<AddLoginFields>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set hoveredIndex(value) {
			throw new Error("<AddLoginFields>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/credentials/CredentialEditor.svelte generated by Svelte v4.2.19 */

	const { Error: Error_1$8 } = globals;
	const file$S = "src/lib/components/dashboard/credentials/CredentialEditor.svelte";

	function get_each_context$k(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[38] = list[i];
		child_ctx[40] = i;
		return child_ctx;
	}

	// (422:4) {#if edit}
	function create_if_block_7$4(ctx) {
		let button;
		let binicon;
		let current;
		let mounted;
		let dispose;
		binicon = new BinIcon({ $$inline: true });

		const block = {
			c: function create() {
				button = element("button");
				create_component(binicon.$$.fragment);
				attr_dev(button, "class", "bg-osvauld-frameblack p-4");
				attr_dev(button, "type", "button");
				add_location(button, file$S, 502, 5, 14531);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				mount_component(binicon, button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", /*deleteCredential*/ ctx[16], false, false, false, false);
					mounted = true;
				}
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(binicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(binicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(binicon);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_7$4.name,
			type: "if",
			source: "(422:4) {#if edit}",
			ctx
		});

		return block;
	}

	// (472:4) {:else}
	function create_else_block_1$b(ctx) {
		let textarea;
		let mounted;
		let dispose;

		const block = {
			c: function create() {
				textarea = element("textarea");
				attr_dev(textarea, "rows", "2");
				attr_dev(textarea, "class", "w-5/6 mt-4 h-auto min-h-[6rem] max-h-[10rem] bg-osvauld-frameblack rounded-lg scrollbar-thin border-osvauld-iconblack resize-none text-base focus:border-osvauld-iconblack focus:ring-0");
				attr_dev(textarea, "placeholder", "Enter note");
				add_location(textarea, file$S, 552, 5, 15919);
			},
			m: function mount(target, anchor) {
				insert_dev(target, textarea, anchor);
				set_input_value(textarea, /*credentialFields*/ ctx[0][0].fieldValue);

				if (!mounted) {
					dispose = [
						listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[27]),
						listen_dev(textarea, "change", /*change_handler_1*/ ctx[28], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*credentialFields*/ 1) {
					set_input_value(textarea, /*credentialFields*/ ctx[0][0].fieldValue);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(textarea);
				}

				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_1$b.name,
			type: "else",
			source: "(472:4) {:else}",
			ctx
		});

		return block;
	}

	// (456:4) {#if credentialType != "Note"}
	function create_if_block_5$8(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like_dev(/*credentialFields*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$k(get_each_context$k(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m: function mount(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert_dev(target, each_1_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*credentialFields, hoveredIndex, triggerSensitiveBubble, removeField, fieldEditHandler*/ 397569) {
					each_value = ensure_array_like_dev(/*credentialFields*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$k(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$k(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_5$8.name,
			type: "if",
			source: "(456:4) {#if credentialType != \\\"Note\\\"}",
			ctx
		});

		return block;
	}

	// (458:6) {#if field.fieldName !== "Domain"}
	function create_if_block_6$6(ctx) {
		let addloginfields;
		let current;

		function change_handler() {
			return /*change_handler*/ ctx[26](/*field*/ ctx[38]);
		}

		addloginfields = new AddLoginFields({
				props: {
					field: /*field*/ ctx[38],
					index: /*index*/ ctx[40],
					hoveredIndex: /*hoveredIndex*/ ctx[8]
				},
				$$inline: true
			});

		addloginfields.$on("select", /*select_handler*/ ctx[24]);
		addloginfields.$on("remove", /*remove_handler*/ ctx[25]);
		addloginfields.$on("change", change_handler);

		const block = {
			c: function create() {
				create_component(addloginfields.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(addloginfields, target, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const addloginfields_changes = {};
				if (dirty[0] & /*credentialFields*/ 1) addloginfields_changes.field = /*field*/ ctx[38];
				if (dirty[0] & /*hoveredIndex*/ 256) addloginfields_changes.hoveredIndex = /*hoveredIndex*/ ctx[8];
				addloginfields.$set(addloginfields_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(addloginfields.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(addloginfields.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(addloginfields, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_6$6.name,
			type: "if",
			source: "(458:6) {#if field.fieldName !== \\\"Domain\\\"}",
			ctx
		});

		return block;
	}

	// (457:5) {#each credentialFields as field, index}
	function create_each_block$k(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*field*/ ctx[38].fieldName !== "Domain" && create_if_block_6$6(ctx);

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (/*field*/ ctx[38].fieldName !== "Domain") {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty[0] & /*credentialFields*/ 1) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_6$6(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$k.name,
			type: "each",
			source: "(457:5) {#each credentialFields as field, index}",
			ctx
		});

		return block;
	}

	// (484:3) {#if credentialType != "Note"}
	function create_if_block_4$9(ctx) {
		let div;
		let button;
		let add;
		let current;
		let mounted;
		let dispose;

		add = new Add({
				props: { color: '#6E7681' },
				$$inline: true
			});

		const block = {
			c: function create() {
				div = element("div");
				button = element("button");
				create_component(add.$$.fragment);
				attr_dev(button, "class", "py-2 m-4 bg-osvauld-addfieldgrey flex-1 flex justify-center items-center rounded-md text-osvauld-chalkwhite border-2 border-dashed border-osvauld-iconblack");
				attr_dev(button, "type", "button");
				add_location(button, file$S, 565, 5, 16413);
				attr_dev(div, "class", "flex mr-24");
				add_location(div, file$S, 564, 4, 16383);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, button);
				mount_component(add, button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", /*addField*/ ctx[11], false, false, false, false);
					mounted = true;
				}
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(add.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(add.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(add);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_4$9.name,
			type: "if",
			source: "(484:3) {#if credentialType != \\\"Note\\\"}",
			ctx
		});

		return block;
	}

	// (504:2) {#if errorMessage !== ""}
	function create_if_block_3$e(ctx) {
		let t;

		const block = {
			c: function create() {
				t = text(/*errorMessage*/ ctx[9]);
			},
			m: function mount(target, anchor) {
				insert_dev(target, t, anchor);
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*errorMessage*/ 512) set_data_dev(t, /*errorMessage*/ ctx[9]);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$e.name,
			type: "if",
			source: "(504:2) {#if errorMessage !== \\\"\\\"}",
			ctx
		});

		return block;
	}

	// (509:3) {#if invalidTotp}
	function create_if_block_2$k(ctx) {
		let span;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = "TOTP Secret key invalid!";
				attr_dev(span, "class", "text-red-500 text-base font-normal mr-3 mb-6");
				add_location(span, file$S, 589, 4, 17323);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$k.name,
			type: "if",
			source: "(509:3) {#if invalidTotp}",
			ctx
		});

		return block;
	}

	// (515:3) {#if invalidUrl}
	function create_if_block_1$t(ctx) {
		let span;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = "invalid url!!";
				attr_dev(span, "class", "text-red-500 text-base font-normal mr-3 mb-6");
				add_location(span, file$S, 595, 4, 17459);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$t.name,
			type: "if",
			source: "(515:3) {#if invalidUrl}",
			ctx
		});

		return block;
	}

	// (534:4) {:else}
	function create_else_block$o(ctx) {
		let span;
		let t_value = (/*edit*/ ctx[4] ? "Save Changes" : "Add credential") + "";
		let t;

		const block = {
			c: function create() {
				span = element("span");
				t = text(t_value);
				attr_dev(span, "class", "w-[8.6rem]");
				add_location(span, file$S, 614, 5, 18368);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				append_dev(span, t);
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*edit*/ 16 && t_value !== (t_value = (/*edit*/ ctx[4] ? "Save Changes" : "Add credential") + "")) set_data_dev(t, t_value);
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$o.name,
			type: "else",
			source: "(534:4) {:else}",
			ctx
		});

		return block;
	}

	// (530:4) {#if isLoaderActive}
	function create_if_block$E(ctx) {
		let span;
		let loader;
		let current;

		loader = new Loader({
				props: { size: 24, color: "#1F242A", duration: 1 },
				$$inline: true
			});

		const block = {
			c: function create() {
				span = element("span");
				create_component(loader.$$.fragment);
				attr_dev(span, "class", "w-[8.6rem] flex justify-center items-center");
				add_location(span, file$S, 610, 5, 18219);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				mount_component(loader, span, null);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(loader.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(loader.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				destroy_component(loader);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$E.name,
			type: "if",
			source: "(530:4) {#if isLoaderActive}",
			ctx
		});

		return block;
	}

	function create_fragment$S(ctx) {
		let form;
		let div9;
		let div2;
		let div0;
		let button0;
		let t0_value = (/*edit*/ ctx[4] ? "Edit Login" : "Login") + "";
		let t0;
		let button0_class_value;
		let t1;
		let button1;
		let t2_value = (/*edit*/ ctx[4] ? "Edit Custom" : "Custom") + "";
		let t2;
		let button1_class_value;
		let t3;
		let button2;
		let t4_value = (/*edit*/ ctx[4] ? "Edit Note" : "Note") + "";
		let t4;
		let button2_class_value;
		let t5;
		let div1;
		let t6;
		let button3;
		let closepanel;
		let t7;
		let div3;
		let t8;
		let div5;
		let div4;
		let input;
		let input_class_value;
		let t9;
		let current_block_type_index;
		let if_block1;
		let t10;
		let t11;
		let div6;
		let textarea;
		let t12;
		let t13;
		let div7;
		let t14;
		let div8;
		let t15;
		let t16;
		let button4;
		let t18;
		let button5;
		let current_block_type_index_1;
		let if_block6;
		let div9_intro;
		let div9_outro;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*edit*/ ctx[4] && create_if_block_7$4(ctx);
		closepanel = new ClosePanel({ $$inline: true });
		const if_block_creators = [create_if_block_5$8, create_else_block_1$b];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*credentialType*/ ctx[3] != "Note") return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		let if_block2 = /*credentialType*/ ctx[3] != "Note" && create_if_block_4$9(ctx);
		let if_block3 = /*errorMessage*/ ctx[9] !== "" && create_if_block_3$e(ctx);
		let if_block4 = /*invalidTotp*/ ctx[6] && create_if_block_2$k(ctx);
		let if_block5 = /*invalidUrl*/ ctx[10] && create_if_block_1$t(ctx);
		const if_block_creators_1 = [create_if_block$E, create_else_block$o];
		const if_blocks_1 = [];

		function select_block_type_1(ctx, dirty) {
			if (/*isLoaderActive*/ ctx[7]) return 0;
			return 1;
		}

		current_block_type_index_1 = select_block_type_1(ctx);
		if_block6 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

		const block = {
			c: function create() {
				form = element("form");
				div9 = element("div");
				div2 = element("div");
				div0 = element("div");
				button0 = element("button");
				t0 = text(t0_value);
				t1 = space();
				button1 = element("button");
				t2 = text(t2_value);
				t3 = space();
				button2 = element("button");
				t4 = text(t4_value);
				t5 = space();
				div1 = element("div");
				if (if_block0) if_block0.c();
				t6 = space();
				button3 = element("button");
				create_component(closepanel.$$.fragment);
				t7 = space();
				div3 = element("div");
				t8 = space();
				div5 = element("div");
				div4 = element("div");
				input = element("input");
				t9 = space();
				if_block1.c();
				t10 = space();
				if (if_block2) if_block2.c();
				t11 = space();
				div6 = element("div");
				textarea = element("textarea");
				t12 = space();
				if (if_block3) if_block3.c();
				t13 = space();
				div7 = element("div");
				t14 = space();
				div8 = element("div");
				if (if_block4) if_block4.c();
				t15 = space();
				if (if_block5) if_block5.c();
				t16 = space();
				button4 = element("button");
				button4.textContent = "Cancel";
				t18 = space();
				button5 = element("button");
				if_block6.c();

				attr_dev(button0, "class", button0_class_value = "text-[28px] font-sans font-normal " + (/*credentialType*/ ctx[3] === 'Login'
				? 'text-osvauld-quarzowhite border-b-2 border-osvauld-carolinablue'
				: 'text-osvauld-sheffieldgrey '));

				attr_dev(button0, "type", "button");
				add_location(button0, file$S, 469, 4, 13476);

				attr_dev(button1, "class", button1_class_value = "text-[28px] font-sans font-normal ml-8 " + (/*credentialType*/ ctx[3] === 'Custom'
				? 'text-osvauld-quarzowhite border-b-2 border-osvauld-carolinablue'
				: 'text-osvauld-sheffieldgrey '));

				attr_dev(button1, "type", "button");
				add_location(button1, file$S, 478, 4, 13809);

				attr_dev(button2, "class", button2_class_value = "text-[28px] font-sans font-normal ml-8 " + (/*credentialType*/ ctx[3] === 'Note'
				? 'text-osvauld-quarzowhite border-b-2 border-osvauld-carolinablue'
				: 'text-osvauld-sheffieldgrey '));

				attr_dev(button2, "type", "button");
				add_location(button2, file$S, 489, 4, 14157);
				add_location(div0, file$S, 468, 3, 13466);
				attr_dev(button3, "class", "bg-osvauld-frameblack p-4");
				attr_dev(button3, "type", "button");
				add_location(button3, file$S, 509, 4, 14677);
				add_location(div1, file$S, 500, 3, 14505);
				attr_dev(div2, "class", "flex justify-between items-center px-12 py-6");
				add_location(div2, file$S, 467, 2, 13404);
				attr_dev(div3, "class", "border-b border-osvauld-iconblack w-full");
				add_location(div3, file$S, 517, 2, 14824);

				attr_dev(input, "class", input_class_value = "w-[78%] mb-2 mt-4 ml-6 pl-4 bg-osvauld-frameblack border rounded-md text-base text-osvauld-quarzowhite font-normal focus:border-osvauld-activeBorder flex focus:ring-0 placeholder-osvauld-iconblack " + (/*notNamed*/ ctx[5]
				? 'border-red-500'
				: 'border-osvauld-iconblack '));

				attr_dev(input, "id", "name");
				attr_dev(input, "type", "text");
				attr_dev(input, "placeholder", "Enter Credential name....");
				attr_dev(input, "autocomplete", "off");
				add_location(input, file$S, 523, 4, 15000);
				attr_dev(div4, "class", "min-h-[32vh] max-h-[35vh] overflow-y-scroll scrollbar-thin z-50");
				add_location(div4, file$S, 520, 3, 14910);
				attr_dev(div5, "class", "mx-6");
				add_location(div5, file$S, 519, 2, 14888);
				attr_dev(textarea, "rows", "2");
				attr_dev(textarea, "class", "w-5/6 mt-4 h-auto min-h-[6rem] max-h-[10rem] bg-osvauld-frameblack rounded-lg scrollbar-thin border-osvauld-iconblack resize-none text-base focus:border-osvauld-iconblack focus:ring-0");
				attr_dev(textarea, "placeholder", "Enter description about the secret");
				add_location(textarea, file$S, 576, 3, 16791);
				attr_dev(div6, "class", "mx-6 pl-3 flex justify-start items-center mb-5");
				add_location(div6, file$S, 575, 2, 16726);
				attr_dev(div7, "class", "border-b border-osvauld-iconblack w-full my-2");
				add_location(div7, file$S, 586, 2, 17175);
				attr_dev(button4, "class", "px-3 py-1.5 mb-6 whitespace-nowrap text-osvauld-fadedCancel bg-osvauld-frameblack hover:bg-osvauld-cardshade flex justify-center items-center rounded-md hover:text-osvauld-textActive text-base font-normal");
				attr_dev(button4, "type", "button");
				add_location(button4, file$S, 599, 3, 17562);
				attr_dev(button5, "type", "submit");
				attr_dev(button5, "class", "px-3 py-1.5 mb-6 whitespace-nowrap flex justify-center items-center ml-3 border border-osvauld-textActive text-osvauld-textActive hover:bg-osvauld-carolinablue hover:text-osvauld-frameblack hover:border-osvauld-carolinablue font-normal text-base rounded-md");
				button5.disabled = /*isLoaderActive*/ ctx[7];
				add_location(button5, file$S, 604, 3, 17857);
				attr_dev(div8, "class", "flex justify-end items-center mx-10 py-2");
				add_location(div8, file$S, 587, 2, 17243);
				attr_dev(div9, "class", "bg-osvauld-frameblack rounded-3xl border border-osvauld-iconblack z-50");
				add_location(div9, file$S, 462, 1, 13293);
				add_location(form, file$S, 461, 0, 13241);
			},
			l: function claim(nodes) {
				throw new Error_1$8("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, form, anchor);
				append_dev(form, div9);
				append_dev(div9, div2);
				append_dev(div2, div0);
				append_dev(div0, button0);
				append_dev(button0, t0);
				append_dev(div0, t1);
				append_dev(div0, button1);
				append_dev(button1, t2);
				append_dev(div0, t3);
				append_dev(div0, button2);
				append_dev(button2, t4);
				append_dev(div2, t5);
				append_dev(div2, div1);
				if (if_block0) if_block0.m(div1, null);
				append_dev(div1, t6);
				append_dev(div1, button3);
				mount_component(closepanel, button3, null);
				append_dev(div9, t7);
				append_dev(div9, div3);
				append_dev(div9, t8);
				append_dev(div9, div5);
				append_dev(div5, div4);
				append_dev(div4, input);
				set_input_value(input, /*name*/ ctx[2]);
				append_dev(div4, t9);
				if_blocks[current_block_type_index].m(div4, null);
				append_dev(div5, t10);
				if (if_block2) if_block2.m(div5, null);
				append_dev(div9, t11);
				append_dev(div9, div6);
				append_dev(div6, textarea);
				set_input_value(textarea, /*description*/ ctx[1]);
				append_dev(div9, t12);
				if (if_block3) if_block3.m(div9, null);
				append_dev(div9, t13);
				append_dev(div9, div7);
				append_dev(div9, t14);
				append_dev(div9, div8);
				if (if_block4) if_block4.m(div8, null);
				append_dev(div8, t15);
				if (if_block5) if_block5.m(div8, null);
				append_dev(div8, t16);
				append_dev(div8, button4);
				append_dev(div8, t18);
				append_dev(div8, button5);
				if_blocks_1[current_block_type_index_1].m(button5, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", /*click_handler*/ ctx[20], false, false, false, false),
						listen_dev(button1, "click", /*click_handler_1*/ ctx[21], false, false, false, false),
						listen_dev(button2, "click", /*click_handler_2*/ ctx[22], false, false, false, false),
						listen_dev(button3, "click", /*closeDialog*/ ctx[15], false, false, false, false),
						listen_dev(input, "input", /*input_input_handler*/ ctx[23]),
						listen_dev(textarea, "input", /*textarea_input_handler_1*/ ctx[29]),
						listen_dev(button4, "click", /*closeDialog*/ ctx[15], false, false, false, false),
						listen_dev(form, "submit", prevent_default(/*saveCredential*/ ctx[13]), false, true, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if ((!current || dirty[0] & /*edit*/ 16) && t0_value !== (t0_value = (/*edit*/ ctx[4] ? "Edit Login" : "Login") + "")) set_data_dev(t0, t0_value);

				if (!current || dirty[0] & /*credentialType*/ 8 && button0_class_value !== (button0_class_value = "text-[28px] font-sans font-normal " + (/*credentialType*/ ctx[3] === 'Login'
				? 'text-osvauld-quarzowhite border-b-2 border-osvauld-carolinablue'
				: 'text-osvauld-sheffieldgrey '))) {
					attr_dev(button0, "class", button0_class_value);
				}

				if ((!current || dirty[0] & /*edit*/ 16) && t2_value !== (t2_value = (/*edit*/ ctx[4] ? "Edit Custom" : "Custom") + "")) set_data_dev(t2, t2_value);

				if (!current || dirty[0] & /*credentialType*/ 8 && button1_class_value !== (button1_class_value = "text-[28px] font-sans font-normal ml-8 " + (/*credentialType*/ ctx[3] === 'Custom'
				? 'text-osvauld-quarzowhite border-b-2 border-osvauld-carolinablue'
				: 'text-osvauld-sheffieldgrey '))) {
					attr_dev(button1, "class", button1_class_value);
				}

				if ((!current || dirty[0] & /*edit*/ 16) && t4_value !== (t4_value = (/*edit*/ ctx[4] ? "Edit Note" : "Note") + "")) set_data_dev(t4, t4_value);

				if (!current || dirty[0] & /*credentialType*/ 8 && button2_class_value !== (button2_class_value = "text-[28px] font-sans font-normal ml-8 " + (/*credentialType*/ ctx[3] === 'Note'
				? 'text-osvauld-quarzowhite border-b-2 border-osvauld-carolinablue'
				: 'text-osvauld-sheffieldgrey '))) {
					attr_dev(button2, "class", button2_class_value);
				}

				if (/*edit*/ ctx[4]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*edit*/ 16) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_7$4(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div1, t6);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (!current || dirty[0] & /*notNamed*/ 32 && input_class_value !== (input_class_value = "w-[78%] mb-2 mt-4 ml-6 pl-4 bg-osvauld-frameblack border rounded-md text-base text-osvauld-quarzowhite font-normal focus:border-osvauld-activeBorder flex focus:ring-0 placeholder-osvauld-iconblack " + (/*notNamed*/ ctx[5]
				? 'border-red-500'
				: 'border-osvauld-iconblack '))) {
					attr_dev(input, "class", input_class_value);
				}

				if (dirty[0] & /*name*/ 4 && input.value !== /*name*/ ctx[2]) {
					set_input_value(input, /*name*/ ctx[2]);
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div4, null);
				}

				if (/*credentialType*/ ctx[3] != "Note") {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty[0] & /*credentialType*/ 8) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_4$9(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(div5, null);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (dirty[0] & /*description*/ 2) {
					set_input_value(textarea, /*description*/ ctx[1]);
				}

				if (/*errorMessage*/ ctx[9] !== "") {
					if (if_block3) {
						if_block3.p(ctx, dirty);
					} else {
						if_block3 = create_if_block_3$e(ctx);
						if_block3.c();
						if_block3.m(div9, t13);
					}
				} else if (if_block3) {
					if_block3.d(1);
					if_block3 = null;
				}

				if (/*invalidTotp*/ ctx[6]) {
					if (if_block4) ; else {
						if_block4 = create_if_block_2$k(ctx);
						if_block4.c();
						if_block4.m(div8, t15);
					}
				} else if (if_block4) {
					if_block4.d(1);
					if_block4 = null;
				}

				if (/*invalidUrl*/ ctx[10]) {
					if (if_block5) ; else {
						if_block5 = create_if_block_1$t(ctx);
						if_block5.c();
						if_block5.m(div8, t16);
					}
				} else if (if_block5) {
					if_block5.d(1);
					if_block5 = null;
				}

				let previous_block_index_1 = current_block_type_index_1;
				current_block_type_index_1 = select_block_type_1(ctx);

				if (current_block_type_index_1 === previous_block_index_1) {
					if_blocks_1[current_block_type_index_1].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
						if_blocks_1[previous_block_index_1] = null;
					});

					check_outros();
					if_block6 = if_blocks_1[current_block_type_index_1];

					if (!if_block6) {
						if_block6 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
						if_block6.c();
					} else {
						if_block6.p(ctx, dirty);
					}

					transition_in(if_block6, 1);
					if_block6.m(button5, null);
				}

				if (!current || dirty[0] & /*isLoaderActive*/ 128) {
					prop_dev(button5, "disabled", /*isLoaderActive*/ ctx[7]);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(closepanel.$$.fragment, local);
				transition_in(if_block1);
				transition_in(if_block2);
				transition_in(if_block6);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (div9_outro) div9_outro.end(1);
						div9_intro = create_in_transition(div9, fly, {});
						div9_intro.start();
					});
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(closepanel.$$.fragment, local);
				transition_out(if_block1);
				transition_out(if_block2);
				transition_out(if_block6);
				if (div9_intro) div9_intro.invalidate();

				if (local) {
					div9_outro = create_out_transition(div9, blur, {});
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(form);
				}

				if (if_block0) if_block0.d();
				destroy_component(closepanel);
				if_blocks[current_block_type_index].d();
				if (if_block2) if_block2.d();
				if (if_block3) if_block3.d();
				if (if_block4) if_block4.d();
				if (if_block5) if_block5.d();
				if_blocks_1[current_block_type_index_1].d();
				if (detaching && div9_outro) div9_outro.end();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$S.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$S($$self, $$props, $$invalidate) {
		let $selectedFolder;
		validate_store(selectedFolder, 'selectedFolder');
		component_subscribe($$self, selectedFolder, $$value => $$invalidate(32, $selectedFolder = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('CredentialEditor', slots, []);
		let { edit = false } = $$props;

		let { credentialFields = [
			{
				fieldName: "Username",
				fieldValue: "",
				sensitive: false
			},
			{
				fieldName: "Password",
				fieldValue: "",
				sensitive: true
			},
			{
				fieldName: "URL",
				fieldValue: "https://",
				sensitive: false
			},
			{
				fieldName: "TOTP",
				fieldValue: "",
				sensitive: true
			}
		] } = $$props;

		let { credentialId = "" } = $$props;
		let { description = "" } = $$props;
		let { name = "" } = $$props;
		let { credentialType = "Login" } = $$props;
		let notNamed = false;
		let invalidTotp = false;
		let isLoaderActive = false;
		let usersToShare = [];
		let addCredentialPaylod;
		let hoveredIndex = null;
		let errorMessage = "";
		let changedFields = new Set();
		let deletedFields = [];
		let invalidUrl = false;
		const dispatcher = createEventDispatcher();

		const addField = () => {
			let newField = {
				fieldName: "",
				fieldValue: "",
				sensitive: false
			};

			$$invalidate(0, credentialFields = [...credentialFields, newField]);
		};

		//TODO: change user type
		const removeField = index => {
			const field = credentialFields[index];

			if (field && field.fieldId) {
				const fieldId = field.fieldId;

				if (typeof fieldId === "string") {
					deletedFields.push(fieldId);
				}
			}

			credentialFields.splice(index, 1);
			$$invalidate(0, credentialFields = [...credentialFields]);
		};

		const totpValidator = secretKey => {
			// Base32 encoded TOTP secrets typically range in size, allowing for flexibility
			if (secretKey.length < 10 || secretKey.length > 64) {
				return false;
			}

			// Check character set: Only uppercase letters A-Z and digits 2-7 are valid
			const validBase32Regex = /^[A-Z2-7]+$/;

			if (!validBase32Regex.test(secretKey)) {
				return false;
			}

			return true;
		};

		const editCredential = async () => {
			if (!credentialId) {
				dispatcher("close");
				throw new Error("credential not selected");
			}

			const editedUserFields = [];
			const editedEnvFields = [];
			const newFields = [];
			const envResponse = await getEnvsForCredential(credentialId);

			const users = usersToShare.map(user => ({
				userId: user.id,
				publicKey: user.publicKey
			}));

			const envFieldsResponse = await getEnvFieldsByCredentialId(credentialId);

			let userEnvMap = envResponse.data.reduce(
				(obj, item) => {
					if (!obj[item.cliUserCreatedBy]) {
						obj[item.cliUserCreatedBy] = [];
					}

					obj[item.cliUserCreatedBy].push(item);
					return obj;
				},
				{}
			);
			const envFieldMap = envFieldsResponse.data;

			for (const field of credentialFields) {
				if (field.fieldName === "URL") {
					getDomain(field.fieldValue);
				}

				let editedUserField;

				if (field.fieldId && changedFields.has(field.fieldId)) {
					editedUserField = {
						fieldId: field.fieldId,
						fieldName: field.fieldName,
						fieldType: field.fieldName === "TOTP"
						? "totp"
						: field.sensitive ? "sensitive" : "meta",
						fieldValues: []
					};

					if (field?.fieldId && envFieldMap[field.fieldId]) {
						// making envFieldId as userId to reuse 'encryptEditFields' case
						const envFieldPayloadForEncryption = envFieldMap[field.fieldId].map(envField => {
							return {
								userId: envField.envFieldId,
								publicKey: envField.cliUserPublicKey
							};
						});

						const encryptedEditFields = await sendMessage("encryptEditFields", {
							fieldValue: field.fieldValue,
							usersToShare: envFieldPayloadForEncryption
						});

						const envFieldPayload = encryptedEditFields.map(envField => {
							return {
								envFieldId: envField.userId,
								fieldValue: envField.fieldValue
							};
						});

						editedEnvFields.push(...envFieldPayload);
					}

					const encryptedEditFields = await sendMessage("encryptEditFields", {
						fieldValue: field.fieldValue,
						usersToShare: users
					});

					editedUserField.fieldValues = encryptedEditFields;
					editedUserFields.push(editedUserField);
				} else if (!field.fieldId) {
					const newFieldPayload = {
						fieldName: field.fieldName,
						fieldType: field.fieldName === "TOTP"
						? "totp"
						: field.sensitive ? "sensitive" : "meta",
						fieldValues: []
					};

					const encryptedEditFields = await sendMessage("encryptEditFields", {
						fieldValue: field.fieldValue,
						usersToShare: users
					});

					for (const fieldData of encryptedEditFields) {
						let payload = {
							fieldValue: fieldData.fieldValue,
							userId: fieldData.userId,
							envFieldValues: []
						};

						if (userEnvMap[fieldData.userId]) {
							const cliUsersToShare = userEnvMap[fieldData.userId].map(envData => {
								return {
									userId: envData.envId,
									publicKey: envData.cliUserPublicKey
								};
							});

							const encryptedFields = await sendMessage("encryptEditFields", {
								fieldValue: field.fieldValue,
								usersToShare: cliUsersToShare
							});

							const envFieldsValues = encryptedFields.map(envField => {
								return {
									envId: envField.userId,
									fieldValue: envField.fieldValue
								};
							});

							payload.envFieldValues = envFieldsValues;
						}

						newFieldPayload.fieldValues.push(payload);
					}

					newFields.push(newFieldPayload);
				}
			}

			const payload = {
				name,
				description,
				credentialId,
				credentialType,
				editedUserFields,
				editedEnvFields,
				newFields,
				domain: "",
				deletedFields
			};

			await updateCredential(payload, credentialId);
			await setCredentialStore();
			$$invalidate(7, isLoaderActive = false);
			dispatcher("close");
		};

		const saveCredential = async () => {
			$$invalidate(7, isLoaderActive = true);
			$$invalidate(9, errorMessage = "");
			if ($selectedFolder === undefined) throw new Error("folder not selected");

			if (name.length === 0) {
				$$invalidate(7, isLoaderActive = false);
				$$invalidate(5, notNamed = true);

				setTimeout(
					() => {
						$$invalidate(5, notNamed = false);
					},
					1000
				);

				return;
			}

			let totpPresence = credentialFields.find(field => {
				if (field.fieldName === "TOTP" && field.fieldValue.length !== 0) {
					return field;
				}
			});

			let isValidUrl = !credentialFields.some(field => {
				if (field.fieldName === "URL") {
					try {
						getDomain(field.fieldValue);
						return false;
					} catch(_) {
						return true;
					}
				}

				return false;
			});

			if (totpPresence) {
				const isTotpValid = totpValidator(totpPresence.fieldValue);

				if (!isTotpValid) {
					$$invalidate(7, isLoaderActive = false);
					$$invalidate(6, invalidTotp = true);

					setTimeout(
						() => {
							$$invalidate(6, invalidTotp = false);
						},
						1000
					);

					return;
				}
			}

			if (!isValidUrl) {
				$$invalidate(7, isLoaderActive = false);
				$$invalidate(10, invalidUrl = true);

				setTimeout(
					() => {
						$$invalidate(10, invalidUrl = false);
					},
					1000
				);

				return;
			}

			if (edit) {
				await editCredential();
				$$invalidate(7, isLoaderActive = false);
				dispatcher("close");
				return;
			}

			let addCredentialFields = [];
			let domain = "";

			for (const field of credentialFields) {
				if (field.fieldName === "URL" && field.fieldValue.length !== 0) {
					try {
						if (!field.fieldValue.startsWith("https://") && !field.fieldValue.startsWith("http://")) {
							$$invalidate(9, errorMessage = "Invalid URL");
							$$invalidate(7, isLoaderActive = false);
							return;
						}

						domain = getDomain(field.fieldValue);

						addCredentialFields.push({
							fieldName: "Domain",
							fieldValue: domain,
							fieldType: "additional"
						});
					} catch(error) {
						$$invalidate(9, errorMessage = "Invalid URL");
						$$invalidate(7, isLoaderActive = false);
						return;
					}
				}

				if ((field.fieldName.length !== 0 || field.fieldValue.length !== 0) && field.fieldName !== "Domain") {
					const baseField = {
						fieldName: field.fieldName,
						fieldValue: field.fieldValue,
						fieldType: field.sensitive ? "sensitive" : "meta"
					};

					if (field.fieldName === "TOTP") {
						if (field.fieldValue.length !== 0) {
							baseField.fieldType = "totp";
							addCredentialFields.push(baseField);
						} else {
							continue;
						}
					} else {
						addCredentialFields.push(baseField);
					}
				}
			}

			addCredentialPaylod = {
				name,
				description,
				folderId: $selectedFolder.id,
				credentialType,
				userFields: [],
				domain: ""
			};

			const response = await sendMessage("addCredential", { users: usersToShare, addCredentialFields });
			addCredentialPaylod.userFields = response;
			await addCredential(addCredentialPaylod);
			await setCredentialStore();
			$$invalidate(7, isLoaderActive = false);
			dispatcher("close");
		};

		const credentialTypeSelection = type => {
			$$invalidate(3, credentialType = type);

			if (credentialType === "Custom") {
				$$invalidate(0, credentialFields = [
					{
						fieldName: "Field Name",
						fieldValue: "",
						sensitive: false
					},
					{
						fieldName: "TOTP",
						fieldValue: "",
						sensitive: true
					}
				]);
			} else if (credentialType === "Login") {
				$$invalidate(0, credentialFields = [
					{
						fieldName: "Username",
						fieldValue: "",
						sensitive: false
					},
					{
						fieldName: "Password",
						fieldValue: "",
						sensitive: true
					},
					{
						fieldName: "URL",
						fieldValue: "https://",
						sensitive: false
					},
					{
						fieldName: "TOTP",
						fieldValue: "",
						sensitive: true
					}
				]);
			} else if (credentialType == "Note") {
				$$invalidate(0, credentialFields = [
					{
						fieldName: "Note",
						fieldValue: "",
						sensitive: false
					}
				]);
			}
		};

		onMount(async () => {
			if (edit && credentialId) {
				const responseJson = await fetchCredentialUsersForDataSync(credentialId);
				usersToShare = responseJson.data;
			} else {
				if ($selectedFolder === undefined) {
					throw new Error("Folder not selected");
				}

				const responseJson = await fetchFolderUsersForDataSync($selectedFolder.id);
				usersToShare = responseJson.data;
			}
		});

		const closeDialog = () => {
			dispatcher("close");
		};

		const deleteCredential = () => {
			if ($selectedFolder === undefined || credentialId === null) {
				throw new Error("Folder not selected");
			}

			modalManager.set({
				id: credentialId,
				name,
				type: "Credential",
				private: $selectedFolder.type === "private"
			});

			DeleteConfirmationModal.set(true);
		};

		const triggerSensitiveBubble = (index, isEnter) => {
			isEnter
			? $$invalidate(8, hoveredIndex = index)
			: $$invalidate(8, hoveredIndex = null);
		};

		const fieldEditHandler = field => {
			if (edit && field.fieldId) {
				changedFields.add(field.fieldId);

				if (field.fieldName === "URL") {
					for (const fieldData of credentialFields) {
						if (fieldData.fieldName === "Domain") {
							changedFields.add(fieldData.fieldId);
							const updatedDomain = getDomain(field.fieldValue);
							fieldData.fieldValue = updatedDomain;
						}
					}
				}
			}
		};

		const writable_props = [
			'edit',
			'credentialFields',
			'credentialId',
			'description',
			'name',
			'credentialType'
		];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CredentialEditor> was created with unknown prop '${key}'`);
		});

		const click_handler = () => credentialTypeSelection('Login');
		const click_handler_1 = () => credentialTypeSelection('Custom');
		const click_handler_2 = () => credentialTypeSelection('Note');

		function input_input_handler() {
			name = this.value;
			$$invalidate(2, name);
		}

		const select_handler = e => triggerSensitiveBubble(e.detail.index, e.detail.identifier);
		const remove_handler = e => removeField(e.detail);

		const change_handler = field => {
			fieldEditHandler(field);
		};

		function textarea_input_handler() {
			credentialFields[0].fieldValue = this.value;
			$$invalidate(0, credentialFields);
		}

		const change_handler_1 = () => {
			fieldEditHandler(credentialFields[0]);
		};

		function textarea_input_handler_1() {
			description = this.value;
			$$invalidate(1, description);
		}

		$$self.$$set = $$props => {
			if ('edit' in $$props) $$invalidate(4, edit = $$props.edit);
			if ('credentialFields' in $$props) $$invalidate(0, credentialFields = $$props.credentialFields);
			if ('credentialId' in $$props) $$invalidate(19, credentialId = $$props.credentialId);
			if ('description' in $$props) $$invalidate(1, description = $$props.description);
			if ('name' in $$props) $$invalidate(2, name = $$props.name);
			if ('credentialType' in $$props) $$invalidate(3, credentialType = $$props.credentialType);
		};

		$$self.$capture_state = () => ({
			onMount,
			fly,
			blur,
			ClosePanel,
			Add,
			BinIcon,
			Loader,
			createEventDispatcher,
			selectedFolder,
			modalManager,
			DeleteConfirmationModal,
			fetchFolderUsersForDataSync,
			addCredential,
			updateCredential,
			fetchCredentialUsersForDataSync,
			getEnvFieldsByCredentialId,
			getEnvsForCredential,
			AddLoginFields,
			sendMessage,
			getDomain,
			setCredentialStore,
			edit,
			credentialFields,
			credentialId,
			description,
			name,
			credentialType,
			notNamed,
			invalidTotp,
			isLoaderActive,
			usersToShare,
			addCredentialPaylod,
			hoveredIndex,
			errorMessage,
			changedFields,
			deletedFields,
			invalidUrl,
			dispatcher,
			addField,
			removeField,
			totpValidator,
			editCredential,
			saveCredential,
			credentialTypeSelection,
			closeDialog,
			deleteCredential,
			triggerSensitiveBubble,
			fieldEditHandler,
			$selectedFolder
		});

		$$self.$inject_state = $$props => {
			if ('edit' in $$props) $$invalidate(4, edit = $$props.edit);
			if ('credentialFields' in $$props) $$invalidate(0, credentialFields = $$props.credentialFields);
			if ('credentialId' in $$props) $$invalidate(19, credentialId = $$props.credentialId);
			if ('description' in $$props) $$invalidate(1, description = $$props.description);
			if ('name' in $$props) $$invalidate(2, name = $$props.name);
			if ('credentialType' in $$props) $$invalidate(3, credentialType = $$props.credentialType);
			if ('notNamed' in $$props) $$invalidate(5, notNamed = $$props.notNamed);
			if ('invalidTotp' in $$props) $$invalidate(6, invalidTotp = $$props.invalidTotp);
			if ('isLoaderActive' in $$props) $$invalidate(7, isLoaderActive = $$props.isLoaderActive);
			if ('usersToShare' in $$props) usersToShare = $$props.usersToShare;
			if ('addCredentialPaylod' in $$props) addCredentialPaylod = $$props.addCredentialPaylod;
			if ('hoveredIndex' in $$props) $$invalidate(8, hoveredIndex = $$props.hoveredIndex);
			if ('errorMessage' in $$props) $$invalidate(9, errorMessage = $$props.errorMessage);
			if ('changedFields' in $$props) changedFields = $$props.changedFields;
			if ('deletedFields' in $$props) deletedFields = $$props.deletedFields;
			if ('invalidUrl' in $$props) $$invalidate(10, invalidUrl = $$props.invalidUrl);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			credentialFields,
			description,
			name,
			credentialType,
			edit,
			notNamed,
			invalidTotp,
			isLoaderActive,
			hoveredIndex,
			errorMessage,
			invalidUrl,
			addField,
			removeField,
			saveCredential,
			credentialTypeSelection,
			closeDialog,
			deleteCredential,
			triggerSensitiveBubble,
			fieldEditHandler,
			credentialId,
			click_handler,
			click_handler_1,
			click_handler_2,
			input_input_handler,
			select_handler,
			remove_handler,
			change_handler,
			textarea_input_handler,
			change_handler_1,
			textarea_input_handler_1
		];
	}

	class CredentialEditor extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(
				this,
				options,
				instance$S,
				create_fragment$S,
				safe_not_equal,
				{
					edit: 4,
					credentialFields: 0,
					credentialId: 19,
					description: 1,
					name: 2,
					credentialType: 3
				},
				null,
				[-1, -1]
			);

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "CredentialEditor",
				options,
				id: create_fragment$S.name
			});
		}

		get edit() {
			throw new Error_1$8("<CredentialEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set edit(value) {
			throw new Error_1$8("<CredentialEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get credentialFields() {
			throw new Error_1$8("<CredentialEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set credentialFields(value) {
			throw new Error_1$8("<CredentialEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get credentialId() {
			throw new Error_1$8("<CredentialEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set credentialId(value) {
			throw new Error_1$8("<CredentialEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get description() {
			throw new Error_1$8("<CredentialEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set description(value) {
			throw new Error_1$8("<CredentialEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get name() {
			throw new Error_1$8("<CredentialEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set name(value) {
			throw new Error_1$8("<CredentialEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get credentialType() {
			throw new Error_1$8("<CredentialEditor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set credentialType(value) {
			throw new Error_1$8("<CredentialEditor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/components/AccessSelector.svelte generated by Svelte v4.2.19 */
	const file$R = "src/lib/components/dashboard/components/AccessSelector.svelte";

	// (15:1) {#if !reverseModal}
	function create_if_block_1$s(ctx) {
		let button;
		let t;
		let span;
		let downarrow;
		let current;
		let mounted;
		let dispose;

		downarrow = new DownArrow({
				props: { type: 'indicator' },
				$$inline: true
			});

		const block = {
			c: function create() {
				button = element("button");
				t = text("Permissions ");
				span = element("span");
				create_component(downarrow.$$.fragment);
				add_location(span, file$R, 20, 16, 803);
				attr_dev(button, "class", "text-osvauld-permissionGreenText bg-osvauld-permissionsGreen w-full rounded-md cursor-pointer px-2 py-0.5 mt-0.5 flex justify-around items-center");
				add_location(button, file$R, 17, 2, 551);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				append_dev(button, t);
				append_dev(button, span);
				mount_component(downarrow, span, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", stop_propagation(/*click_handler*/ ctx[3]), false, false, true, false);
					mounted = true;
				}
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(downarrow.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(downarrow.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(downarrow);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$s.name,
			type: "if",
			source: "(15:1) {#if !reverseModal}",
			ctx
		});

		return block;
	}

	// (30:1) {#if reverseModal}
	function create_if_block$D(ctx) {
		let button;
		let t;
		let span;
		let downarrow;
		let current;
		let mounted;
		let dispose;

		downarrow = new DownArrow({
				props: { type: 'indicator' },
				$$inline: true
			});

		const block = {
			c: function create() {
				button = element("button");
				t = text("Permissions ");
				span = element("span");
				create_component(downarrow.$$.fragment);
				attr_dev(span, "class", "rotate-180");
				add_location(span, file$R, 35, 16, 1523);
				attr_dev(button, "class", "text-osvauld-permissionGreenText bg-osvauld-permissionsGreen w-full rounded-md cursor-pointer px-2 py-0.5 flex justify-around items-center");
				add_location(button, file$R, 32, 2, 1278);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				append_dev(button, t);
				append_dev(button, span);
				mount_component(downarrow, span, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", stop_propagation(/*click_handler_3*/ ctx[6]), false, false, true, false);
					mounted = true;
				}
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(downarrow.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(downarrow.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(downarrow);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$D.name,
			type: "if",
			source: "(30:1) {#if reverseModal}",
			ctx
		});

		return block;
	}

	function create_fragment$R(ctx) {
		let div;
		let t0;
		let button0;
		let t2;
		let button1;
		let t4;
		let div_class_value;
		let current;
		let mounted;
		let dispose;
		let if_block0 = !/*reverseModal*/ ctx[0] && create_if_block_1$s(ctx);
		let if_block1 = /*reverseModal*/ ctx[0] && create_if_block$D(ctx);

		const block = {
			c: function create() {
				div = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				button0 = element("button");
				button0.textContent = "Reader";
				t2 = space();
				button1 = element("button");
				button1.textContent = "Manager";
				t4 = space();
				if (if_block1) if_block1.c();
				attr_dev(button0, "class", "w-full rounded-md cursor-pointer px-2 py-0.5 bg-osvauld-readerOrange text-osvauld-readerText mt-0.5");
				add_location(button0, file$R, 23, 1, 871);
				attr_dev(button1, "class", "w-full rounded-md cursor-pointer px-2 py-0.5 bg-osvauld-managerPurple text-osvauld-managerText my-0.5");
				add_location(button1, file$R, 27, 1, 1062);

				attr_dev(div, "class", div_class_value = "absolute " + (/*reverseModal*/ ctx[0]
				? '-top-[60px] right-0'
				: 'top-0 right-0') + " !z-[100] w-[10rem] px-0.5 py-0 rounded-md bg-osvauld-frameblack border-[0.5px] border-osvauld-iconblack ml-auto text-base font-normal flex flex-col justify-center items-center");

				add_location(div, file$R, 11, 0, 266);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append_dev(div, t0);
				append_dev(div, button0);
				append_dev(div, t2);
				append_dev(div, button1);
				append_dev(div, t4);
				if (if_block1) if_block1.m(div, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*click_handler_1*/ ctx[4]), false, false, true, false),
						listen_dev(button1, "click", stop_propagation(/*click_handler_2*/ ctx[5]), false, false, true, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (!/*reverseModal*/ ctx[0]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*reverseModal*/ 1) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$s(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*reverseModal*/ ctx[0]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*reverseModal*/ 1) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$D(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*reverseModal*/ 1 && div_class_value !== (div_class_value = "absolute " + (/*reverseModal*/ ctx[0]
				? '-top-[60px] right-0'
				: 'top-0 right-0') + " !z-[100] w-[10rem] px-0.5 py-0 rounded-md bg-osvauld-frameblack border-[0.5px] border-osvauld-iconblack ml-auto text-base font-normal flex flex-col justify-center items-center")) {
					attr_dev(div, "class", div_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$R.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$R($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('AccessSelector', slots, []);
		let { reverseModal = false } = $$props;
		const dispatch = createEventDispatcher();

		const select = permission => {
			dispatch("select", { permission });
		};

		const writable_props = ['reverseModal'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AccessSelector> was created with unknown prop '${key}'`);
		});

		const click_handler = () => dispatch('closeSelector', true);
		const click_handler_1 = () => select('reader');
		const click_handler_2 = () => select('manager');
		const click_handler_3 = () => dispatch('closeSelector', true);

		$$self.$$set = $$props => {
			if ('reverseModal' in $$props) $$invalidate(0, reverseModal = $$props.reverseModal);
		};

		$$self.$capture_state = () => ({
			DownArrow,
			createEventDispatcher,
			reverseModal,
			dispatch,
			select
		});

		$$self.$inject_state = $$props => {
			if ('reverseModal' in $$props) $$invalidate(0, reverseModal = $$props.reverseModal);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			reverseModal,
			dispatch,
			select,
			click_handler,
			click_handler_1,
			click_handler_2,
			click_handler_3
		];
	}

	class AccessSelector extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$R, create_fragment$R, safe_not_equal, { reverseModal: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "AccessSelector",
				options,
				id: create_fragment$R.name
			});
		}

		get reverseModal() {
			throw new Error("<AccessSelector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set reverseModal(value) {
			throw new Error("<AccessSelector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/components/ListItem.svelte generated by Svelte v4.2.19 */
	const file$Q = "src/lib/components/dashboard/components/ListItem.svelte";

	// (46:1) {#if isBottomList}
	function create_if_block_2$j(ctx) {
		let div;
		let button0;
		let binicon;
		let t0;
		let button1;
		let t1_value = /*item*/ ctx[0].accessType + "";
		let t1;
		let t2;
		let span;
		let downarrow;
		let button1_class_value;
		let t3;
		let current;
		let mounted;
		let dispose;

		binicon = new BinIcon({
				props: { color: '#67697C' },
				$$inline: true
			});

		downarrow = new DownArrow({
				props: { type: /*item*/ ctx[0].accessType },
				$$inline: true
			});

		let if_block = /*showOptions*/ ctx[3] && /*isSelected*/ ctx[1] && create_if_block_3$d(ctx);

		const block = {
			c: function create() {
				div = element("div");
				button0 = element("button");
				create_component(binicon.$$.fragment);
				t0 = space();
				button1 = element("button");
				t1 = text(t1_value);
				t2 = space();
				span = element("span");
				create_component(downarrow.$$.fragment);
				t3 = space();
				if (if_block) if_block.c();
				attr_dev(button0, "class", "mr-3");
				add_location(button0, file$Q, 55, 3, 1546);
				add_location(span, file$Q, 63, 4, 1906);

				attr_dev(button1, "class", button1_class_value = "w-[9.8rem] rounded-md font-normal cursor-pointer px-2 py-0.5 pl-2 text-base flex justify-around items-center " + setbackground(/*item*/ ctx[0].accessType === undefined
				? 'reader'
				: /*item*/ ctx[0].accessType));

				add_location(button1, file$Q, 58, 3, 1662);
				attr_dev(div, "class", "flex justify-center items-center");
				add_location(div, file$Q, 54, 2, 1496);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, button0);
				mount_component(binicon, button0, null);
				append_dev(div, t0);
				append_dev(div, button1);
				append_dev(button1, t1);
				append_dev(button1, t2);
				append_dev(button1, span);
				mount_component(downarrow, span, null);
				append_dev(div, t3);
				if (if_block) if_block.m(div, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button0, "click", stop_propagation(/*handleRemove*/ ctx[6]), false, false, true, false);
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if ((!current || dirty & /*item*/ 1) && t1_value !== (t1_value = /*item*/ ctx[0].accessType + "")) set_data_dev(t1, t1_value);
				const downarrow_changes = {};
				if (dirty & /*item*/ 1) downarrow_changes.type = /*item*/ ctx[0].accessType;
				downarrow.$set(downarrow_changes);

				if (!current || dirty & /*item*/ 1 && button1_class_value !== (button1_class_value = "w-[9.8rem] rounded-md font-normal cursor-pointer px-2 py-0.5 pl-2 text-base flex justify-around items-center " + setbackground(/*item*/ ctx[0].accessType === undefined
				? 'reader'
				: /*item*/ ctx[0].accessType))) {
					attr_dev(button1, "class", button1_class_value);
				}

				if (/*showOptions*/ ctx[3] && /*isSelected*/ ctx[1]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*showOptions, isSelected*/ 10) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_3$d(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(div, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(binicon.$$.fragment, local);
				transition_in(downarrow.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(binicon.$$.fragment, local);
				transition_out(downarrow.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(binicon);
				destroy_component(downarrow);
				if (if_block) if_block.d();
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$j.name,
			type: "if",
			source: "(46:1) {#if isBottomList}",
			ctx
		});

		return block;
	}

	// (58:3) {#if showOptions && isSelected}
	function create_if_block_3$d(ctx) {
		let accessselector;
		let current;

		accessselector = new AccessSelector({
				props: { reverseModal: /*reverseModal*/ ctx[4] },
				$$inline: true
			});

		accessselector.$on("select", /*select_handler*/ ctx[9]);

		const block = {
			c: function create() {
				create_component(accessselector.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(accessselector, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const accessselector_changes = {};
				if (dirty & /*reverseModal*/ 16) accessselector_changes.reverseModal = /*reverseModal*/ ctx[4];
				accessselector.$set(accessselector_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(accessselector.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(accessselector.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(accessselector, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$d.name,
			type: "if",
			source: "(58:3) {#if showOptions && isSelected}",
			ctx
		});

		return block;
	}

	// (63:1) {#if !isBottomList && showOptions && isSelected}
	function create_if_block_1$r(ctx) {
		let accessselector;
		let current;

		accessselector = new AccessSelector({
				props: { reverseModal: /*reverseModal*/ ctx[4] },
				$$inline: true
			});

		accessselector.$on("select", /*select_handler_1*/ ctx[10]);

		const block = {
			c: function create() {
				create_component(accessselector.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(accessselector, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const accessselector_changes = {};
				if (dirty & /*reverseModal*/ 16) accessselector_changes.reverseModal = /*reverseModal*/ ctx[4];
				accessselector.$set(accessselector_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(accessselector.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(accessselector.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(accessselector, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$r.name,
			type: "if",
			source: "(63:1) {#if !isBottomList && showOptions && isSelected}",
			ctx
		});

		return block;
	}

	// (66:1) {#if !isBottomList && hoveredOverThisItem}
	function create_if_block$C(ctx) {
		let span1;
		let t;
		let span0;
		let downarrow;
		let current;

		downarrow = new DownArrow({
				props: { type: 'indicator' },
				$$inline: true
			});

		const block = {
			c: function create() {
				span1 = element("span");
				t = text("Permissions ");
				span0 = element("span");
				create_component(downarrow.$$.fragment);
				attr_dev(span0, "class", "-rotate-90");
				add_location(span0, file$Q, 76, 16, 2479);
				attr_dev(span1, "class", "cursor-pointer text-osvauld-permissionGreenText bg-osvauld-permissionsGreen rounded-md px-1 py-0.5 w-[9.8rem] flex justify-around items-center text-base font-normal");
				add_location(span1, file$Q, 74, 2, 2281);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span1, anchor);
				append_dev(span1, t);
				append_dev(span1, span0);
				mount_component(downarrow, span0, null);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(downarrow.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(downarrow.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span1);
				}

				destroy_component(downarrow);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$C.name,
			type: "if",
			source: "(66:1) {#if !isBottomList && hoveredOverThisItem}",
			ctx
		});

		return block;
	}

	function create_fragment$Q(ctx) {
		let button;
		let div;
		let p;
		let t0_value = /*item*/ ctx[0].name + "";
		let t0;
		let p_class_value;
		let t1;
		let t2;
		let t3;
		let button_class_value;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*isBottomList*/ ctx[2] && create_if_block_2$j(ctx);
		let if_block1 = !/*isBottomList*/ ctx[2] && /*showOptions*/ ctx[3] && /*isSelected*/ ctx[1] && create_if_block_1$r(ctx);
		let if_block2 = !/*isBottomList*/ ctx[2] && /*hoveredOverThisItem*/ ctx[5] && create_if_block$C(ctx);

		const block = {
			c: function create() {
				button = element("button");
				div = element("div");
				p = element("p");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				if (if_block1) if_block1.c();
				t3 = space();
				if (if_block2) if_block2.c();

				attr_dev(p, "class", p_class_value = "py-1 px-1 w-[15rem] overflow-hidden whitespace-nowrap text-base flex justify-start " + (/*isBottomList*/ ctx[2] || /*hoveredOverThisItem*/ ctx[5]
				? 'text-osvauld-textActive'
				: 'text-osvauld-sheffieldgrey'));

				add_location(p, file$Q, 44, 2, 1235);
				attr_dev(div, "class", "flex items-center space-x-4 max-w-full");
				add_location(div, file$Q, 43, 1, 1180);

				attr_dev(button, "class", button_class_value = "relative w-[98%] my-1 ml-1 pl-2 pr-0.5 rounded-lg cursor-pointer flex items-center justify-between text-osvauld-sheffieldgrey text-base font-normal " + (/*isSelected*/ ctx[1] && !/*isBottomList*/ ctx[2] || /*hoveredOverThisItem*/ ctx[5] && !/*isBottomList*/ ctx[2]
				? 'shadow-[0_0_0_1px_#292A36] '
				: '') + (/*showOptions*/ ctx[3] && /*isSelected*/ ctx[1]
				? 'bg-osvauld-cardshade text-osvauld-textActive'
				: ''));

				add_location(button, file$Q, 31, 0, 674);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				append_dev(button, div);
				append_dev(div, p);
				append_dev(p, t0);
				append_dev(button, t1);
				if (if_block0) if_block0.m(button, null);
				append_dev(button, t2);
				if (if_block1) if_block1.m(button, null);
				append_dev(button, t3);
				if (if_block2) if_block2.m(button, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "click", /*handleClick*/ ctx[8], false, false, false, false),
						listen_dev(button, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false, false),
						listen_dev(button, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if ((!current || dirty & /*item*/ 1) && t0_value !== (t0_value = /*item*/ ctx[0].name + "")) set_data_dev(t0, t0_value);

				if (!current || dirty & /*isBottomList, hoveredOverThisItem*/ 36 && p_class_value !== (p_class_value = "py-1 px-1 w-[15rem] overflow-hidden whitespace-nowrap text-base flex justify-start " + (/*isBottomList*/ ctx[2] || /*hoveredOverThisItem*/ ctx[5]
				? 'text-osvauld-textActive'
				: 'text-osvauld-sheffieldgrey'))) {
					attr_dev(p, "class", p_class_value);
				}

				if (/*isBottomList*/ ctx[2]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*isBottomList*/ 4) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_2$j(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(button, t2);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (!/*isBottomList*/ ctx[2] && /*showOptions*/ ctx[3] && /*isSelected*/ ctx[1]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*isBottomList, showOptions, isSelected*/ 14) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_1$r(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(button, t3);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!/*isBottomList*/ ctx[2] && /*hoveredOverThisItem*/ ctx[5]) {
					if (if_block2) {
						if (dirty & /*isBottomList, hoveredOverThisItem*/ 36) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block$C(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(button, null);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*isSelected, isBottomList, hoveredOverThisItem, showOptions*/ 46 && button_class_value !== (button_class_value = "relative w-[98%] my-1 ml-1 pl-2 pr-0.5 rounded-lg cursor-pointer flex items-center justify-between text-osvauld-sheffieldgrey text-base font-normal " + (/*isSelected*/ ctx[1] && !/*isBottomList*/ ctx[2] || /*hoveredOverThisItem*/ ctx[5] && !/*isBottomList*/ ctx[2]
				? 'shadow-[0_0_0_1px_#292A36] '
				: '') + (/*showOptions*/ ctx[3] && /*isSelected*/ ctx[1]
				? 'bg-osvauld-cardshade text-osvauld-textActive'
				: ''))) {
					attr_dev(button, "class", button_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if (if_block2) if_block2.d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$Q.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$Q($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ListItem', slots, []);
		let { item } = $$props;
		let { isSelected } = $$props;
		let { isBottomList = false } = $$props;
		let { showOptions } = $$props;
		let { reverseModal = false } = $$props;
		let hoveredOverThisItem = false;
		const dispatch = createEventDispatcher();

		const handleRemove = () => {
			dispatch("remove", item);
		};

		const eventPasser = e => {
			$$invalidate(5, hoveredOverThisItem = false);
			dispatch("select", { item, permission: e.detail.permission });
		};

		const handleClick = () => {
			dispatch("click");
		};

		$$self.$$.on_mount.push(function () {
			if (item === undefined && !('item' in $$props || $$self.$$.bound[$$self.$$.props['item']])) {
				console.warn("<ListItem> was created without expected prop 'item'");
			}

			if (isSelected === undefined && !('isSelected' in $$props || $$self.$$.bound[$$self.$$.props['isSelected']])) {
				console.warn("<ListItem> was created without expected prop 'isSelected'");
			}

			if (showOptions === undefined && !('showOptions' in $$props || $$self.$$.bound[$$self.$$.props['showOptions']])) {
				console.warn("<ListItem> was created without expected prop 'showOptions'");
			}
		});

		const writable_props = ['item', 'isSelected', 'isBottomList', 'showOptions', 'reverseModal'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ListItem> was created with unknown prop '${key}'`);
		});

		const select_handler = e => eventPasser(e);
		const select_handler_1 = e => eventPasser(e);
		const mouseenter_handler = () => $$invalidate(5, hoveredOverThisItem = true);
		const mouseleave_handler = () => $$invalidate(5, hoveredOverThisItem = false);

		$$self.$$set = $$props => {
			if ('item' in $$props) $$invalidate(0, item = $$props.item);
			if ('isSelected' in $$props) $$invalidate(1, isSelected = $$props.isSelected);
			if ('isBottomList' in $$props) $$invalidate(2, isBottomList = $$props.isBottomList);
			if ('showOptions' in $$props) $$invalidate(3, showOptions = $$props.showOptions);
			if ('reverseModal' in $$props) $$invalidate(4, reverseModal = $$props.reverseModal);
		};

		$$self.$capture_state = () => ({
			setbackground,
			item,
			isSelected,
			isBottomList,
			showOptions,
			reverseModal,
			hoveredOverThisItem,
			BinIcon,
			DownArrow,
			AccessSelector,
			createEventDispatcher,
			dispatch,
			handleRemove,
			eventPasser,
			handleClick
		});

		$$self.$inject_state = $$props => {
			if ('item' in $$props) $$invalidate(0, item = $$props.item);
			if ('isSelected' in $$props) $$invalidate(1, isSelected = $$props.isSelected);
			if ('isBottomList' in $$props) $$invalidate(2, isBottomList = $$props.isBottomList);
			if ('showOptions' in $$props) $$invalidate(3, showOptions = $$props.showOptions);
			if ('reverseModal' in $$props) $$invalidate(4, reverseModal = $$props.reverseModal);
			if ('hoveredOverThisItem' in $$props) $$invalidate(5, hoveredOverThisItem = $$props.hoveredOverThisItem);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			item,
			isSelected,
			isBottomList,
			showOptions,
			reverseModal,
			hoveredOverThisItem,
			handleRemove,
			eventPasser,
			handleClick,
			select_handler,
			select_handler_1,
			mouseenter_handler,
			mouseleave_handler
		];
	}

	class ListItem extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {
				item: 0,
				isSelected: 1,
				isBottomList: 2,
				showOptions: 3,
				reverseModal: 4
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ListItem",
				options,
				id: create_fragment$Q.name
			});
		}

		get item() {
			throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set item(value) {
			throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isSelected() {
			throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isSelected(value) {
			throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isBottomList() {
			throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isBottomList(value) {
			throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get showOptions() {
			throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set showOptions(value) {
			throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get reverseModal() {
			throw new Error("<ListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set reverseModal(value) {
			throw new Error("<ListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/folders/ShareFolderWithGroups.svelte generated by Svelte v4.2.19 */

	const { Error: Error_1$7 } = globals;
	const file$P = "src/lib/components/dashboard/folders/ShareFolderWithGroups.svelte";

	function get_each_context$j(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[21] = list[i][0];
		child_ctx[22] = list[i][1];
		child_ctx[24] = i;
		return child_ctx;
	}

	function get_each_context_1$6(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[22] = list[i];
		child_ctx[24] = i;
		return child_ctx;
	}

	// (118:2) {#each filteredGroups as group, index}
	function create_each_block_1$6(ctx) {
		let listitem;
		let current;

		function click_handler() {
			return /*click_handler*/ ctx[14](/*index*/ ctx[24]);
		}

		function select_handler(...args) {
			return /*select_handler*/ ctx[15](/*index*/ ctx[24], ...args);
		}

		listitem = new ListItem({
				props: {
					item: /*group*/ ctx[22],
					isSelected: /*index*/ ctx[24] === /*selectionIndex*/ ctx[3] && !/*topList*/ ctx[4],
					showOptions: /*showOptions*/ ctx[2],
					reverseModal: /*filteredGroups*/ ctx[5].length > 4 && /*index*/ ctx[24] > /*filteredGroups*/ ctx[5].length - 3
				},
				$$inline: true
			});

		listitem.$on("click", click_handler);
		listitem.$on("select", select_handler);

		const block = {
			c: function create() {
				create_component(listitem.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(listitem, target, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const listitem_changes = {};
				if (dirty & /*filteredGroups*/ 32) listitem_changes.item = /*group*/ ctx[22];
				if (dirty & /*selectionIndex, topList*/ 24) listitem_changes.isSelected = /*index*/ ctx[24] === /*selectionIndex*/ ctx[3] && !/*topList*/ ctx[4];
				if (dirty & /*showOptions*/ 4) listitem_changes.showOptions = /*showOptions*/ ctx[2];
				if (dirty & /*filteredGroups*/ 32) listitem_changes.reverseModal = /*filteredGroups*/ ctx[5].length > 4 && /*index*/ ctx[24] > /*filteredGroups*/ ctx[5].length - 3;
				listitem.$set(listitem_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(listitem.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(listitem.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(listitem, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block_1$6.name,
			type: "each",
			source: "(118:2) {#each filteredGroups as group, index}",
			ctx
		});

		return block;
	}

	// (132:0) {#if $selectedGroups.size !== 0}
	function create_if_block$B(ctx) {
		let div1;
		let div0;
		let current;
		let each_value = ensure_array_like_dev(Array.from(/*$selectedGroups*/ ctx[1]));
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div1 = element("div");
				div0 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(div0, "class", "overflow-y-scroll h-[90%] scrollbar-thin rounded-lg w-full px-2 mt-1");
				add_location(div0, file$P, 156, 2, 4716);
				attr_dev(div1, "class", "my-2 w-full border border-osvauld-iconblack rounded-lg h-[8rem] mb-2");
				add_location(div1, file$P, 153, 1, 4627);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, div0);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div0, null);
					}
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty & /*Array, $selectedGroups, selectionIndex, topList, showOptions, handleClick, handleItemRemove, handleRoleChange*/ 926) {
					each_value = ensure_array_like_dev(Array.from(/*$selectedGroups*/ ctx[1]));
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$j(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$j(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div0, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$B.name,
			type: "if",
			source: "(132:0) {#if $selectedGroups.size !== 0}",
			ctx
		});

		return block;
	}

	// (139:3) {#each Array.from($selectedGroups) as [groupId, group], index}
	function create_each_block$j(ctx) {
		let listitem;
		let t;
		let div;
		let current;

		function click_handler_1() {
			return /*click_handler_1*/ ctx[16](/*index*/ ctx[24]);
		}

		function remove_handler() {
			return /*remove_handler*/ ctx[17](/*groupId*/ ctx[21]);
		}

		function select_handler_1(...args) {
			return /*select_handler_1*/ ctx[18](/*index*/ ctx[24], ...args);
		}

		listitem = new ListItem({
				props: {
					item: /*group*/ ctx[22],
					isSelected: /*index*/ ctx[24] === /*selectionIndex*/ ctx[3] && /*topList*/ ctx[4],
					isBottomList: true,
					showOptions: /*showOptions*/ ctx[2],
					reverseModal: /*$selectedGroups*/ ctx[1].size > 1 && /*index*/ ctx[24] > 1
				},
				$$inline: true
			});

		listitem.$on("click", click_handler_1);
		listitem.$on("remove", remove_handler);
		listitem.$on("select", select_handler_1);

		const block = {
			c: function create() {
				create_component(listitem.$$.fragment);
				t = space();
				div = element("div");
				attr_dev(div, "class", "border-b border-osvauld-iconblack w-full");
				add_location(div, file$P, 170, 4, 5249);
			},
			m: function mount(target, anchor) {
				mount_component(listitem, target, anchor);
				insert_dev(target, t, anchor);
				insert_dev(target, div, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const listitem_changes = {};
				if (dirty & /*$selectedGroups*/ 2) listitem_changes.item = /*group*/ ctx[22];
				if (dirty & /*selectionIndex, topList*/ 24) listitem_changes.isSelected = /*index*/ ctx[24] === /*selectionIndex*/ ctx[3] && /*topList*/ ctx[4];
				if (dirty & /*showOptions*/ 4) listitem_changes.showOptions = /*showOptions*/ ctx[2];
				if (dirty & /*$selectedGroups*/ 2) listitem_changes.reverseModal = /*$selectedGroups*/ ctx[1].size > 1 && /*index*/ ctx[24] > 1;
				listitem.$set(listitem_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(listitem.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(listitem.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
					detach_dev(div);
				}

				destroy_component(listitem, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$j.name,
			type: "each",
			source: "(139:3) {#each Array.from($selectedGroups) as [groupId, group], index}",
			ctx
		});

		return block;
	}

	function create_fragment$P(ctx) {
		let div3;
		let div1;
		let div0;
		let lens;
		let t0;
		let input;
		let t1;
		let div2;
		let t2;
		let if_block_anchor;
		let current;
		let mounted;
		let dispose;
		lens = new Lens({ $$inline: true });
		let each_value_1 = ensure_array_like_dev(/*filteredGroups*/ ctx[5]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let if_block = /*$selectedGroups*/ ctx[1].size !== 0 && create_if_block$B(ctx);

		const block = {
			c: function create() {
				div3 = element("div");
				div1 = element("div");
				div0 = element("div");
				create_component(lens.$$.fragment);
				t0 = space();
				input = element("input");
				t1 = space();
				div2 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t2 = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
				attr_dev(input, "type", "text");
				attr_dev(input, "class", "h-[1.60rem] w-full bg-osvauld-frameblack border-0 text-osvauld-quarzowhite placeholder-osvauld-placeholderblack border-transparent text-base focus:border-transparent focus:ring-0 cursor-pointer");
				attr_dev(input, "placeholder", "");
				add_location(input, file$P, 126, 3, 3762);
				attr_dev(div0, "class", "h-[1.875rem] w-full px-2 mx-auto flex justify-start items-center border border-osvauld-iconblack rounded-lg cursor-pointer");
				add_location(div0, file$P, 122, 2, 3604);
				attr_dev(div1, "class", "bg-osvauld-frameblack flex justify-center items-center");
				add_location(div1, file$P, 121, 1, 3533);
				attr_dev(div2, "class", "overflow-y-scroll scrollbar-thin bg-osvauld-frameblack w-full max-h-[15rem] min-h-[8rem] flex flex-col justify-start items-center");
				add_location(div2, file$P, 135, 1, 4066);
				attr_dev(div3, "class", "p-2 w-full max-h-full rounded-lg overflow-hidden");
				add_location(div3, file$P, 120, 0, 3469);
			},
			l: function claim(nodes) {
				throw new Error_1$7("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div3, anchor);
				append_dev(div3, div1);
				append_dev(div1, div0);
				mount_component(lens, div0, null);
				append_dev(div0, t0);
				append_dev(div0, input);
				set_input_value(input, /*searchInput*/ ctx[0]);
				append_dev(div3, t1);
				append_dev(div3, div2);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div2, null);
					}
				}

				insert_dev(target, t2, anchor);
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;

				if (!mounted) {
					dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[13]);
					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*searchInput*/ 1 && input.value !== /*searchInput*/ ctx[0]) {
					set_input_value(input, /*searchInput*/ ctx[0]);
				}

				if (dirty & /*filteredGroups, selectionIndex, topList, showOptions, handleClick, handleRoleChange*/ 700) {
					each_value_1 = ensure_array_like_dev(/*filteredGroups*/ ctx[5]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$6(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1$6(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div2, null);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (/*$selectedGroups*/ ctx[1].size !== 0) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*$selectedGroups*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$B(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(lens.$$.fragment, local);

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(lens.$$.fragment, local);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div3);
					detach_dev(t2);
					detach_dev(if_block_anchor);
				}

				destroy_component(lens);
				destroy_each(each_blocks, detaching);
				if (if_block) if_block.d(detaching);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$P.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$P($$self, $$props, $$invalidate) {
		let filteredGroups;
		let $selectedFolder;
		let $selectedGroups;
		validate_store(selectedFolder, 'selectedFolder');
		component_subscribe($$self, selectedFolder, $$value => $$invalidate(19, $selectedFolder = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ShareFolderWithGroups', slots, []);
		const dispatch = createEventDispatcher();
		let groups = [];
		let { credentialsFields } = $$props;
		let selectedGroups = writable(new Map());
		validate_store(selectedGroups, 'selectedGroups');
		component_subscribe($$self, selectedGroups, value => $$invalidate(1, $selectedGroups = value));
		let showOptions = false;
		let selectionIndex = null;
		let topList = false;
		let searchInput = "";

		const shareFolderHandler = async () => {
			const groupIds = Array.from($selectedGroups.keys());
			const response = await fetchUsersByGroupIds(groupIds);
			const groupUsersList = response.data;
			if ($selectedFolder === undefined) throw new Error("Folder not selected");

			const payload = {
				folderId: $selectedFolder.id,
				groupData: []
			};

			for (const groupUsers of groupUsersList) {
				const group = $selectedGroups.get(groupUsers.groupId);
				if (group === undefined || !group.accessType) continue;

				const userData = await sendMessage("createShareCredPayload", {
					creds: credentialsFields,
					users: groupUsers.userDetails
				});

				payload.groupData.push({
					groupId: group.groupId,
					accessType: group.accessType,
					userData
				});
			}

			const shareStatus = await shareFolderWithGroups(payload);

			toastStore.set({
				type: shareStatus.success,
				message: "Successfully shared",
				show: true
			});

			dispatch("cancel", true);
		};

		function handleClick(index, isSelectedList) {
			$$invalidate(2, showOptions = !showOptions);
			$$invalidate(3, selectionIndex = index);
			$$invalidate(4, topList = isSelectedList);
		}

		function handleItemRemove(id) {
			let removedGroup;

			selectedGroups.update(currentGroups => {
				removedGroup = currentGroups.get(id);
				currentGroups.delete(id);
				return currentGroups;
			});

			if (removedGroup) {
				$$invalidate(12, groups = [...groups, { ...removedGroup }]);
			}
		}

		function handleRoleChange(e, index, type) {
			const item = e.detail.item;
			const option = e.detail.permission;
			$$invalidate(2, showOptions = !showOptions);
			$$invalidate(3, selectionIndex = null);

			if (type === "selectedGroups") {
				selectedGroups.update(currentGroups => {
					currentGroups.set(item.groupId, { ...item, accessType: option });
					return currentGroups;
				});
			} else {
				$selectedGroups.set(item.groupId, { ...item, accessType: option });
				$$invalidate(12, groups = groups.filter(u => u.groupId !== item.groupId));
			}

			$selectedGroups.size !== 0 && dispatch("enable", true);
		}

		onMount(async () => {
			// TODO: change fetch all groups to fetch groups where folder not shared.
			if ($selectedFolder === undefined) throw new Error("Folder not selected");

			//Below will disable save changes button when group/user button switched
			dispatch("enable", false);

			const responseJson = await fetchGroupsWithoutAccess($selectedFolder.id);
			$$invalidate(12, groups = responseJson.data);
		});

		$$self.$$.on_mount.push(function () {
			if (credentialsFields === undefined && !('credentialsFields' in $$props || $$self.$$.bound[$$self.$$.props['credentialsFields']])) {
				console.warn("<ShareFolderWithGroups> was created without expected prop 'credentialsFields'");
			}
		});

		const writable_props = ['credentialsFields'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ShareFolderWithGroups> was created with unknown prop '${key}'`);
		});

		function input_input_handler() {
			searchInput = this.value;
			$$invalidate(0, searchInput);
		}

		const click_handler = index => handleClick(index, false);
		const select_handler = (index, e) => handleRoleChange(e, index, 'groups');
		const click_handler_1 = index => handleClick(index, true);
		const remove_handler = groupId => handleItemRemove(groupId);
		const select_handler_1 = (index, e) => handleRoleChange(e, index, 'selectedGroups');

		$$self.$$set = $$props => {
			if ('credentialsFields' in $$props) $$invalidate(10, credentialsFields = $$props.credentialsFields);
		};

		$$self.$capture_state = () => ({
			fetchUsersByGroupIds,
			shareFolderWithGroups,
			fetchGroupsWithoutAccess,
			createEventDispatcher,
			sendMessage,
			writable,
			selectedFolder,
			toastStore,
			onMount,
			Lens,
			ListItem,
			dispatch,
			groups,
			credentialsFields,
			selectedGroups,
			showOptions,
			selectionIndex,
			topList,
			searchInput,
			shareFolderHandler,
			handleClick,
			handleItemRemove,
			handleRoleChange,
			filteredGroups,
			$selectedFolder,
			$selectedGroups
		});

		$$self.$inject_state = $$props => {
			if ('groups' in $$props) $$invalidate(12, groups = $$props.groups);
			if ('credentialsFields' in $$props) $$invalidate(10, credentialsFields = $$props.credentialsFields);
			if ('selectedGroups' in $$props) $$invalidate(6, selectedGroups = $$props.selectedGroups);
			if ('showOptions' in $$props) $$invalidate(2, showOptions = $$props.showOptions);
			if ('selectionIndex' in $$props) $$invalidate(3, selectionIndex = $$props.selectionIndex);
			if ('topList' in $$props) $$invalidate(4, topList = $$props.topList);
			if ('searchInput' in $$props) $$invalidate(0, searchInput = $$props.searchInput);
			if ('filteredGroups' in $$props) $$invalidate(5, filteredGroups = $$props.filteredGroups);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$selectedGroups*/ 2) {
				$selectedGroups.size === 0 && dispatch("enable", false);
			}

			if ($$self.$$.dirty & /*searchInput, groups*/ 4097) {
				$$invalidate(5, filteredGroups = searchInput
				? groups.filter(group => group.name.toLowerCase().includes(searchInput.toLowerCase()))
				: groups);
			}
		};

		return [
			searchInput,
			$selectedGroups,
			showOptions,
			selectionIndex,
			topList,
			filteredGroups,
			selectedGroups,
			handleClick,
			handleItemRemove,
			handleRoleChange,
			credentialsFields,
			shareFolderHandler,
			groups,
			input_input_handler,
			click_handler,
			select_handler,
			click_handler_1,
			remove_handler,
			select_handler_1
		];
	}

	class ShareFolderWithGroups extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$P, create_fragment$P, safe_not_equal, {
				credentialsFields: 10,
				shareFolderHandler: 11
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ShareFolderWithGroups",
				options,
				id: create_fragment$P.name
			});
		}

		get credentialsFields() {
			throw new Error_1$7("<ShareFolderWithGroups>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set credentialsFields(value) {
			throw new Error_1$7("<ShareFolderWithGroups>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get shareFolderHandler() {
			return this.$$.ctx[11];
		}

		set shareFolderHandler(value) {
			throw new Error_1$7("<ShareFolderWithGroups>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/folders/ShareFolderWithUsers.svelte generated by Svelte v4.2.19 */

	const { Error: Error_1$6 } = globals;
	const file$O = "src/lib/components/dashboard/folders/ShareFolderWithUsers.svelte";

	function get_each_context$i(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[20] = list[i];
		child_ctx[22] = i;
		return child_ctx;
	}

	function get_each_context_1$5(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[20] = list[i];
		child_ctx[22] = i;
		return child_ctx;
	}

	// (92:2) {#each filteredUsers as user, index}
	function create_each_block_1$5(ctx) {
		let listitem;
		let current;

		function click_handler() {
			return /*click_handler*/ ctx[13](/*index*/ ctx[22]);
		}

		function select_handler(...args) {
			return /*select_handler*/ ctx[14](/*index*/ ctx[22], ...args);
		}

		listitem = new ListItem({
				props: {
					item: /*user*/ ctx[20],
					isSelected: /*index*/ ctx[22] === /*selectionIndex*/ ctx[3] && !/*topList*/ ctx[4],
					showOptions: /*showOptions*/ ctx[2],
					reverseModal: /*filteredUsers*/ ctx[5].length > 3 && /*index*/ ctx[22] > /*filteredUsers*/ ctx[5].length - 3
				},
				$$inline: true
			});

		listitem.$on("click", click_handler);
		listitem.$on("select", select_handler);

		const block = {
			c: function create() {
				create_component(listitem.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(listitem, target, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const listitem_changes = {};
				if (dirty & /*filteredUsers*/ 32) listitem_changes.item = /*user*/ ctx[20];
				if (dirty & /*selectionIndex, topList*/ 24) listitem_changes.isSelected = /*index*/ ctx[22] === /*selectionIndex*/ ctx[3] && !/*topList*/ ctx[4];
				if (dirty & /*showOptions*/ 4) listitem_changes.showOptions = /*showOptions*/ ctx[2];
				if (dirty & /*filteredUsers*/ 32) listitem_changes.reverseModal = /*filteredUsers*/ ctx[5].length > 3 && /*index*/ ctx[22] > /*filteredUsers*/ ctx[5].length - 3;
				listitem.$set(listitem_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(listitem.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(listitem.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(listitem, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block_1$5.name,
			type: "each",
			source: "(92:2) {#each filteredUsers as user, index}",
			ctx
		});

		return block;
	}

	// (106:0) {#if selectedUsers.length !== 0}
	function create_if_block$A(ctx) {
		let div1;
		let div0;
		let current;
		let each_value = ensure_array_like_dev(/*selectedUsers*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$i(get_each_context$i(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div1 = element("div");
				div0 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(div0, "class", "overflow-y-scroll h-[90%] scrollbar-thin rounded-lg w-full px-2 mt-1");
				add_location(div0, file$O, 125, 2, 3660);
				attr_dev(div1, "class", "my-2 w-full border border-osvauld-iconblack rounded-lg h-[8rem] mb-2");
				add_location(div1, file$O, 122, 1, 3571);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, div0);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div0, null);
					}
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty & /*selectedUsers, selectionIndex, topList, showOptions, handleClick, handleItemRemove, handleRoleChange*/ 477) {
					each_value = ensure_array_like_dev(/*selectedUsers*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$i(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$i(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div0, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$A.name,
			type: "if",
			source: "(106:0) {#if selectedUsers.length !== 0}",
			ctx
		});

		return block;
	}

	// (113:3) {#each selectedUsers as user, index}
	function create_each_block$i(ctx) {
		let listitem;
		let t;
		let div;
		let current;

		function click_handler_1() {
			return /*click_handler_1*/ ctx[15](/*index*/ ctx[22]);
		}

		function remove_handler() {
			return /*remove_handler*/ ctx[16](/*index*/ ctx[22]);
		}

		function select_handler_1(...args) {
			return /*select_handler_1*/ ctx[17](/*index*/ ctx[22], ...args);
		}

		listitem = new ListItem({
				props: {
					item: /*user*/ ctx[20],
					isSelected: /*index*/ ctx[22] === /*selectionIndex*/ ctx[3] && /*topList*/ ctx[4],
					isBottomList: true,
					showOptions: /*showOptions*/ ctx[2],
					reverseModal: /*selectedUsers*/ ctx[0].length > 3 && /*index*/ ctx[22] > /*selectedUsers*/ ctx[0].length - 3
				},
				$$inline: true
			});

		listitem.$on("click", click_handler_1);
		listitem.$on("remove", remove_handler);
		listitem.$on("select", select_handler_1);

		const block = {
			c: function create() {
				create_component(listitem.$$.fragment);
				t = space();
				div = element("div");
				attr_dev(div, "class", "border-b border-osvauld-iconblack w-full");
				add_location(div, file$O, 140, 4, 4192);
			},
			m: function mount(target, anchor) {
				mount_component(listitem, target, anchor);
				insert_dev(target, t, anchor);
				insert_dev(target, div, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const listitem_changes = {};
				if (dirty & /*selectedUsers*/ 1) listitem_changes.item = /*user*/ ctx[20];
				if (dirty & /*selectionIndex, topList*/ 24) listitem_changes.isSelected = /*index*/ ctx[22] === /*selectionIndex*/ ctx[3] && /*topList*/ ctx[4];
				if (dirty & /*showOptions*/ 4) listitem_changes.showOptions = /*showOptions*/ ctx[2];
				if (dirty & /*selectedUsers*/ 1) listitem_changes.reverseModal = /*selectedUsers*/ ctx[0].length > 3 && /*index*/ ctx[22] > /*selectedUsers*/ ctx[0].length - 3;
				listitem.$set(listitem_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(listitem.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(listitem.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
					detach_dev(div);
				}

				destroy_component(listitem, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$i.name,
			type: "each",
			source: "(113:3) {#each selectedUsers as user, index}",
			ctx
		});

		return block;
	}

	function create_fragment$O(ctx) {
		let div3;
		let div1;
		let div0;
		let lens;
		let t0;
		let input;
		let t1;
		let div2;
		let div2_class_value;
		let t2;
		let if_block_anchor;
		let current;
		let mounted;
		let dispose;
		lens = new Lens({ $$inline: true });
		let each_value_1 = ensure_array_like_dev(/*filteredUsers*/ ctx[5]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let if_block = /*selectedUsers*/ ctx[0].length !== 0 && create_if_block$A(ctx);

		const block = {
			c: function create() {
				div3 = element("div");
				div1 = element("div");
				div0 = element("div");
				create_component(lens.$$.fragment);
				t0 = space();
				input = element("input");
				t1 = space();
				div2 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t2 = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
				attr_dev(input, "type", "text");
				attr_dev(input, "class", "h-[1.60rem] w-full bg-osvauld-frameblack border-0 text-osvauld-quarzowhite placeholder-osvauld-placeholderblack border-transparent text-base focus:border-transparent focus:ring-0 cursor-pointer");
				attr_dev(input, "placeholder", "");
				add_location(input, file$O, 92, 3, 2675);
				attr_dev(div0, "class", "h-[1.875rem] w-full px-2 mx-auto flex justify-start items-center border border-osvauld-iconblack rounded-lg cursor-pointer");
				add_location(div0, file$O, 88, 2, 2517);
				attr_dev(div1, "class", "bg-osvauld-frameblack flex justify-center items-center");
				add_location(div1, file$O, 87, 1, 2446);

				attr_dev(div2, "class", div2_class_value = "overflow-y-scroll scrollbar-thin bg-osvauld-frameblack w-full " + (/*selectedUsers*/ ctx[0].length !== 0
				? 'h-[8rem]'
				: 'h-[15rem]') + " flex flex-col justify-start items-center");

				add_location(div2, file$O, 101, 1, 2979);
				attr_dev(div3, "class", "p-2 w-full max-h-full overflow-hidden");
				add_location(div3, file$O, 86, 0, 2393);
			},
			l: function claim(nodes) {
				throw new Error_1$6("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div3, anchor);
				append_dev(div3, div1);
				append_dev(div1, div0);
				mount_component(lens, div0, null);
				append_dev(div0, t0);
				append_dev(div0, input);
				set_input_value(input, /*searchInput*/ ctx[1]);
				append_dev(div3, t1);
				append_dev(div3, div2);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div2, null);
					}
				}

				insert_dev(target, t2, anchor);
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;

				if (!mounted) {
					dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[12]);
					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*searchInput*/ 2 && input.value !== /*searchInput*/ ctx[1]) {
					set_input_value(input, /*searchInput*/ ctx[1]);
				}

				if (dirty & /*filteredUsers, selectionIndex, topList, showOptions, handleClick, handleRoleChange*/ 380) {
					each_value_1 = ensure_array_like_dev(/*filteredUsers*/ ctx[5]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1$5(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div2, null);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (!current || dirty & /*selectedUsers*/ 1 && div2_class_value !== (div2_class_value = "overflow-y-scroll scrollbar-thin bg-osvauld-frameblack w-full " + (/*selectedUsers*/ ctx[0].length !== 0
				? 'h-[8rem]'
				: 'h-[15rem]') + " flex flex-col justify-start items-center")) {
					attr_dev(div2, "class", div2_class_value);
				}

				if (/*selectedUsers*/ ctx[0].length !== 0) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*selectedUsers*/ 1) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$A(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(lens.$$.fragment, local);

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(lens.$$.fragment, local);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div3);
					detach_dev(t2);
					detach_dev(if_block_anchor);
				}

				destroy_component(lens);
				destroy_each(each_blocks, detaching);
				if (if_block) if_block.d(detaching);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$O.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$O($$self, $$props, $$invalidate) {
		let filteredUsers;
		let $selectedFolder;
		validate_store(selectedFolder, 'selectedFolder');
		component_subscribe($$self, selectedFolder, $$value => $$invalidate(18, $selectedFolder = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ShareFolderWithUsers', slots, []);
		const dispatch = createEventDispatcher();
		let { users } = $$props;
		let { credentialsFields } = $$props;
		let selectedUsers = [];
		let showOptions = false;
		let selectionIndex = null;
		let topList = false;
		let searchInput = "";

		const shareFolderHandler = async () => {
			if ($selectedFolder === undefined) {
				throw new Error("Folder not selected");
			}

			const userData = await sendMessage("createShareCredPayload", {
				creds: credentialsFields,
				users: selectedUsers
			});

			const shareFolderPayload = { folderId: $selectedFolder.id, userData };
			const shareStatus = await shareFolderWithUsers(shareFolderPayload);

			toastStore.set({
				type: shareStatus.success,
				message: "Successfully shared",
				show: true
			});

			dispatch("cancel", true);
		};

		function handleClick(index, isSelectedList) {
			$$invalidate(2, showOptions = !showOptions);
			$$invalidate(3, selectionIndex = index);
			$$invalidate(4, topList = isSelectedList);
		}

		function handleItemRemove(index) {
			const removedUser = selectedUsers.splice(index, 1);
			$$invalidate(0, selectedUsers = [...selectedUsers]);
			const [{ accessType, ...userWithoutAccessType }] = removedUser;
			$$invalidate(9, users = [...users, { ...userWithoutAccessType }]);
		}

		function handleRoleChange(e, index, type) {
			const user = e.detail.item;
			const option = e.detail.permission;
			$$invalidate(2, showOptions = !showOptions);
			$$invalidate(3, selectionIndex = null);

			if (type === "selectedUsers") {
				selectedUsers.splice(index, 1);
				$$invalidate(0, selectedUsers = [...selectedUsers, { ...user, accessType: option }]);
			} else {
				$$invalidate(0, selectedUsers = [...selectedUsers, { ...user, accessType: option }]);
				$$invalidate(9, users = users.filter(u => u.id !== user.id));
			}

			selectedUsers.length !== 0 && dispatch("enable", true);
		}

		onMount(() => {
			//Below will disable save changes button when group/user button switched
			dispatch("enable", false);
		});

		$$self.$$.on_mount.push(function () {
			if (users === undefined && !('users' in $$props || $$self.$$.bound[$$self.$$.props['users']])) {
				console.warn("<ShareFolderWithUsers> was created without expected prop 'users'");
			}

			if (credentialsFields === undefined && !('credentialsFields' in $$props || $$self.$$.bound[$$self.$$.props['credentialsFields']])) {
				console.warn("<ShareFolderWithUsers> was created without expected prop 'credentialsFields'");
			}
		});

		const writable_props = ['users', 'credentialsFields'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ShareFolderWithUsers> was created with unknown prop '${key}'`);
		});

		function input_input_handler() {
			searchInput = this.value;
			$$invalidate(1, searchInput);
		}

		const click_handler = index => handleClick(index, false);
		const select_handler = (index, e) => handleRoleChange(e, index, 'users');
		const click_handler_1 = index => handleClick(index, true);
		const remove_handler = index => handleItemRemove(index);
		const select_handler_1 = (index, e) => handleRoleChange(e, index, 'selectedUsers');

		$$self.$$set = $$props => {
			if ('users' in $$props) $$invalidate(9, users = $$props.users);
			if ('credentialsFields' in $$props) $$invalidate(10, credentialsFields = $$props.credentialsFields);
		};

		$$self.$capture_state = () => ({
			shareFolderWithUsers,
			createEventDispatcher,
			onMount,
			selectedFolder,
			toastStore,
			sendMessage,
			Lens,
			ListItem,
			dispatch,
			users,
			credentialsFields,
			selectedUsers,
			showOptions,
			selectionIndex,
			topList,
			searchInput,
			shareFolderHandler,
			handleClick,
			handleItemRemove,
			handleRoleChange,
			filteredUsers,
			$selectedFolder
		});

		$$self.$inject_state = $$props => {
			if ('users' in $$props) $$invalidate(9, users = $$props.users);
			if ('credentialsFields' in $$props) $$invalidate(10, credentialsFields = $$props.credentialsFields);
			if ('selectedUsers' in $$props) $$invalidate(0, selectedUsers = $$props.selectedUsers);
			if ('showOptions' in $$props) $$invalidate(2, showOptions = $$props.showOptions);
			if ('selectionIndex' in $$props) $$invalidate(3, selectionIndex = $$props.selectionIndex);
			if ('topList' in $$props) $$invalidate(4, topList = $$props.topList);
			if ('searchInput' in $$props) $$invalidate(1, searchInput = $$props.searchInput);
			if ('filteredUsers' in $$props) $$invalidate(5, filteredUsers = $$props.filteredUsers);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*selectedUsers*/ 1) {
				selectedUsers.length === 0 && dispatch("enable", false);
			}

			if ($$self.$$.dirty & /*searchInput, users*/ 514) {
				$$invalidate(5, filteredUsers = searchInput
				? users.filter(user => user.name.toLowerCase().includes(searchInput.toLowerCase()))
				: users);
			}
		};

		return [
			selectedUsers,
			searchInput,
			showOptions,
			selectionIndex,
			topList,
			filteredUsers,
			handleClick,
			handleItemRemove,
			handleRoleChange,
			users,
			credentialsFields,
			shareFolderHandler,
			input_input_handler,
			click_handler,
			select_handler,
			click_handler_1,
			remove_handler,
			select_handler_1
		];
	}

	class ShareFolderWithUsers extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$O, create_fragment$O, safe_not_equal, {
				users: 9,
				credentialsFields: 10,
				shareFolderHandler: 11
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ShareFolderWithUsers",
				options,
				id: create_fragment$O.name
			});
		}

		get users() {
			throw new Error_1$6("<ShareFolderWithUsers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set users(value) {
			throw new Error_1$6("<ShareFolderWithUsers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get credentialsFields() {
			throw new Error_1$6("<ShareFolderWithUsers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set credentialsFields(value) {
			throw new Error_1$6("<ShareFolderWithUsers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get shareFolderHandler() {
			return this.$$.ctx[11];
		}

		set shareFolderHandler(value) {
			throw new Error_1$6("<ShareFolderWithUsers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/components/Info.svelte generated by Svelte v4.2.19 */
	const file$N = "src/lib/components/dashboard/components/Info.svelte";

	function create_fragment$N(ctx) {
		let div2;
		let div0;
		let h60;
		let t1;
		let p0;
		let t3;
		let p1;
		let t5;
		let div1;
		let h61;
		let t7;
		let p2;

		const block = {
			c: function create() {
				div2 = element("div");
				div0 = element("div");
				h60 = element("h6");
				h60.textContent = "Manager";
				t1 = space();
				p0 = element("p");
				p0.textContent = "Can share folder/credentials.";
				t3 = space();
				p1 = element("p");
				p1.textContent = "Can view Audit logs and readers list";
				t5 = space();
				div1 = element("div");
				h61 = element("h6");
				h61.textContent = "Reader";
				t7 = space();
				p2 = element("p");
				p2.textContent = "Read only";
				attr_dev(h60, "class", "font-semibold text-base mb-1");
				add_location(h60, file$N, 6, 2, 325);
				add_location(p0, file$N, 7, 2, 381);
				add_location(p1, file$N, 8, 2, 420);
				attr_dev(div0, "class", "w-full mt-2 mb-1 rounded-lg bg-osvauld-managerPurple text-osvauld-managerText text-left pl-4 py-2");
				add_location(div0, file$N, 3, 1, 207);
				attr_dev(h61, "class", "font-semibold text-base mb-1");
				add_location(h61, file$N, 13, 2, 589);
				add_location(p2, file$N, 14, 2, 644);
				attr_dev(div1, "class", "w-full mb-2 mt-1 rounded-lg bg-osvauld-readerOrange text-osvauld-readerText text-left pl-4 py-2");
				add_location(div1, file$N, 10, 1, 473);
				attr_dev(div2, "class", "absolute top-[2.2rem] left-0 w-[100%] h-auto bg-osvauld-frameblack border-2 border-osvauld-bordergreen font-normal text-sm px-2 rounded-xl flex flex-col justify-center items-center z-[9999]");
				add_location(div2, file$N, 0, 0, 0);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div2, anchor);
				append_dev(div2, div0);
				append_dev(div0, h60);
				append_dev(div0, t1);
				append_dev(div0, p0);
				append_dev(div0, t3);
				append_dev(div0, p1);
				append_dev(div2, t5);
				append_dev(div2, div1);
				append_dev(div1, h61);
				append_dev(div1, t7);
				append_dev(div1, p2);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div2);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$N.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$N($$self, $$props) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Info', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Info> was created with unknown prop '${key}'`);
		});

		return [];
	}

	class Info extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$N, create_fragment$N, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Info",
				options,
				id: create_fragment$N.name
			});
		}
	}

	/* src/lib/components/dashboard/folders/ShareFolderModal.svelte generated by Svelte v4.2.19 */

	const { Error: Error_1$5 } = globals;
	const file$M = "src/lib/components/dashboard/folders/ShareFolderModal.svelte";

	// (54:2) {#if showInfoTab}
	function create_if_block_1$q(ctx) {
		let div;
		let span;
		let infoicon;
		let t0;
		let p;
		let t2;
		let infooverlay;
		let current;
		infoicon = new InfoIcon({ $$inline: true });
		infooverlay = new Info({ $$inline: true });

		const block = {
			c: function create() {
				div = element("div");
				span = element("span");
				create_component(infoicon.$$.fragment);
				t0 = space();
				p = element("p");
				p.textContent = "Select groups/users and choose access type";
				t2 = space();
				create_component(infooverlay.$$.fragment);
				attr_dev(span, "class", "mr-2");
				add_location(span, file$M, 66, 4, 2023);
				attr_dev(p, "class", "text-sm font-normal text-osvauld-highlightwhite ");
				add_location(p, file$M, 69, 4, 2077);
				attr_dev(div, "class", "relative h-auto w-full px-4 py-2 mx-auto flex justify-start items-center rounded-lg cursor-pointer bg-osvauld-fieldActive");
				add_location(div, file$M, 63, 3, 1875);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, span);
				mount_component(infoicon, span, null);
				append_dev(div, t0);
				append_dev(div, p);
				append_dev(div, t2);
				mount_component(infooverlay, div, null);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(infoicon.$$.fragment, local);
				transition_in(infooverlay.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(infoicon.$$.fragment, local);
				transition_out(infooverlay.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(infoicon);
				destroy_component(infooverlay);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$q.name,
			type: "if",
			source: "(54:2) {#if showInfoTab}",
			ctx
		});

		return block;
	}

	// (85:3) {:else}
	function create_else_block$n(ctx) {
		let sharefolderwithgroups;
		let current;

		let sharefolderwithgroups_props = {
			credentialsFields: /*credentialsFields*/ ctx[1]
		};

		sharefolderwithgroups = new ShareFolderWithGroups({
				props: sharefolderwithgroups_props,
				$$inline: true
			});

		/*sharefolderwithgroups_binding*/ ctx[15](sharefolderwithgroups);
		sharefolderwithgroups.$on("cancel", /*cancel_handler_1*/ ctx[16]);
		sharefolderwithgroups.$on("enable", /*enable_handler_1*/ ctx[17]);

		const block = {
			c: function create() {
				create_component(sharefolderwithgroups.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(sharefolderwithgroups, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const sharefolderwithgroups_changes = {};
				if (dirty & /*credentialsFields*/ 2) sharefolderwithgroups_changes.credentialsFields = /*credentialsFields*/ ctx[1];
				sharefolderwithgroups.$set(sharefolderwithgroups_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(sharefolderwithgroups.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(sharefolderwithgroups.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				/*sharefolderwithgroups_binding*/ ctx[15](null);
				destroy_component(sharefolderwithgroups, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$n.name,
			type: "else",
			source: "(85:3) {:else}",
			ctx
		});

		return block;
	}

	// (77:3) {#if selectedTab === "Users"}
	function create_if_block$z(ctx) {
		let sharefolderwithusers;
		let current;

		let sharefolderwithusers_props = {
			users: /*users*/ ctx[0],
			credentialsFields: /*credentialsFields*/ ctx[1]
		};

		sharefolderwithusers = new ShareFolderWithUsers({
				props: sharefolderwithusers_props,
				$$inline: true
			});

		/*sharefolderwithusers_binding*/ ctx[12](sharefolderwithusers);
		sharefolderwithusers.$on("cancel", /*cancel_handler*/ ctx[13]);
		sharefolderwithusers.$on("enable", /*enable_handler*/ ctx[14]);

		const block = {
			c: function create() {
				create_component(sharefolderwithusers.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(sharefolderwithusers, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const sharefolderwithusers_changes = {};
				if (dirty & /*users*/ 1) sharefolderwithusers_changes.users = /*users*/ ctx[0];
				if (dirty & /*credentialsFields*/ 2) sharefolderwithusers_changes.credentialsFields = /*credentialsFields*/ ctx[1];
				sharefolderwithusers.$set(sharefolderwithusers_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(sharefolderwithusers.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(sharefolderwithusers.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				/*sharefolderwithusers_binding*/ ctx[12](null);
				destroy_component(sharefolderwithusers, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$z.name,
			type: "if",
			source: "(77:3) {#if selectedTab === \\\"Users\\\"}",
			ctx
		});

		return block;
	}

	function create_fragment$M(ctx) {
		let div6;
		let div5;
		let div0;
		let span;
		let t0;
		let button0;
		let infoicon;
		let t1;
		let button1;
		let closepanel;
		let t2;
		let t3;
		let div1;
		let t4;
		let div2;
		let toggle;
		let t5;
		let current_block_type_index;
		let if_block1;
		let t6;
		let div3;
		let t7;
		let div4;
		let button2;
		let t9;
		let button3;
		let t10;
		let button3_class_value;
		let button3_disabled_value;
		let div6_intro;
		let div6_outro;
		let current;
		let mounted;
		let dispose;

		infoicon = new InfoIcon({
				props: {
					color: /*infoOnHover*/ ctx[2] ? '#BFC0CC' : '#4D4F60'
				},
				$$inline: true
			});

		closepanel = new ClosePanel({ $$inline: true });
		let if_block0 = /*showInfoTab*/ ctx[3] && create_if_block_1$q(ctx);
		toggle = new Toggle({ $$inline: true });
		toggle.$on("select", /*toggleSelect*/ ctx[7]);
		const if_block_creators = [create_if_block$z, create_else_block$n];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*selectedTab*/ ctx[4] === "Users") return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				div6 = element("div");
				div5 = element("div");
				div0 = element("div");
				span = element("span");
				t0 = text("Share Folder ");
				button0 = element("button");
				create_component(infoicon.$$.fragment);
				t1 = space();
				button1 = element("button");
				create_component(closepanel.$$.fragment);
				t2 = space();
				if (if_block0) if_block0.c();
				t3 = space();
				div1 = element("div");
				t4 = space();
				div2 = element("div");
				create_component(toggle.$$.fragment);
				t5 = space();
				if_block1.c();
				t6 = space();
				div3 = element("div");
				t7 = space();
				div4 = element("div");
				button2 = element("button");
				button2.textContent = "Cancel";
				t9 = space();
				button3 = element("button");
				t10 = text("Save changes");
				attr_dev(button0, "class", "ml-2 pt-1");
				add_location(button0, file$M, 48, 18, 1458);
				attr_dev(span, "class", "font-sans text-osvauld-quarzowhite text-xl font-normal flex justify-center items-center");
				add_location(span, file$M, 46, 3, 1334);
				attr_dev(button1, "class", "p-2");
				add_location(button1, file$M, 57, 3, 1737);
				attr_dev(div0, "class", "flex justify-between items-center p-3 pt-0");
				add_location(div0, file$M, 45, 2, 1274);
				attr_dev(div1, "class", "border-b mt-2 mb-4 border-osvauld-iconblack w-[calc(100%+3.5rem)] -translate-x-7");
				add_location(div1, file$M, 79, 2, 2258);
				attr_dev(div2, "class", "");
				add_location(div2, file$M, 83, 2, 2368);
				attr_dev(div3, "class", "border-b mt-auto mb-2 border-osvauld-iconblack w-[calc(100%+3.5rem)] -translate-x-7");
				add_location(div3, file$M, 102, 2, 2898);
				attr_dev(button2, "class", "ml-auto p-2 whitespace-nowrap text-sm font-medium text-osvauld-fadedCancel");
				add_location(button2, file$M, 106, 3, 3084);

				attr_dev(button3, "class", button3_class_value = "ml-4 px-3 py-2 whitespace-nowrap text-sm font-medium rounded-md " + (/*saveEnabled*/ ctx[6]
				? 'bg-osvauld-carolinablue text-osvauld-frameblack border-transparent'
				: 'border border-osvauld-iconblack text-osvauld-textActive'));

				button3.disabled = button3_disabled_value = !/*saveEnabled*/ ctx[6];
				add_location(button3, file$M, 111, 3, 3259);
				attr_dev(div4, "class", "p-2 w-full flex justify-end items-center box-border mt-0");
				add_location(div4, file$M, 105, 2, 3010);
				attr_dev(div5, "class", "w-[32.25rem] min-h-[34.375rem] max-h-[37rem] rounded-2xl translate-x-0 bg-osvauld-frameblack p-7 flex flex-col");
				add_location(div5, file$M, 42, 1, 1143);
				attr_dev(div6, "class", "fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 flex justify-end rounded-2xl border border-osvauld-activeBorder");
				add_location(div6, file$M, 37, 0, 973);
			},
			l: function claim(nodes) {
				throw new Error_1$5("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div6, anchor);
				append_dev(div6, div5);
				append_dev(div5, div0);
				append_dev(div0, span);
				append_dev(span, t0);
				append_dev(span, button0);
				mount_component(infoicon, button0, null);
				append_dev(div0, t1);
				append_dev(div0, button1);
				mount_component(closepanel, button1, null);
				append_dev(div5, t2);
				if (if_block0) if_block0.m(div5, null);
				append_dev(div5, t3);
				append_dev(div5, div1);
				append_dev(div5, t4);
				append_dev(div5, div2);
				mount_component(toggle, div2, null);
				append_dev(div2, t5);
				if_blocks[current_block_type_index].m(div2, null);
				append_dev(div5, t6);
				append_dev(div5, div3);
				append_dev(div5, t7);
				append_dev(div5, div4);
				append_dev(div4, button2);
				append_dev(div4, t9);
				append_dev(div4, button3);
				append_dev(button3, t10);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "mouseenter", /*mouseenter_handler*/ ctx[8], false, false, false, false),
						listen_dev(button0, "mouseleave", /*mouseleave_handler*/ ctx[9], false, false, false, false),
						listen_dev(button0, "click", /*click_handler*/ ctx[10], false, false, false, false),
						listen_dev(button1, "click", /*click_handler_1*/ ctx[11], false, false, false, false),
						listen_dev(button2, "click", /*click_handler_2*/ ctx[18], false, false, false, false),
						listen_dev(button3, "click", /*click_handler_3*/ ctx[19], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				const infoicon_changes = {};
				if (dirty & /*infoOnHover*/ 4) infoicon_changes.color = /*infoOnHover*/ ctx[2] ? '#BFC0CC' : '#4D4F60';
				infoicon.$set(infoicon_changes);

				if (/*showInfoTab*/ ctx[3]) {
					if (if_block0) {
						if (dirty & /*showInfoTab*/ 8) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$q(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div5, t3);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div2, null);
				}

				if (!current || dirty & /*saveEnabled*/ 64 && button3_class_value !== (button3_class_value = "ml-4 px-3 py-2 whitespace-nowrap text-sm font-medium rounded-md " + (/*saveEnabled*/ ctx[6]
				? 'bg-osvauld-carolinablue text-osvauld-frameblack border-transparent'
				: 'border border-osvauld-iconblack text-osvauld-textActive'))) {
					attr_dev(button3, "class", button3_class_value);
				}

				if (!current || dirty & /*saveEnabled*/ 64 && button3_disabled_value !== (button3_disabled_value = !/*saveEnabled*/ ctx[6])) {
					prop_dev(button3, "disabled", button3_disabled_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(infoicon.$$.fragment, local);
				transition_in(closepanel.$$.fragment, local);
				transition_in(if_block0);
				transition_in(toggle.$$.fragment, local);
				transition_in(if_block1);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (div6_outro) div6_outro.end(1);
						div6_intro = create_in_transition(div6, fly, {});
						div6_intro.start();
					});
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(infoicon.$$.fragment, local);
				transition_out(closepanel.$$.fragment, local);
				transition_out(if_block0);
				transition_out(toggle.$$.fragment, local);
				transition_out(if_block1);
				if (div6_intro) div6_intro.invalidate();

				if (local) {
					div6_outro = create_out_transition(div6, fly, {});
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div6);
				}

				destroy_component(infoicon);
				destroy_component(closepanel);
				if (if_block0) if_block0.d();
				destroy_component(toggle);
				if_blocks[current_block_type_index].d();
				if (detaching && div6_outro) div6_outro.end();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$M.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$M($$self, $$props, $$invalidate) {
		let saveEnabled;
		let $selectedFolder;
		validate_store(selectedFolder, 'selectedFolder');
		component_subscribe($$self, selectedFolder, $$value => $$invalidate(20, $selectedFolder = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ShareFolderModal', slots, []);
		let { users } = $$props;
		let credentialsFields;
		let infoOnHover = false;
		let showInfoTab = false;
		let selectedTab = "Groups";

		onMount(async () => {
			if (!$selectedFolder) throw new Error("folder not selected");
			const responseJson = await fetchCredentialsFieldsByFolderId($selectedFolder.id);
			$$invalidate(1, credentialsFields = responseJson.data);
		});

		const toggleSelect = e => {
			$$invalidate(4, selectedTab = e.detail);
		};

		let saveChanges;

		$$self.$$.on_mount.push(function () {
			if (users === undefined && !('users' in $$props || $$self.$$.bound[$$self.$$.props['users']])) {
				console.warn("<ShareFolderModal> was created without expected prop 'users'");
			}
		});

		const writable_props = ['users'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ShareFolderModal> was created with unknown prop '${key}'`);
		});

		const mouseenter_handler = () => $$invalidate(2, infoOnHover = true);
		const mouseleave_handler = () => $$invalidate(2, infoOnHover = false);
		const click_handler = () => $$invalidate(3, showInfoTab = !showInfoTab);
		const click_handler_1 = () => showFolderShareDrawer.set(false);

		function sharefolderwithusers_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				saveChanges = $$value;
				$$invalidate(5, saveChanges);
			});
		}

		const cancel_handler = () => showFolderShareDrawer.set(false);
		const enable_handler = e => $$invalidate(6, saveEnabled = e.detail);

		function sharefolderwithgroups_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				saveChanges = $$value;
				$$invalidate(5, saveChanges);
			});
		}

		const cancel_handler_1 = () => showFolderShareDrawer.set(false);
		const enable_handler_1 = e => $$invalidate(6, saveEnabled = e.detail);
		const click_handler_2 = () => showFolderShareDrawer.set(false);
		const click_handler_3 = () => saveChanges.shareFolderHandler();

		$$self.$$set = $$props => {
			if ('users' in $$props) $$invalidate(0, users = $$props.users);
		};

		$$self.$capture_state = () => ({
			fly,
			onMount,
			fetchCredentialsFieldsByFolderId,
			selectedFolder,
			showFolderShareDrawer,
			InfoIcon,
			ClosePanel,
			ShareFolderWithGroups,
			Toggle,
			ShareFolderWithUsers,
			InfoOverlay: Info,
			users,
			credentialsFields,
			infoOnHover,
			showInfoTab,
			selectedTab,
			toggleSelect,
			saveChanges,
			saveEnabled,
			$selectedFolder
		});

		$$self.$inject_state = $$props => {
			if ('users' in $$props) $$invalidate(0, users = $$props.users);
			if ('credentialsFields' in $$props) $$invalidate(1, credentialsFields = $$props.credentialsFields);
			if ('infoOnHover' in $$props) $$invalidate(2, infoOnHover = $$props.infoOnHover);
			if ('showInfoTab' in $$props) $$invalidate(3, showInfoTab = $$props.showInfoTab);
			if ('selectedTab' in $$props) $$invalidate(4, selectedTab = $$props.selectedTab);
			if ('saveChanges' in $$props) $$invalidate(5, saveChanges = $$props.saveChanges);
			if ('saveEnabled' in $$props) $$invalidate(6, saveEnabled = $$props.saveEnabled);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$invalidate(6, saveEnabled = false);

		return [
			users,
			credentialsFields,
			infoOnHover,
			showInfoTab,
			selectedTab,
			saveChanges,
			saveEnabled,
			toggleSelect,
			mouseenter_handler,
			mouseleave_handler,
			click_handler,
			click_handler_1,
			sharefolderwithusers_binding,
			cancel_handler,
			enable_handler,
			sharefolderwithgroups_binding,
			cancel_handler_1,
			enable_handler_1,
			click_handler_2,
			click_handler_3
		];
	}

	class ShareFolderModal extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$M, create_fragment$M, safe_not_equal, { users: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ShareFolderModal",
				options,
				id: create_fragment$M.name
			});
		}

		get users() {
			throw new Error_1$5("<ShareFolderModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set users(value) {
			throw new Error_1$5("<ShareFolderModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/credentials/ShareCredentialsWithUsers.svelte generated by Svelte v4.2.19 */
	const file$L = "src/lib/components/dashboard/credentials/ShareCredentialsWithUsers.svelte";

	function get_each_context$h(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[19] = list[i];
		child_ctx[21] = i;
		return child_ctx;
	}

	function get_each_context_1$4(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[19] = list[i];
		child_ctx[21] = i;
		return child_ctx;
	}

	// (81:2) {#each filteredUsers as user, index}
	function create_each_block_1$4(ctx) {
		let listitem;
		let current;

		function click_handler() {
			return /*click_handler*/ ctx[13](/*index*/ ctx[21]);
		}

		function select_handler(...args) {
			return /*select_handler*/ ctx[14](/*index*/ ctx[21], ...args);
		}

		listitem = new ListItem({
				props: {
					item: /*user*/ ctx[19],
					isSelected: /*index*/ ctx[21] === /*selectionIndex*/ ctx[3] && !/*topList*/ ctx[4],
					showOptions: /*showOptions*/ ctx[2],
					reverseModal: /*filteredUsers*/ ctx[5].length > 3 && /*index*/ ctx[21] > /*filteredUsers*/ ctx[5].length - 3
				},
				$$inline: true
			});

		listitem.$on("click", click_handler);
		listitem.$on("select", select_handler);

		const block = {
			c: function create() {
				create_component(listitem.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(listitem, target, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const listitem_changes = {};
				if (dirty & /*filteredUsers*/ 32) listitem_changes.item = /*user*/ ctx[19];
				if (dirty & /*selectionIndex, topList*/ 24) listitem_changes.isSelected = /*index*/ ctx[21] === /*selectionIndex*/ ctx[3] && !/*topList*/ ctx[4];
				if (dirty & /*showOptions*/ 4) listitem_changes.showOptions = /*showOptions*/ ctx[2];
				if (dirty & /*filteredUsers*/ 32) listitem_changes.reverseModal = /*filteredUsers*/ ctx[5].length > 3 && /*index*/ ctx[21] > /*filteredUsers*/ ctx[5].length - 3;
				listitem.$set(listitem_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(listitem.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(listitem.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(listitem, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block_1$4.name,
			type: "each",
			source: "(81:2) {#each filteredUsers as user, index}",
			ctx
		});

		return block;
	}

	// (95:0) {#if selectedUsers.length !== 0}
	function create_if_block$y(ctx) {
		let div;
		let current;
		let each_value = ensure_array_like_dev(/*selectedUsers*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(div, "class", "overflow-y-scroll overflow-x-hidden scrollbar-thin bg-osvauld-frameblack rounded-lg w-full h-[8rem] p-0.5 border border-osvauld-iconblack mt-auto !text-osvauld-textActive");
				add_location(div, file$L, 115, 1, 3194);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty & /*selectedUsers, selectionIndex, topList, showOptions, handleClick, handleItemRemove, handleRoleChange*/ 477) {
					each_value = ensure_array_like_dev(/*selectedUsers*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$h(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$h(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$y.name,
			type: "if",
			source: "(95:0) {#if selectedUsers.length !== 0}",
			ctx
		});

		return block;
	}

	// (99:2) {#each selectedUsers as user, index}
	function create_each_block$h(ctx) {
		let listitem;
		let current;

		function click_handler_1() {
			return /*click_handler_1*/ ctx[15](/*index*/ ctx[21]);
		}

		function remove_handler() {
			return /*remove_handler*/ ctx[16](/*index*/ ctx[21]);
		}

		function select_handler_1(...args) {
			return /*select_handler_1*/ ctx[17](/*index*/ ctx[21], ...args);
		}

		listitem = new ListItem({
				props: {
					item: /*user*/ ctx[19],
					isSelected: /*index*/ ctx[21] === /*selectionIndex*/ ctx[3] && /*topList*/ ctx[4],
					isBottomList: true,
					showOptions: /*showOptions*/ ctx[2],
					reverseModal: /*selectedUsers*/ ctx[0].length > 3 && /*index*/ ctx[21] > /*selectedUsers*/ ctx[0].length - 3
				},
				$$inline: true
			});

		listitem.$on("click", click_handler_1);
		listitem.$on("remove", remove_handler);
		listitem.$on("select", select_handler_1);

		const block = {
			c: function create() {
				create_component(listitem.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(listitem, target, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const listitem_changes = {};
				if (dirty & /*selectedUsers*/ 1) listitem_changes.item = /*user*/ ctx[19];
				if (dirty & /*selectionIndex, topList*/ 24) listitem_changes.isSelected = /*index*/ ctx[21] === /*selectionIndex*/ ctx[3] && /*topList*/ ctx[4];
				if (dirty & /*showOptions*/ 4) listitem_changes.showOptions = /*showOptions*/ ctx[2];
				if (dirty & /*selectedUsers*/ 1) listitem_changes.reverseModal = /*selectedUsers*/ ctx[0].length > 3 && /*index*/ ctx[21] > /*selectedUsers*/ ctx[0].length - 3;
				listitem.$set(listitem_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(listitem.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(listitem.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(listitem, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$h.name,
			type: "each",
			source: "(99:2) {#each selectedUsers as user, index}",
			ctx
		});

		return block;
	}

	function create_fragment$L(ctx) {
		let div2;
		let div0;
		let lens;
		let t0;
		let input;
		let t1;
		let div1;
		let t2;
		let if_block_anchor;
		let current;
		let mounted;
		let dispose;
		lens = new Lens({ $$inline: true });
		let each_value_1 = ensure_array_like_dev(/*filteredUsers*/ ctx[5]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let if_block = /*selectedUsers*/ ctx[0].length !== 0 && create_if_block$y(ctx);

		const block = {
			c: function create() {
				div2 = element("div");
				div0 = element("div");
				create_component(lens.$$.fragment);
				t0 = space();
				input = element("input");
				t1 = space();
				div1 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t2 = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
				attr_dev(input, "type", "text");
				attr_dev(input, "class", "h-[1.60rem] w-full bg-osvauld-frameblack border-0 text-osvauld-quarzowhite placeholder-osvauld-placeholderblack border-transparent text-base focus:border-transparent focus:ring-0 cursor-pointer");
				attr_dev(input, "placeholder", "");
				add_location(input, file$L, 89, 2, 2407);
				attr_dev(div0, "class", "h-[1.875rem] w-full px-2 mx-auto flex justify-start items-center cursor-pointer border rounded-lg border-osvauld-iconblack");
				add_location(div0, file$L, 85, 1, 2253);
				attr_dev(div1, "class", "overflow-y-scroll scrollbar-thin h-[20rem] bg-osvauld-frameblack w-full");
				add_location(div1, file$L, 97, 1, 2697);
				attr_dev(div2, "class", "p-2 rounded-lg pl-2 w-full");
				add_location(div2, file$L, 84, 0, 2211);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div2, anchor);
				append_dev(div2, div0);
				mount_component(lens, div0, null);
				append_dev(div0, t0);
				append_dev(div0, input);
				set_input_value(input, /*searchInput*/ ctx[1]);
				append_dev(div2, t1);
				append_dev(div2, div1);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div1, null);
					}
				}

				insert_dev(target, t2, anchor);
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;

				if (!mounted) {
					dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[12]);
					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*searchInput*/ 2 && input.value !== /*searchInput*/ ctx[1]) {
					set_input_value(input, /*searchInput*/ ctx[1]);
				}

				if (dirty & /*filteredUsers, selectionIndex, topList, showOptions, handleClick, handleRoleChange*/ 380) {
					each_value_1 = ensure_array_like_dev(/*filteredUsers*/ ctx[5]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1$4(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div1, null);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (/*selectedUsers*/ ctx[0].length !== 0) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*selectedUsers*/ 1) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$y(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(lens.$$.fragment, local);

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(lens.$$.fragment, local);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div2);
					detach_dev(t2);
					detach_dev(if_block_anchor);
				}

				destroy_component(lens);
				destroy_each(each_blocks, detaching);
				if (if_block) if_block.d(detaching);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$L.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$L($$self, $$props, $$invalidate) {
		let filteredUsers;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ShareCredentialsWithUsers', slots, []);
		const dispatch = createEventDispatcher();
		let { users } = $$props;
		let { credentialsFields = [] } = $$props;
		let selectedUsers = [];
		let showOptions = false;
		let selectionIndex = null;
		let topList = false;
		let searchInput = "";

		const shareCredentialHandler = async () => {
			const userData = await sendMessage("createShareCredPayload", {
				creds: credentialsFields,
				users: selectedUsers
			});

			const payload = { userData };
			const shareStatus = await shareCredentialsWithUsers(payload);

			toastStore.set({
				type: true,
				message: shareStatus.message,
				show: true
			});

			dispatch("cancel", true);
		};

		function handleClick(index, isSelectedList) {
			$$invalidate(2, showOptions = !showOptions);
			$$invalidate(3, selectionIndex = index);
			$$invalidate(4, topList = isSelectedList);
		}

		function handleItemRemove(index) {
			const removedUser = selectedUsers.splice(index, 1);
			$$invalidate(0, selectedUsers = [...selectedUsers]);
			const [{ accessType, ...userWithoutAccessType }] = removedUser;
			$$invalidate(9, users = [...users, { ...userWithoutAccessType }]);
		}

		function handleRoleChange(e, index, type) {
			const user = e.detail.item;
			const option = e.detail.permission;
			$$invalidate(2, showOptions = !showOptions);
			$$invalidate(3, selectionIndex = null);

			if (type === "selectedUsers") {
				selectedUsers.splice(index, 1);
				$$invalidate(0, selectedUsers = [...selectedUsers, { ...user, accessType: option }]);
			} else {
				$$invalidate(0, selectedUsers = [...selectedUsers, { ...user, accessType: option }]);
				$$invalidate(9, users = users.filter(u => u.id !== user.id));
			}

			selectedUsers.length !== 0 && dispatch("enable", true);
		}

		onMount(() => {
			//Below will disable save changes button when group/user button switched
			dispatch("enable", false);
		});

		$$self.$$.on_mount.push(function () {
			if (users === undefined && !('users' in $$props || $$self.$$.bound[$$self.$$.props['users']])) {
				console.warn("<ShareCredentialsWithUsers> was created without expected prop 'users'");
			}
		});

		const writable_props = ['users', 'credentialsFields'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ShareCredentialsWithUsers> was created with unknown prop '${key}'`);
		});

		function input_input_handler() {
			searchInput = this.value;
			$$invalidate(1, searchInput);
		}

		const click_handler = index => handleClick(index, false);
		const select_handler = (index, e) => handleRoleChange(e, index, 'users');
		const click_handler_1 = index => handleClick(index, true);
		const remove_handler = index => handleItemRemove(index);
		const select_handler_1 = (index, e) => handleRoleChange(e, index, 'selectedUsers');

		$$self.$$set = $$props => {
			if ('users' in $$props) $$invalidate(9, users = $$props.users);
			if ('credentialsFields' in $$props) $$invalidate(10, credentialsFields = $$props.credentialsFields);
		};

		$$self.$capture_state = () => ({
			createEventDispatcher,
			onMount,
			shareCredentialsWithUsers,
			sendMessage,
			Lens,
			ListItem,
			toastStore,
			dispatch,
			users,
			credentialsFields,
			selectedUsers,
			showOptions,
			selectionIndex,
			topList,
			searchInput,
			shareCredentialHandler,
			handleClick,
			handleItemRemove,
			handleRoleChange,
			filteredUsers
		});

		$$self.$inject_state = $$props => {
			if ('users' in $$props) $$invalidate(9, users = $$props.users);
			if ('credentialsFields' in $$props) $$invalidate(10, credentialsFields = $$props.credentialsFields);
			if ('selectedUsers' in $$props) $$invalidate(0, selectedUsers = $$props.selectedUsers);
			if ('showOptions' in $$props) $$invalidate(2, showOptions = $$props.showOptions);
			if ('selectionIndex' in $$props) $$invalidate(3, selectionIndex = $$props.selectionIndex);
			if ('topList' in $$props) $$invalidate(4, topList = $$props.topList);
			if ('searchInput' in $$props) $$invalidate(1, searchInput = $$props.searchInput);
			if ('filteredUsers' in $$props) $$invalidate(5, filteredUsers = $$props.filteredUsers);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*selectedUsers*/ 1) {
				selectedUsers.length === 0 && dispatch("enable", false);
			}

			if ($$self.$$.dirty & /*searchInput, users*/ 514) {
				$$invalidate(5, filteredUsers = searchInput
				? users.filter(user => user.name.toLowerCase().includes(searchInput.toLowerCase()))
				: users);
			}
		};

		return [
			selectedUsers,
			searchInput,
			showOptions,
			selectionIndex,
			topList,
			filteredUsers,
			handleClick,
			handleItemRemove,
			handleRoleChange,
			users,
			credentialsFields,
			shareCredentialHandler,
			input_input_handler,
			click_handler,
			select_handler,
			click_handler_1,
			remove_handler,
			select_handler_1
		];
	}

	class ShareCredentialsWithUsers extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$L, create_fragment$L, safe_not_equal, {
				users: 9,
				credentialsFields: 10,
				shareCredentialHandler: 11
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ShareCredentialsWithUsers",
				options,
				id: create_fragment$L.name
			});
		}

		get users() {
			throw new Error("<ShareCredentialsWithUsers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set users(value) {
			throw new Error("<ShareCredentialsWithUsers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get credentialsFields() {
			throw new Error("<ShareCredentialsWithUsers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set credentialsFields(value) {
			throw new Error("<ShareCredentialsWithUsers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get shareCredentialHandler() {
			return this.$$.ctx[11];
		}

		set shareCredentialHandler(value) {
			throw new Error("<ShareCredentialsWithUsers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/credentials/ShareCredentialsWithGroups.svelte generated by Svelte v4.2.19 */
	const file$K = "src/lib/components/dashboard/credentials/ShareCredentialsWithGroups.svelte";

	function get_each_context$g(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[21] = list[i][0];
		child_ctx[22] = list[i][1];
		child_ctx[24] = i;
		return child_ctx;
	}

	function get_each_context_1$3(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[22] = list[i];
		child_ctx[24] = i;
		return child_ctx;
	}

	// (112:2) {#each filteredGroups as group, index}
	function create_each_block_1$3(ctx) {
		let listitem;
		let current;

		function click_handler() {
			return /*click_handler*/ ctx[15](/*index*/ ctx[24]);
		}

		function select_handler(...args) {
			return /*select_handler*/ ctx[16](/*index*/ ctx[24], ...args);
		}

		listitem = new ListItem({
				props: {
					item: /*group*/ ctx[22],
					isSelected: /*index*/ ctx[24] === /*selectionIndex*/ ctx[3] && !/*topList*/ ctx[4],
					showOptions: /*showOptions*/ ctx[2],
					reverseModal: /*filteredGroups*/ ctx[5].length > 3 && /*index*/ ctx[24] > /*filteredGroups*/ ctx[5].length - 3
				},
				$$inline: true
			});

		listitem.$on("click", click_handler);
		listitem.$on("select", select_handler);

		const block = {
			c: function create() {
				create_component(listitem.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(listitem, target, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const listitem_changes = {};
				if (dirty & /*filteredGroups*/ 32) listitem_changes.item = /*group*/ ctx[22];
				if (dirty & /*selectionIndex, topList*/ 24) listitem_changes.isSelected = /*index*/ ctx[24] === /*selectionIndex*/ ctx[3] && !/*topList*/ ctx[4];
				if (dirty & /*showOptions*/ 4) listitem_changes.showOptions = /*showOptions*/ ctx[2];
				if (dirty & /*filteredGroups*/ 32) listitem_changes.reverseModal = /*filteredGroups*/ ctx[5].length > 3 && /*index*/ ctx[24] > /*filteredGroups*/ ctx[5].length - 3;
				listitem.$set(listitem_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(listitem.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(listitem.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(listitem, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block_1$3.name,
			type: "each",
			source: "(112:2) {#each filteredGroups as group, index}",
			ctx
		});

		return block;
	}

	// (126:0) {#if $selectedGroups.size !== 0}
	function create_if_block$x(ctx) {
		let div;
		let current;
		let each_value = ensure_array_like_dev(Array.from(/*$selectedGroups*/ ctx[1]));
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(div, "class", "overflow-y-scroll overflow-x-hidden scrollbar-thin h-[8rem] bg-osvauld-frameblack rounded-lg w-full p-0.5 border border-osvauld-iconblack mt-auto !text-osvauld-textActive");
				add_location(div, file$K, 148, 1, 4168);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty & /*Array, $selectedGroups, selectionIndex, topList, showOptions, handleClick, handleItemRemove, handleRoleChange*/ 926) {
					each_value = ensure_array_like_dev(Array.from(/*$selectedGroups*/ ctx[1]));
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$g(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$g(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$x.name,
			type: "if",
			source: "(126:0) {#if $selectedGroups.size !== 0}",
			ctx
		});

		return block;
	}

	// (130:2) {#each Array.from($selectedGroups) as [groupId, group], index}
	function create_each_block$g(ctx) {
		let listitem;
		let current;

		function click_handler_1() {
			return /*click_handler_1*/ ctx[17](/*index*/ ctx[24]);
		}

		function remove_handler() {
			return /*remove_handler*/ ctx[18](/*groupId*/ ctx[21]);
		}

		function select_handler_1(...args) {
			return /*select_handler_1*/ ctx[19](/*index*/ ctx[24], ...args);
		}

		listitem = new ListItem({
				props: {
					item: /*group*/ ctx[22],
					isSelected: /*index*/ ctx[24] === /*selectionIndex*/ ctx[3] && /*topList*/ ctx[4],
					isBottomList: true,
					showOptions: /*showOptions*/ ctx[2],
					reverseModal: /*$selectedGroups*/ ctx[1].size > 3 && /*index*/ ctx[24] > /*$selectedGroups*/ ctx[1].size - 3
				},
				$$inline: true
			});

		listitem.$on("click", click_handler_1);
		listitem.$on("remove", remove_handler);
		listitem.$on("select", select_handler_1);

		const block = {
			c: function create() {
				create_component(listitem.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(listitem, target, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const listitem_changes = {};
				if (dirty & /*$selectedGroups*/ 2) listitem_changes.item = /*group*/ ctx[22];
				if (dirty & /*selectionIndex, topList*/ 24) listitem_changes.isSelected = /*index*/ ctx[24] === /*selectionIndex*/ ctx[3] && /*topList*/ ctx[4];
				if (dirty & /*showOptions*/ 4) listitem_changes.showOptions = /*showOptions*/ ctx[2];
				if (dirty & /*$selectedGroups*/ 2) listitem_changes.reverseModal = /*$selectedGroups*/ ctx[1].size > 3 && /*index*/ ctx[24] > /*$selectedGroups*/ ctx[1].size - 3;
				listitem.$set(listitem_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(listitem.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(listitem.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(listitem, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$g.name,
			type: "each",
			source: "(130:2) {#each Array.from($selectedGroups) as [groupId, group], index}",
			ctx
		});

		return block;
	}

	function create_fragment$K(ctx) {
		let div2;
		let div0;
		let lens;
		let t0;
		let input;
		let t1;
		let div1;
		let t2;
		let if_block_anchor;
		let current;
		let mounted;
		let dispose;
		lens = new Lens({ $$inline: true });
		let each_value_1 = ensure_array_like_dev(/*filteredGroups*/ ctx[5]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let if_block = /*$selectedGroups*/ ctx[1].size !== 0 && create_if_block$x(ctx);

		const block = {
			c: function create() {
				div2 = element("div");
				div0 = element("div");
				create_component(lens.$$.fragment);
				t0 = space();
				input = element("input");
				t1 = space();
				div1 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t2 = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
				attr_dev(input, "type", "text");
				attr_dev(input, "class", "h-[1.60rem] w-full bg-osvauld-frameblack border-0 text-osvauld-quarzowhite placeholder-osvauld-placeholderblack border-transparent text-base focus:border-transparent focus:ring-0 cursor-pointer");
				attr_dev(input, "placeholder", "");
				add_location(input, file$K, 122, 2, 3375);
				attr_dev(div0, "class", "h-[1.875rem] w-full px-2 mx-auto flex justify-start items-center cursor-pointer border rounded-lg border-osvauld-iconblack");
				add_location(div0, file$K, 118, 1, 3221);
				attr_dev(div1, "class", "overflow-y-scroll scrollbar-thin h-[20rem] bg-osvauld-frameblack w-full");
				add_location(div1, file$K, 130, 1, 3665);
				attr_dev(div2, "class", "p-2 pl-2 rounded-lg w-full");
				add_location(div2, file$K, 117, 0, 3179);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div2, anchor);
				append_dev(div2, div0);
				mount_component(lens, div0, null);
				append_dev(div0, t0);
				append_dev(div0, input);
				set_input_value(input, /*searchInput*/ ctx[0]);
				append_dev(div2, t1);
				append_dev(div2, div1);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div1, null);
					}
				}

				insert_dev(target, t2, anchor);
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;

				if (!mounted) {
					dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[14]);
					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*searchInput*/ 1 && input.value !== /*searchInput*/ ctx[0]) {
					set_input_value(input, /*searchInput*/ ctx[0]);
				}

				if (dirty & /*filteredGroups, selectionIndex, topList, showOptions, handleClick, handleRoleChange*/ 700) {
					each_value_1 = ensure_array_like_dev(/*filteredGroups*/ ctx[5]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1$3(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div1, null);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (/*$selectedGroups*/ ctx[1].size !== 0) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*$selectedGroups*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$x(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(lens.$$.fragment, local);

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(lens.$$.fragment, local);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div2);
					detach_dev(t2);
					detach_dev(if_block_anchor);
				}

				destroy_component(lens);
				destroy_each(each_blocks, detaching);
				if (if_block) if_block.d(detaching);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$K.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$K($$self, $$props, $$invalidate) {
		let filteredGroups;
		let $selectedGroups;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ShareCredentialsWithGroups', slots, []);
		const dispatch = createEventDispatcher();
		let { allGroups } = $$props;

		let { groups = allGroups.map(group => {
			return { groupId: group.groupId, name: group.name };
		}) } = $$props;

		let { credentialsFields = [] } = $$props;
		let selectedGroups = writable(new Map());
		validate_store(selectedGroups, 'selectedGroups');
		component_subscribe($$self, selectedGroups, value => $$invalidate(1, $selectedGroups = value));
		let showOptions = false;
		let selectionIndex = null;
		let topList = false;
		let searchInput = "";

		const shareCredentialHandler = async () => {
			const groupIds = Array.from($selectedGroups.keys());
			const response = await fetchUsersByGroupIds(groupIds);
			const groupUsersList = response.data;
			const payload = { groupData: [] };

			for (const groupUsers of groupUsersList) {
				const group = $selectedGroups.get(groupUsers.groupId);
				if (group == undefined || !group.accessType) continue;

				const userData = await sendMessage("createShareCredPayload", {
					creds: credentialsFields,
					users: groupUsers.userDetails
				});

				payload.groupData.push({
					groupId: group.groupId,
					accessType: group.accessType,
					userData
				});
			}

			const shareStatus = await shareCredentialsWithGroups(payload);

			toastStore.set({
				type: shareStatus.success,
				message: shareStatus.message,
				show: true
			});

			dispatch("cancel", true);
		};

		function handleClick(index, isSelectedList) {
			$$invalidate(2, showOptions = !showOptions);
			$$invalidate(3, selectionIndex = index);
			$$invalidate(4, topList = isSelectedList);
		}

		function handleItemRemove(id) {
			let removedGroup;

			selectedGroups.update(currentGroups => {
				if (currentGroups.has(id)) {
					removedGroup = currentGroups.get(id);
					currentGroups.delete(id);
				}

				return currentGroups;
			});

			if (removedGroup) {
				$$invalidate(10, groups = [...groups, { ...removedGroup }]);
			}
		}

		function handleRoleChange(e, index, type) {
			const item = e.detail.item;
			const option = e.detail.permission;
			$$invalidate(2, showOptions = !showOptions);
			$$invalidate(3, selectionIndex = null);

			if (type === "selectedGroups") {
				selectedGroups.update(currentGroups => {
					currentGroups.set(item.groupId, { ...item, accessType: option });
					return currentGroups;
				});
			} else {
				$selectedGroups.set(item.groupId, { ...item, accessType: option });
				$$invalidate(10, groups = groups.filter(u => u.groupId !== item.groupId));
			}

			$selectedGroups.size !== 0 && dispatch("enable", true);
		}

		onMount(() => {
			//Below will disable save changes button when group/user button switched
			dispatch("enable", false);
		});

		$$self.$$.on_mount.push(function () {
			if (allGroups === undefined && !('allGroups' in $$props || $$self.$$.bound[$$self.$$.props['allGroups']])) {
				console.warn("<ShareCredentialsWithGroups> was created without expected prop 'allGroups'");
			}
		});

		const writable_props = ['allGroups', 'groups', 'credentialsFields'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ShareCredentialsWithGroups> was created with unknown prop '${key}'`);
		});

		function input_input_handler() {
			searchInput = this.value;
			$$invalidate(0, searchInput);
		}

		const click_handler = index => handleClick(index, false);
		const select_handler = (index, e) => handleRoleChange(e, index, 'groups');
		const click_handler_1 = index => handleClick(index, true);
		const remove_handler = groupId => handleItemRemove(groupId);
		const select_handler_1 = (index, e) => handleRoleChange(e, index, 'selectedGroups');

		$$self.$$set = $$props => {
			if ('allGroups' in $$props) $$invalidate(11, allGroups = $$props.allGroups);
			if ('groups' in $$props) $$invalidate(10, groups = $$props.groups);
			if ('credentialsFields' in $$props) $$invalidate(12, credentialsFields = $$props.credentialsFields);
		};

		$$self.$capture_state = () => ({
			writable,
			fetchUsersByGroupIds,
			shareCredentialsWithGroups,
			sendMessage,
			Lens,
			ListItem,
			toastStore,
			createEventDispatcher,
			onMount,
			dispatch,
			allGroups,
			groups,
			credentialsFields,
			selectedGroups,
			showOptions,
			selectionIndex,
			topList,
			searchInput,
			shareCredentialHandler,
			handleClick,
			handleItemRemove,
			handleRoleChange,
			filteredGroups,
			$selectedGroups
		});

		$$self.$inject_state = $$props => {
			if ('allGroups' in $$props) $$invalidate(11, allGroups = $$props.allGroups);
			if ('groups' in $$props) $$invalidate(10, groups = $$props.groups);
			if ('credentialsFields' in $$props) $$invalidate(12, credentialsFields = $$props.credentialsFields);
			if ('selectedGroups' in $$props) $$invalidate(6, selectedGroups = $$props.selectedGroups);
			if ('showOptions' in $$props) $$invalidate(2, showOptions = $$props.showOptions);
			if ('selectionIndex' in $$props) $$invalidate(3, selectionIndex = $$props.selectionIndex);
			if ('topList' in $$props) $$invalidate(4, topList = $$props.topList);
			if ('searchInput' in $$props) $$invalidate(0, searchInput = $$props.searchInput);
			if ('filteredGroups' in $$props) $$invalidate(5, filteredGroups = $$props.filteredGroups);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$selectedGroups*/ 2) {
				$selectedGroups.size == 0 && dispatch("enable", false);
			}

			if ($$self.$$.dirty & /*searchInput, groups*/ 1025) {
				$$invalidate(5, filteredGroups = searchInput
				? groups.filter(group => group.name.toLowerCase().includes(searchInput.toLowerCase()))
				: groups);
			}
		};

		return [
			searchInput,
			$selectedGroups,
			showOptions,
			selectionIndex,
			topList,
			filteredGroups,
			selectedGroups,
			handleClick,
			handleItemRemove,
			handleRoleChange,
			groups,
			allGroups,
			credentialsFields,
			shareCredentialHandler,
			input_input_handler,
			click_handler,
			select_handler,
			click_handler_1,
			remove_handler,
			select_handler_1
		];
	}

	class ShareCredentialsWithGroups extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$K, create_fragment$K, safe_not_equal, {
				allGroups: 11,
				groups: 10,
				credentialsFields: 12,
				shareCredentialHandler: 13
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ShareCredentialsWithGroups",
				options,
				id: create_fragment$K.name
			});
		}

		get allGroups() {
			throw new Error("<ShareCredentialsWithGroups>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set allGroups(value) {
			throw new Error("<ShareCredentialsWithGroups>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get groups() {
			throw new Error("<ShareCredentialsWithGroups>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set groups(value) {
			throw new Error("<ShareCredentialsWithGroups>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get credentialsFields() {
			throw new Error("<ShareCredentialsWithGroups>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set credentialsFields(value) {
			throw new Error("<ShareCredentialsWithGroups>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get shareCredentialHandler() {
			return this.$$.ctx[13];
		}

		set shareCredentialHandler(value) {
			throw new Error("<ShareCredentialsWithGroups>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/credentials/ShareCredentialModal.svelte generated by Svelte v4.2.19 */
	const file$J = "src/lib/components/dashboard/credentials/ShareCredentialModal.svelte";

	// (60:2) {#if showInfoTab}
	function create_if_block_2$i(ctx) {
		let div;
		let span;
		let infoicon;
		let t0;
		let p;
		let t2;
		let infooverlay;
		let div_class_value;
		let current;
		infoicon = new InfoIcon({ $$inline: true });
		infooverlay = new Info({ $$inline: true });

		const block = {
			c: function create() {
				div = element("div");
				span = element("span");
				create_component(infoicon.$$.fragment);
				t0 = space();
				p = element("p");
				p.textContent = "Select groups/users and choose access type";
				t2 = space();
				create_component(infooverlay.$$.fragment);
				attr_dev(span, "class", "");
				add_location(span, file$J, 79, 4, 2187);
				attr_dev(p, "class", "whitespace-nowrap text-base font-normal text-osvauld-highlightwhite");
				add_location(p, file$J, 82, 4, 2237);
				attr_dev(div, "class", div_class_value = "relative h-[1.875rem] w-full px-4 py-2 mx-auto flex justify-between items-center border border-osvauld-bordergreen rounded-lg cursor-pointer mb-3 hover:bg-osvauld-bordergreen " + (/*showInfoTab*/ ctx[3] ? 'bg-osvauld-bordergreen' : ''));
				add_location(div, file$J, 74, 3, 1930);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, span);
				mount_component(infoicon, span, null);
				append_dev(div, t0);
				append_dev(div, p);
				append_dev(div, t2);
				mount_component(infooverlay, div, null);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (!current || dirty & /*showInfoTab*/ 8 && div_class_value !== (div_class_value = "relative h-[1.875rem] w-full px-4 py-2 mx-auto flex justify-between items-center border border-osvauld-bordergreen rounded-lg cursor-pointer mb-3 hover:bg-osvauld-bordergreen " + (/*showInfoTab*/ ctx[3] ? 'bg-osvauld-bordergreen' : ''))) {
					attr_dev(div, "class", div_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(infoicon.$$.fragment, local);
				transition_in(infooverlay.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(infoicon.$$.fragment, local);
				transition_out(infooverlay.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(infoicon);
				destroy_component(infooverlay);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$i.name,
			type: "if",
			source: "(60:2) {#if showInfoTab}",
			ctx
		});

		return block;
	}

	// (94:37) 
	function create_if_block_1$p(ctx) {
		let sharecredentialswithgroups;
		let current;

		let sharecredentialswithgroups_props = {
			allGroups: /*groups*/ ctx[1],
			credentialsFields: /*credentialsFields*/ ctx[2]
		};

		sharecredentialswithgroups = new ShareCredentialsWithGroups({
				props: sharecredentialswithgroups_props,
				$$inline: true
			});

		/*sharecredentialswithgroups_binding*/ ctx[17](sharecredentialswithgroups);
		sharecredentialswithgroups.$on("cancel", /*cancel_handler_1*/ ctx[18]);
		sharecredentialswithgroups.$on("enable", /*enable_handler_1*/ ctx[19]);

		const block = {
			c: function create() {
				create_component(sharecredentialswithgroups.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(sharecredentialswithgroups, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const sharecredentialswithgroups_changes = {};
				if (dirty & /*groups*/ 2) sharecredentialswithgroups_changes.allGroups = /*groups*/ ctx[1];
				if (dirty & /*credentialsFields*/ 4) sharecredentialswithgroups_changes.credentialsFields = /*credentialsFields*/ ctx[2];
				sharecredentialswithgroups.$set(sharecredentialswithgroups_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(sharecredentialswithgroups.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(sharecredentialswithgroups.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				/*sharecredentialswithgroups_binding*/ ctx[17](null);
				destroy_component(sharecredentialswithgroups, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$p.name,
			type: "if",
			source: "(94:37) ",
			ctx
		});

		return block;
	}

	// (86:3) {#if selectedTab === "Users"}
	function create_if_block$w(ctx) {
		let sharecredentialswithuser;
		let current;

		let sharecredentialswithuser_props = {
			users: /*users*/ ctx[0],
			credentialsFields: /*credentialsFields*/ ctx[2]
		};

		sharecredentialswithuser = new ShareCredentialsWithUsers({
				props: sharecredentialswithuser_props,
				$$inline: true
			});

		/*sharecredentialswithuser_binding*/ ctx[14](sharecredentialswithuser);
		sharecredentialswithuser.$on("cancel", /*cancel_handler*/ ctx[15]);
		sharecredentialswithuser.$on("enable", /*enable_handler*/ ctx[16]);

		const block = {
			c: function create() {
				create_component(sharecredentialswithuser.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(sharecredentialswithuser, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const sharecredentialswithuser_changes = {};
				if (dirty & /*users*/ 1) sharecredentialswithuser_changes.users = /*users*/ ctx[0];
				if (dirty & /*credentialsFields*/ 4) sharecredentialswithuser_changes.credentialsFields = /*credentialsFields*/ ctx[2];
				sharecredentialswithuser.$set(sharecredentialswithuser_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(sharecredentialswithuser.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(sharecredentialswithuser.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				/*sharecredentialswithuser_binding*/ ctx[14](null);
				destroy_component(sharecredentialswithuser, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$w.name,
			type: "if",
			source: "(86:3) {#if selectedTab === \\\"Users\\\"}",
			ctx
		});

		return block;
	}

	function create_fragment$J(ctx) {
		let div6;
		let div5;
		let div0;
		let span1;
		let span0;
		let t1;
		let button0;
		let infoicon;
		let t2;
		let button1;
		let closepanel;
		let t3;
		let t4;
		let div1;
		let t5;
		let div2;
		let toggle;
		let t6;
		let current_block_type_index;
		let if_block1;
		let t7;
		let div3;
		let t8;
		let div4;
		let button2;
		let t10;
		let button3;
		let t11;
		let button3_class_value;
		let button3_disabled_value;
		let div6_intro;
		let div6_outro;
		let current;
		let mounted;
		let dispose;

		infoicon = new InfoIcon({
				props: {
					color: /*infoOnHover*/ ctx[4] ? '#BFC0CC' : '#4D4F60'
				},
				$$inline: true
			});

		closepanel = new ClosePanel({ $$inline: true });
		let if_block0 = /*showInfoTab*/ ctx[3] && create_if_block_2$i(ctx);
		toggle = new Toggle({ $$inline: true });
		toggle.$on("select", /*toggleSelect*/ ctx[8]);
		const if_block_creators = [create_if_block$w, create_if_block_1$p];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*selectedTab*/ ctx[7] === "Users") return 0;
			if (/*selectedTab*/ ctx[7] == "Groups") return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		const block = {
			c: function create() {
				div6 = element("div");
				div5 = element("div");
				div0 = element("div");
				span1 = element("span");
				span0 = element("span");
				span0.textContent = "Share Credentials";
				t1 = space();
				button0 = element("button");
				create_component(infoicon.$$.fragment);
				t2 = space();
				button1 = element("button");
				create_component(closepanel.$$.fragment);
				t3 = space();
				if (if_block0) if_block0.c();
				t4 = space();
				div1 = element("div");
				t5 = space();
				div2 = element("div");
				create_component(toggle.$$.fragment);
				t6 = space();
				if (if_block1) if_block1.c();
				t7 = space();
				div3 = element("div");
				t8 = space();
				div4 = element("div");
				button2 = element("button");
				button2.textContent = "Cancel";
				t10 = space();
				button3 = element("button");
				t11 = text("Save changes");
				add_location(span0, file$J, 57, 4, 1472);
				attr_dev(button0, "class", "ml-2");
				add_location(button0, file$J, 58, 4, 1507);
				attr_dev(span1, "class", "font-sans text-white text-xl font-normal flex justify-between items-center");
				add_location(span1, file$J, 54, 3, 1370);
				attr_dev(button1, "class", "p-2");
				add_location(button1, file$J, 66, 3, 1780);
				attr_dev(div0, "class", "flex justify-between items-center p-3");
				add_location(div0, file$J, 53, 2, 1315);
				attr_dev(div1, "class", "border-b mt-2 mb-4 border-osvauld-iconblack w-[calc(100%+2.8rem)] -translate-x-3");
				add_location(div1, file$J, 91, 2, 2425);
				attr_dev(div2, "class", "flex flex-col justify-start items-center overflow-hidden h-full");
				add_location(div2, file$J, 95, 2, 2535);
				attr_dev(div3, "class", "border-b mt-2 mb-4 border-osvauld-iconblack w-[calc(100%+2.8rem)] -translate-x-3");
				add_location(div3, file$J, 117, 2, 3204);
				attr_dev(button2, "class", "ml-auto p-2 whitespace-nowrap text-sm font-medium text-osvauld-fadedCancel");
				add_location(button2, file$J, 121, 3, 3387);

				attr_dev(button3, "class", button3_class_value = "ml-4 px-3 py-2 whitespace-nowrap text-sm font-medium rounded-md " + (/*saveEnabled*/ ctx[6]
				? 'bg-osvauld-carolinablue text-osvauld-frameblack border-transparent'
				: 'border border-osvauld-iconblack text-osvauld-textActive'));

				button3.disabled = button3_disabled_value = !/*saveEnabled*/ ctx[6];
				add_location(button3, file$J, 126, 3, 3566);
				attr_dev(div4, "class", "p-2 w-full flex justify-end items-center box-border mt-4");
				add_location(div4, file$J, 120, 2, 3313);
				attr_dev(div5, "class", "w-[28rem] h-screen shadow-xl translate-x-0 bg-osvauld-frameblack py-6 px-3 flex flex-col");
				add_location(div5, file$J, 50, 1, 1206);
				attr_dev(div6, "class", "fixed top-0 right-0 z-50 flex justify-end rounded-xl blur-none");
				add_location(div6, file$J, 45, 0, 1109);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div6, anchor);
				append_dev(div6, div5);
				append_dev(div5, div0);
				append_dev(div0, span1);
				append_dev(span1, span0);
				append_dev(span1, t1);
				append_dev(span1, button0);
				mount_component(infoicon, button0, null);
				append_dev(div0, t2);
				append_dev(div0, button1);
				mount_component(closepanel, button1, null);
				append_dev(div5, t3);
				if (if_block0) if_block0.m(div5, null);
				append_dev(div5, t4);
				append_dev(div5, div1);
				append_dev(div5, t5);
				append_dev(div5, div2);
				mount_component(toggle, div2, null);
				append_dev(div2, t6);

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(div2, null);
				}

				append_dev(div5, t7);
				append_dev(div5, div3);
				append_dev(div5, t8);
				append_dev(div5, div4);
				append_dev(div4, button2);
				append_dev(div4, t10);
				append_dev(div4, button3);
				append_dev(button3, t11);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "mouseenter", /*mouseenter_handler*/ ctx[10], false, false, false, false),
						listen_dev(button0, "mouseleave", /*mouseleave_handler*/ ctx[11], false, false, false, false),
						listen_dev(button0, "click", /*click_handler*/ ctx[12], false, false, false, false),
						listen_dev(button1, "click", /*click_handler_1*/ ctx[13], false, false, false, false),
						listen_dev(button2, "click", /*click_handler_2*/ ctx[20], false, false, false, false),
						listen_dev(button3, "click", /*click_handler_3*/ ctx[21], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				const infoicon_changes = {};
				if (dirty & /*infoOnHover*/ 16) infoicon_changes.color = /*infoOnHover*/ ctx[4] ? '#BFC0CC' : '#4D4F60';
				infoicon.$set(infoicon_changes);

				if (/*showInfoTab*/ ctx[3]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*showInfoTab*/ 8) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_2$i(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div5, t4);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) {
						if_blocks[current_block_type_index].p(ctx, dirty);
					}
				} else {
					if (if_block1) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block1 = if_blocks[current_block_type_index];

						if (!if_block1) {
							if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block1.c();
						} else {
							if_block1.p(ctx, dirty);
						}

						transition_in(if_block1, 1);
						if_block1.m(div2, null);
					} else {
						if_block1 = null;
					}
				}

				if (!current || dirty & /*saveEnabled*/ 64 && button3_class_value !== (button3_class_value = "ml-4 px-3 py-2 whitespace-nowrap text-sm font-medium rounded-md " + (/*saveEnabled*/ ctx[6]
				? 'bg-osvauld-carolinablue text-osvauld-frameblack border-transparent'
				: 'border border-osvauld-iconblack text-osvauld-textActive'))) {
					attr_dev(button3, "class", button3_class_value);
				}

				if (!current || dirty & /*saveEnabled*/ 64 && button3_disabled_value !== (button3_disabled_value = !/*saveEnabled*/ ctx[6])) {
					prop_dev(button3, "disabled", button3_disabled_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(infoicon.$$.fragment, local);
				transition_in(closepanel.$$.fragment, local);
				transition_in(if_block0);
				transition_in(toggle.$$.fragment, local);
				transition_in(if_block1);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (div6_outro) div6_outro.end(1);
						div6_intro = create_in_transition(div6, fly, {});
						div6_intro.start();
					});
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(infoicon.$$.fragment, local);
				transition_out(closepanel.$$.fragment, local);
				transition_out(if_block0);
				transition_out(toggle.$$.fragment, local);
				transition_out(if_block1);
				if (div6_intro) div6_intro.invalidate();

				if (local) {
					div6_outro = create_out_transition(div6, fly, {});
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div6);
				}

				destroy_component(infoicon);
				destroy_component(closepanel);
				if (if_block0) if_block0.d();
				destroy_component(toggle);

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d();
				}

				if (detaching && div6_outro) div6_outro.end();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$J.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$J($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ShareCredentialModal', slots, []);
		let { credentials } = $$props;
		let { users } = $$props;
		let { groups } = $$props;
		let credentialsFields = [];
		let showInfoTab = false;
		let infoOnHover = false;
		let saveChanges;
		let saveEnabled = false;
		const credIds = credentials.map(cred => cred.credentialId);

		onMount(async () => {
			const responseJson = await fetchCredentialsFieldsByIds(credIds);
			$$invalidate(2, credentialsFields = responseJson.data);
			modalManager.set(null);
		});

		let selectedTab = "Groups";

		const toggleSelect = e => {
			$$invalidate(7, selectedTab = e.detail);
		};

		$$self.$$.on_mount.push(function () {
			if (credentials === undefined && !('credentials' in $$props || $$self.$$.bound[$$self.$$.props['credentials']])) {
				console.warn("<ShareCredentialModal> was created without expected prop 'credentials'");
			}

			if (users === undefined && !('users' in $$props || $$self.$$.bound[$$self.$$.props['users']])) {
				console.warn("<ShareCredentialModal> was created without expected prop 'users'");
			}

			if (groups === undefined && !('groups' in $$props || $$self.$$.bound[$$self.$$.props['groups']])) {
				console.warn("<ShareCredentialModal> was created without expected prop 'groups'");
			}
		});

		const writable_props = ['credentials', 'users', 'groups'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ShareCredentialModal> was created with unknown prop '${key}'`);
		});

		const mouseenter_handler = () => $$invalidate(4, infoOnHover = true);
		const mouseleave_handler = () => $$invalidate(4, infoOnHover = false);
		const click_handler = () => $$invalidate(3, showInfoTab = !showInfoTab);
		const click_handler_1 = () => showCredentialShareDrawer.set(false);

		function sharecredentialswithuser_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				saveChanges = $$value;
				$$invalidate(5, saveChanges);
			});
		}

		const cancel_handler = () => showCredentialShareDrawer.set(false);
		const enable_handler = e => $$invalidate(6, saveEnabled = e.detail);

		function sharecredentialswithgroups_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				saveChanges = $$value;
				$$invalidate(5, saveChanges);
			});
		}

		const cancel_handler_1 = () => showCredentialShareDrawer.set(false);
		const enable_handler_1 = e => $$invalidate(6, saveEnabled = e.detail);
		const click_handler_2 = () => showCredentialShareDrawer.set(false);
		const click_handler_3 = () => saveChanges.shareCredentialHandler();

		$$self.$$set = $$props => {
			if ('credentials' in $$props) $$invalidate(9, credentials = $$props.credentials);
			if ('users' in $$props) $$invalidate(0, users = $$props.users);
			if ('groups' in $$props) $$invalidate(1, groups = $$props.groups);
		};

		$$self.$capture_state = () => ({
			fly,
			onMount,
			showCredentialShareDrawer,
			modalManager,
			fetchCredentialsFieldsByIds,
			Toggle,
			ShareCredentialsWithUser: ShareCredentialsWithUsers,
			ShareCredentialsWithGroups,
			InfoIcon,
			InfoOverlay: Info,
			ClosePanel,
			credentials,
			users,
			groups,
			credentialsFields,
			showInfoTab,
			infoOnHover,
			saveChanges,
			saveEnabled,
			credIds,
			selectedTab,
			toggleSelect
		});

		$$self.$inject_state = $$props => {
			if ('credentials' in $$props) $$invalidate(9, credentials = $$props.credentials);
			if ('users' in $$props) $$invalidate(0, users = $$props.users);
			if ('groups' in $$props) $$invalidate(1, groups = $$props.groups);
			if ('credentialsFields' in $$props) $$invalidate(2, credentialsFields = $$props.credentialsFields);
			if ('showInfoTab' in $$props) $$invalidate(3, showInfoTab = $$props.showInfoTab);
			if ('infoOnHover' in $$props) $$invalidate(4, infoOnHover = $$props.infoOnHover);
			if ('saveChanges' in $$props) $$invalidate(5, saveChanges = $$props.saveChanges);
			if ('saveEnabled' in $$props) $$invalidate(6, saveEnabled = $$props.saveEnabled);
			if ('selectedTab' in $$props) $$invalidate(7, selectedTab = $$props.selectedTab);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			users,
			groups,
			credentialsFields,
			showInfoTab,
			infoOnHover,
			saveChanges,
			saveEnabled,
			selectedTab,
			toggleSelect,
			credentials,
			mouseenter_handler,
			mouseleave_handler,
			click_handler,
			click_handler_1,
			sharecredentialswithuser_binding,
			cancel_handler,
			enable_handler,
			sharecredentialswithgroups_binding,
			cancel_handler_1,
			enable_handler_1,
			click_handler_2,
			click_handler_3
		];
	}

	class ShareCredentialModal extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$J, create_fragment$J, safe_not_equal, { credentials: 9, users: 0, groups: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ShareCredentialModal",
				options,
				id: create_fragment$J.name
			});
		}

		get credentials() {
			throw new Error("<ShareCredentialModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set credentials(value) {
			throw new Error("<ShareCredentialModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get users() {
			throw new Error("<ShareCredentialModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set users(value) {
			throw new Error("<ShareCredentialModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get groups() {
			throw new Error("<ShareCredentialModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set groups(value) {
			throw new Error("<ShareCredentialModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/**
	 * A JavaScript implementation of the SHA family of hashes - defined in FIPS PUB 180-4, FIPS PUB 202,
	 * and SP 800-185 - as well as the corresponding HMAC implementation as defined in FIPS PUB 198-1.
	 *
	 * Copyright 2008-2023 Brian Turek, 1998-2009 Paul Johnston & Contributors
	 * Distributed under the BSD License
	 * See http://caligatio.github.com/jsSHA/ for more information
	 */
	const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",n="ARRAYBUFFER not supported by this environment",e="UINT8ARRAY not supported by this environment";function r(t,n,e,r){let i,s,o;const h=n||[0],u=(e=e||0)>>>3,w=-1===r?3:0;for(i=0;i<t.length;i+=1)o=i+u,s=o>>>2,h.length<=s&&h.push(0),h[s]|=t[i]<<8*(w+r*(o%4));return {value:h,binLen:8*t.length+e}}function i(i,s,o){switch(s){case"UTF8":case"UTF16BE":case"UTF16LE":break;default:throw new Error("encoding must be UTF8, UTF16BE, or UTF16LE")}switch(i){case"HEX":return function(t,n,e){return function(t,n,e,r){let i,s,o,h;if(0!=t.length%2)throw new Error("String of HEX type must be in byte increments");const u=n||[0],w=(e=e||0)>>>3,c=-1===r?3:0;for(i=0;i<t.length;i+=2){if(s=parseInt(t.substr(i,2),16),isNaN(s))throw new Error("String of HEX type contains invalid characters");for(h=(i>>>1)+w,o=h>>>2;u.length<=o;)u.push(0);u[o]|=s<<8*(c+r*(h%4));}return {value:u,binLen:4*t.length+e}}(t,n,e,o)};case"TEXT":return function(t,n,e){return function(t,n,e,r,i){let s,o,h,u,w,c,f,a,l=0;const A=e||[0],E=(r=r||0)>>>3;if("UTF8"===n)for(f=-1===i?3:0,h=0;h<t.length;h+=1)for(s=t.charCodeAt(h),o=[],128>s?o.push(s):2048>s?(o.push(192|s>>>6),o.push(128|63&s)):55296>s||57344<=s?o.push(224|s>>>12,128|s>>>6&63,128|63&s):(h+=1,s=65536+((1023&s)<<10|1023&t.charCodeAt(h)),o.push(240|s>>>18,128|s>>>12&63,128|s>>>6&63,128|63&s)),u=0;u<o.length;u+=1){for(c=l+E,w=c>>>2;A.length<=w;)A.push(0);A[w]|=o[u]<<8*(f+i*(c%4)),l+=1;}else for(f=-1===i?2:0,a="UTF16LE"===n&&1!==i||"UTF16LE"!==n&&1===i,h=0;h<t.length;h+=1){for(s=t.charCodeAt(h),!0===a&&(u=255&s,s=u<<8|s>>>8),c=l+E,w=c>>>2;A.length<=w;)A.push(0);A[w]|=s<<8*(f+i*(c%4)),l+=2;}return {value:A,binLen:8*l+r}}(t,s,n,e,o)};case"B64":return function(n,e,r){return function(n,e,r,i){let s,o,h,u,w,c,f,a=0;const l=e||[0],A=(r=r||0)>>>3,E=-1===i?3:0,H=n.indexOf("=");if(-1===n.search(/^[a-zA-Z0-9=+/]+$/))throw new Error("Invalid character in base-64 string");if(n=n.replace(/=/g,""),-1!==H&&H<n.length)throw new Error("Invalid '=' found in base-64 string");for(o=0;o<n.length;o+=4){for(w=n.substr(o,4),u=0,h=0;h<w.length;h+=1)s=t.indexOf(w.charAt(h)),u|=s<<18-6*h;for(h=0;h<w.length-1;h+=1){for(f=a+A,c=f>>>2;l.length<=c;)l.push(0);l[c]|=(u>>>16-8*h&255)<<8*(E+i*(f%4)),a+=1;}}return {value:l,binLen:8*a+r}}(n,e,r,o)};case"BYTES":return function(t,n,e){return function(t,n,e,r){let i,s,o,h;const u=n||[0],w=(e=e||0)>>>3,c=-1===r?3:0;for(s=0;s<t.length;s+=1)i=t.charCodeAt(s),h=s+w,o=h>>>2,u.length<=o&&u.push(0),u[o]|=i<<8*(c+r*(h%4));return {value:u,binLen:8*t.length+e}}(t,n,e,o)};case"ARRAYBUFFER":try{new ArrayBuffer(0);}catch(t){throw new Error(n)}return function(t,n,e){return function(t,n,e,i){return r(new Uint8Array(t),n,e,i)}(t,n,e,o)};case"UINT8ARRAY":try{new Uint8Array(0);}catch(t){throw new Error(e)}return function(t,n,e){return r(t,n,e,o)};default:throw new Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")}}function s(r,i,s,o){switch(r){case"HEX":return function(t){return function(t,n,e,r){const i="0123456789abcdef";let s,o,h="";const u=n/8,w=-1===e?3:0;for(s=0;s<u;s+=1)o=t[s>>>2]>>>8*(w+e*(s%4)),h+=i.charAt(o>>>4&15)+i.charAt(15&o);return r.outputUpper?h.toUpperCase():h}(t,i,s,o)};case"B64":return function(n){return function(n,e,r,i){let s,o,h,u,w,c="";const f=e/8,a=-1===r?3:0;for(s=0;s<f;s+=3)for(u=s+1<f?n[s+1>>>2]:0,w=s+2<f?n[s+2>>>2]:0,h=(n[s>>>2]>>>8*(a+r*(s%4))&255)<<16|(u>>>8*(a+r*((s+1)%4))&255)<<8|w>>>8*(a+r*((s+2)%4))&255,o=0;o<4;o+=1)c+=8*s+6*o<=e?t.charAt(h>>>6*(3-o)&63):i.b64Pad;return c}(n,i,s,o)};case"BYTES":return function(t){return function(t,n,e){let r,i,s="";const o=n/8,h=-1===e?3:0;for(r=0;r<o;r+=1)i=t[r>>>2]>>>8*(h+e*(r%4))&255,s+=String.fromCharCode(i);return s}(t,i,s)};case"ARRAYBUFFER":try{new ArrayBuffer(0);}catch(t){throw new Error(n)}return function(t){return function(t,n,e){let r;const i=n/8,s=new ArrayBuffer(i),o=new Uint8Array(s),h=-1===e?3:0;for(r=0;r<i;r+=1)o[r]=t[r>>>2]>>>8*(h+e*(r%4))&255;return s}(t,i,s)};case"UINT8ARRAY":try{new Uint8Array(0);}catch(t){throw new Error(e)}return function(t){return function(t,n,e){let r;const i=n/8,s=-1===e?3:0,o=new Uint8Array(i);for(r=0;r<i;r+=1)o[r]=t[r>>>2]>>>8*(s+e*(r%4))&255;return o}(t,i,s)};default:throw new Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")}}const o=4294967296,h=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],u=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428],w=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],c="Chosen SHA variant is not supported",f="Cannot set numRounds with MAC";function a(t,n){let e,r;const i=t.binLen>>>3,s=n.binLen>>>3,o=i<<3,h=4-i<<3;if(i%4!=0){for(e=0;e<s;e+=4)r=i+e>>>2,t.value[r]|=n.value[e>>>2]<<o,t.value.push(0),t.value[r+1]|=n.value[e>>>2]>>>h;return (t.value.length<<2)-4>=s+i&&t.value.pop(),{value:t.value,binLen:t.binLen+n.binLen}}return {value:t.value.concat(n.value),binLen:t.binLen+n.binLen}}function l(t){const n={outputUpper:!1,b64Pad:"=",outputLen:-1},e=t||{},r="Output length must be a multiple of 8";if(n.outputUpper=e.outputUpper||!1,e.b64Pad&&(n.b64Pad=e.b64Pad),e.outputLen){if(e.outputLen%8!=0)throw new Error(r);n.outputLen=e.outputLen;}else if(e.shakeLen){if(e.shakeLen%8!=0)throw new Error(r);n.outputLen=e.shakeLen;}if("boolean"!=typeof n.outputUpper)throw new Error("Invalid outputUpper formatting option");if("string"!=typeof n.b64Pad)throw new Error("Invalid b64Pad formatting option");return n}function A(t,n,e,r){const s=t+" must include a value and format";if(!n){if(!r)throw new Error(s);return r}if(void 0===n.value||!n.format)throw new Error(s);return i(n.format,n.encoding||"UTF8",e)(n.value)}class E{constructor(t,n,e){const r=e||{};if(this.t=n,this.i=r.encoding||"UTF8",this.numRounds=r.numRounds||1,isNaN(this.numRounds)||this.numRounds!==parseInt(this.numRounds,10)||1>this.numRounds)throw new Error("numRounds must a integer >= 1");this.o=t,this.h=[],this.u=0,this.l=!1,this.A=0,this.H=!1,this.S=[],this.p=[];}update(t){let n,e=0;const r=this.m>>>5,i=this.C(t,this.h,this.u),s=i.binLen,o=i.value,h=s>>>5;for(n=0;n<h;n+=r)e+this.m<=s&&(this.U=this.v(o.slice(n,n+r),this.U),e+=this.m);return this.A+=e,this.h=o.slice(e>>>5),this.u=s%this.m,this.l=!0,this}getHash(t,n){let e,r,i=this.R;const o=l(n);if(this.K){if(-1===o.outputLen)throw new Error("Output length must be specified in options");i=o.outputLen;}const h=s(t,i,this.T,o);if(this.H&&this.g)return h(this.g(o));for(r=this.F(this.h.slice(),this.u,this.A,this.L(this.U),i),e=1;e<this.numRounds;e+=1)this.K&&i%32!=0&&(r[r.length-1]&=16777215>>>24-i%32),r=this.F(r,i,0,this.B(this.o),i);return h(r)}setHMACKey(t,n,e){if(!this.M)throw new Error("Variant does not support HMAC");if(this.l)throw new Error("Cannot set MAC key after calling update");const r=i(n,(e||{}).encoding||"UTF8",this.T);this.k(r(t));}k(t){const n=this.m>>>3,e=n/4-1;let r;if(1!==this.numRounds)throw new Error(f);if(this.H)throw new Error("MAC key already set");for(n<t.binLen/8&&(t.value=this.F(t.value,t.binLen,0,this.B(this.o),this.R));t.value.length<=e;)t.value.push(0);for(r=0;r<=e;r+=1)this.S[r]=909522486^t.value[r],this.p[r]=1549556828^t.value[r];this.U=this.v(this.S,this.U),this.A=this.m,this.H=!0;}getHMAC(t,n){const e=l(n);return s(t,this.R,this.T,e)(this.Y())}Y(){let t;if(!this.H)throw new Error("Cannot call getHMAC without first setting MAC key");const n=this.F(this.h.slice(),this.u,this.A,this.L(this.U),this.R);return t=this.v(this.p,this.B(this.o)),t=this.F(n,this.R,this.m,t,this.R),t}}function H(t,n){return t<<n|t>>>32-n}function S(t,n){return t>>>n|t<<32-n}function b(t,n){return t>>>n}function p(t,n,e){return t^n^e}function d(t,n,e){return t&n^~t&e}function m(t,n,e){return t&n^t&e^n&e}function C(t){return S(t,2)^S(t,13)^S(t,22)}function y(t,n){const e=(65535&t)+(65535&n);return (65535&(t>>>16)+(n>>>16)+(e>>>16))<<16|65535&e}function U(t,n,e,r){const i=(65535&t)+(65535&n)+(65535&e)+(65535&r);return (65535&(t>>>16)+(n>>>16)+(e>>>16)+(r>>>16)+(i>>>16))<<16|65535&i}function v(t,n,e,r,i){const s=(65535&t)+(65535&n)+(65535&e)+(65535&r)+(65535&i);return (65535&(t>>>16)+(n>>>16)+(e>>>16)+(r>>>16)+(i>>>16)+(s>>>16))<<16|65535&s}function R(t){return S(t,7)^S(t,18)^b(t,3)}function K(t){return S(t,6)^S(t,11)^S(t,25)}function T(t){return [1732584193,4023233417,2562383102,271733878,3285377520]}function g(t,n){let e,r,i,s,o,h,u;const w=[];for(e=n[0],r=n[1],i=n[2],s=n[3],o=n[4],u=0;u<80;u+=1)w[u]=u<16?t[u]:H(w[u-3]^w[u-8]^w[u-14]^w[u-16],1),h=u<20?v(H(e,5),d(r,i,s),o,1518500249,w[u]):u<40?v(H(e,5),p(r,i,s),o,1859775393,w[u]):u<60?v(H(e,5),m(r,i,s),o,2400959708,w[u]):v(H(e,5),p(r,i,s),o,3395469782,w[u]),o=s,s=i,i=H(r,30),r=e,e=h;return n[0]=y(e,n[0]),n[1]=y(r,n[1]),n[2]=y(i,n[2]),n[3]=y(s,n[3]),n[4]=y(o,n[4]),n}function F(t,n,e,r){let i;const s=15+(n+65>>>9<<4),h=n+e;for(;t.length<=s;)t.push(0);for(t[n>>>5]|=128<<24-n%32,t[s]=4294967295&h,t[s-1]=h/o|0,i=0;i<t.length;i+=16)r=g(t.slice(i,i+16),r);return r}let L=class extends E{constructor(t,n,e){if("SHA-1"!==t)throw new Error(c);super(t,n,e);const r=e||{};this.M=!0,this.g=this.Y,this.T=-1,this.C=i(this.t,this.i,this.T),this.v=g,this.L=function(t){return t.slice()},this.B=T,this.F=F,this.U=[1732584193,4023233417,2562383102,271733878,3285377520],this.m=512,this.R=160,this.K=!1,r.hmacKey&&this.k(A("hmacKey",r.hmacKey,this.T));}};function B(t){let n;return n="SHA-224"==t?u.slice():w.slice(),n}function M(t,n){let e,r,i,s,o,u,w,c,f,a,l;const A=[];for(e=n[0],r=n[1],i=n[2],s=n[3],o=n[4],u=n[5],w=n[6],c=n[7],l=0;l<64;l+=1)A[l]=l<16?t[l]:U(S(E=A[l-2],17)^S(E,19)^b(E,10),A[l-7],R(A[l-15]),A[l-16]),f=v(c,K(o),d(o,u,w),h[l],A[l]),a=y(C(e),m(e,r,i)),c=w,w=u,u=o,o=y(s,f),s=i,i=r,r=e,e=y(f,a);var E;return n[0]=y(e,n[0]),n[1]=y(r,n[1]),n[2]=y(i,n[2]),n[3]=y(s,n[3]),n[4]=y(o,n[4]),n[5]=y(u,n[5]),n[6]=y(w,n[6]),n[7]=y(c,n[7]),n}let k=class extends E{constructor(t,n,e){if("SHA-224"!==t&&"SHA-256"!==t)throw new Error(c);super(t,n,e);const r=e||{};this.g=this.Y,this.M=!0,this.T=-1,this.C=i(this.t,this.i,this.T),this.v=M,this.L=function(t){return t.slice()},this.B=B,this.F=function(n,e,r,i){return function(t,n,e,r,i){let s,h;const u=15+(n+65>>>9<<4),w=n+e;for(;t.length<=u;)t.push(0);for(t[n>>>5]|=128<<24-n%32,t[u]=4294967295&w,t[u-1]=w/o|0,s=0;s<t.length;s+=16)r=M(t.slice(s,s+16),r);return h="SHA-224"===i?[r[0],r[1],r[2],r[3],r[4],r[5],r[6]]:r,h}(n,e,r,i,t)},this.U=B(t),this.m=512,this.R="SHA-224"===t?224:256,this.K=!1,r.hmacKey&&this.k(A("hmacKey",r.hmacKey,this.T));}};class Y{constructor(t,n){this.N=t,this.I=n;}}function N(t,n){let e;return n>32?(e=64-n,new Y(t.I<<n|t.N>>>e,t.N<<n|t.I>>>e)):0!==n?(e=32-n,new Y(t.N<<n|t.I>>>e,t.I<<n|t.N>>>e)):t}function I(t,n){let e;return n<32?(e=32-n,new Y(t.N>>>n|t.I<<e,t.I>>>n|t.N<<e)):(e=64-n,new Y(t.I>>>n|t.N<<e,t.N>>>n|t.I<<e))}function X(t,n){return new Y(t.N>>>n,t.I>>>n|t.N<<32-n)}function z(t,n,e){return new Y(t.N&n.N^t.N&e.N^n.N&e.N,t.I&n.I^t.I&e.I^n.I&e.I)}function x(t){const n=I(t,28),e=I(t,34),r=I(t,39);return new Y(n.N^e.N^r.N,n.I^e.I^r.I)}function _(t,n){let e,r;e=(65535&t.I)+(65535&n.I),r=(t.I>>>16)+(n.I>>>16)+(e>>>16);const i=(65535&r)<<16|65535&e;e=(65535&t.N)+(65535&n.N)+(r>>>16),r=(t.N>>>16)+(n.N>>>16)+(e>>>16);return new Y((65535&r)<<16|65535&e,i)}function O(t,n,e,r){let i,s;i=(65535&t.I)+(65535&n.I)+(65535&e.I)+(65535&r.I),s=(t.I>>>16)+(n.I>>>16)+(e.I>>>16)+(r.I>>>16)+(i>>>16);const o=(65535&s)<<16|65535&i;i=(65535&t.N)+(65535&n.N)+(65535&e.N)+(65535&r.N)+(s>>>16),s=(t.N>>>16)+(n.N>>>16)+(e.N>>>16)+(r.N>>>16)+(i>>>16);return new Y((65535&s)<<16|65535&i,o)}function P(t,n,e,r,i){let s,o;s=(65535&t.I)+(65535&n.I)+(65535&e.I)+(65535&r.I)+(65535&i.I),o=(t.I>>>16)+(n.I>>>16)+(e.I>>>16)+(r.I>>>16)+(i.I>>>16)+(s>>>16);const h=(65535&o)<<16|65535&s;s=(65535&t.N)+(65535&n.N)+(65535&e.N)+(65535&r.N)+(65535&i.N)+(o>>>16),o=(t.N>>>16)+(n.N>>>16)+(e.N>>>16)+(r.N>>>16)+(i.N>>>16)+(s>>>16);return new Y((65535&o)<<16|65535&s,h)}function V(t,n){return new Y(t.N^n.N,t.I^n.I)}function Z(t){const n=I(t,19),e=I(t,61),r=X(t,6);return new Y(n.N^e.N^r.N,n.I^e.I^r.I)}function j(t){const n=I(t,1),e=I(t,8),r=X(t,7);return new Y(n.N^e.N^r.N,n.I^e.I^r.I)}function q(t){const n=I(t,14),e=I(t,18),r=I(t,41);return new Y(n.N^e.N^r.N,n.I^e.I^r.I)}const D=[new Y(h[0],3609767458),new Y(h[1],602891725),new Y(h[2],3964484399),new Y(h[3],2173295548),new Y(h[4],4081628472),new Y(h[5],3053834265),new Y(h[6],2937671579),new Y(h[7],3664609560),new Y(h[8],2734883394),new Y(h[9],1164996542),new Y(h[10],1323610764),new Y(h[11],3590304994),new Y(h[12],4068182383),new Y(h[13],991336113),new Y(h[14],633803317),new Y(h[15],3479774868),new Y(h[16],2666613458),new Y(h[17],944711139),new Y(h[18],2341262773),new Y(h[19],2007800933),new Y(h[20],1495990901),new Y(h[21],1856431235),new Y(h[22],3175218132),new Y(h[23],2198950837),new Y(h[24],3999719339),new Y(h[25],766784016),new Y(h[26],2566594879),new Y(h[27],3203337956),new Y(h[28],1034457026),new Y(h[29],2466948901),new Y(h[30],3758326383),new Y(h[31],168717936),new Y(h[32],1188179964),new Y(h[33],1546045734),new Y(h[34],1522805485),new Y(h[35],2643833823),new Y(h[36],2343527390),new Y(h[37],1014477480),new Y(h[38],1206759142),new Y(h[39],344077627),new Y(h[40],1290863460),new Y(h[41],3158454273),new Y(h[42],3505952657),new Y(h[43],106217008),new Y(h[44],3606008344),new Y(h[45],1432725776),new Y(h[46],1467031594),new Y(h[47],851169720),new Y(h[48],3100823752),new Y(h[49],1363258195),new Y(h[50],3750685593),new Y(h[51],3785050280),new Y(h[52],3318307427),new Y(h[53],3812723403),new Y(h[54],2003034995),new Y(h[55],3602036899),new Y(h[56],1575990012),new Y(h[57],1125592928),new Y(h[58],2716904306),new Y(h[59],442776044),new Y(h[60],593698344),new Y(h[61],3733110249),new Y(h[62],2999351573),new Y(h[63],3815920427),new Y(3391569614,3928383900),new Y(3515267271,566280711),new Y(3940187606,3454069534),new Y(4118630271,4000239992),new Y(116418474,1914138554),new Y(174292421,2731055270),new Y(289380356,3203993006),new Y(460393269,320620315),new Y(685471733,587496836),new Y(852142971,1086792851),new Y(1017036298,365543100),new Y(1126000580,2618297676),new Y(1288033470,3409855158),new Y(1501505948,4234509866),new Y(1607167915,987167468),new Y(1816402316,1246189591)];function G(t){return "SHA-384"===t?[new Y(3418070365,u[0]),new Y(1654270250,u[1]),new Y(2438529370,u[2]),new Y(355462360,u[3]),new Y(1731405415,u[4]),new Y(41048885895,u[5]),new Y(3675008525,u[6]),new Y(1203062813,u[7])]:[new Y(w[0],4089235720),new Y(w[1],2227873595),new Y(w[2],4271175723),new Y(w[3],1595750129),new Y(w[4],2917565137),new Y(w[5],725511199),new Y(w[6],4215389547),new Y(w[7],327033209)]}function J(t,n){let e,r,i,s,o,h,u,w,c,f,a,l;const A=[];for(e=n[0],r=n[1],i=n[2],s=n[3],o=n[4],h=n[5],u=n[6],w=n[7],a=0;a<80;a+=1)a<16?(l=2*a,A[a]=new Y(t[l],t[l+1])):A[a]=O(Z(A[a-2]),A[a-7],j(A[a-15]),A[a-16]),c=P(w,q(o),(H=h,S=u,new Y((E=o).N&H.N^~E.N&S.N,E.I&H.I^~E.I&S.I)),D[a],A[a]),f=_(x(e),z(e,r,i)),w=u,u=h,h=o,o=_(s,c),s=i,i=r,r=e,e=_(c,f);var E,H,S;return n[0]=_(e,n[0]),n[1]=_(r,n[1]),n[2]=_(i,n[2]),n[3]=_(s,n[3]),n[4]=_(o,n[4]),n[5]=_(h,n[5]),n[6]=_(u,n[6]),n[7]=_(w,n[7]),n}let Q=class extends E{constructor(t,n,e){if("SHA-384"!==t&&"SHA-512"!==t)throw new Error(c);super(t,n,e);const r=e||{};this.g=this.Y,this.M=!0,this.T=-1,this.C=i(this.t,this.i,this.T),this.v=J,this.L=function(t){return t.slice()},this.B=G,this.F=function(n,e,r,i){return function(t,n,e,r,i){let s,h;const u=31+(n+129>>>10<<5),w=n+e;for(;t.length<=u;)t.push(0);for(t[n>>>5]|=128<<24-n%32,t[u]=4294967295&w,t[u-1]=w/o|0,s=0;s<t.length;s+=32)r=J(t.slice(s,s+32),r);return h="SHA-384"===i?[r[0].N,r[0].I,r[1].N,r[1].I,r[2].N,r[2].I,r[3].N,r[3].I,r[4].N,r[4].I,r[5].N,r[5].I]:[r[0].N,r[0].I,r[1].N,r[1].I,r[2].N,r[2].I,r[3].N,r[3].I,r[4].N,r[4].I,r[5].N,r[5].I,r[6].N,r[6].I,r[7].N,r[7].I],h}(n,e,r,i,t)},this.U=G(t),this.m=1024,this.R="SHA-384"===t?384:512,this.K=!1,r.hmacKey&&this.k(A("hmacKey",r.hmacKey,this.T));}};const W=[new Y(0,1),new Y(0,32898),new Y(2147483648,32906),new Y(2147483648,2147516416),new Y(0,32907),new Y(0,2147483649),new Y(2147483648,2147516545),new Y(2147483648,32777),new Y(0,138),new Y(0,136),new Y(0,2147516425),new Y(0,2147483658),new Y(0,2147516555),new Y(2147483648,139),new Y(2147483648,32905),new Y(2147483648,32771),new Y(2147483648,32770),new Y(2147483648,128),new Y(0,32778),new Y(2147483648,2147483658),new Y(2147483648,2147516545),new Y(2147483648,32896),new Y(0,2147483649),new Y(2147483648,2147516424)],$=[[0,36,3,41,18],[1,44,10,45,2],[62,6,43,15,61],[28,55,25,21,56],[27,20,39,8,14]];function tt(t){let n;const e=[];for(n=0;n<5;n+=1)e[n]=[new Y(0,0),new Y(0,0),new Y(0,0),new Y(0,0),new Y(0,0)];return e}function nt(t){let n;const e=[];for(n=0;n<5;n+=1)e[n]=t[n].slice();return e}function et(t,n){let e,r,i,s;const o=[],h=[];if(null!==t)for(r=0;r<t.length;r+=2)n[(r>>>1)%5][(r>>>1)/5|0]=V(n[(r>>>1)%5][(r>>>1)/5|0],new Y(t[r+1],t[r]));for(e=0;e<24;e+=1){for(s=tt(),r=0;r<5;r+=1)o[r]=(u=n[r][0],w=n[r][1],c=n[r][2],f=n[r][3],a=n[r][4],new Y(u.N^w.N^c.N^f.N^a.N,u.I^w.I^c.I^f.I^a.I));for(r=0;r<5;r+=1)h[r]=V(o[(r+4)%5],N(o[(r+1)%5],1));for(r=0;r<5;r+=1)for(i=0;i<5;i+=1)n[r][i]=V(n[r][i],h[r]);for(r=0;r<5;r+=1)for(i=0;i<5;i+=1)s[i][(2*r+3*i)%5]=N(n[r][i],$[r][i]);for(r=0;r<5;r+=1)for(i=0;i<5;i+=1)n[r][i]=V(s[r][i],new Y(~s[(r+1)%5][i].N&s[(r+2)%5][i].N,~s[(r+1)%5][i].I&s[(r+2)%5][i].I));n[0][0]=V(n[0][0],W[e]);}var u,w,c,f,a;return n}function rt(t){let n,e,r=0;const i=[0,0],s=[4294967295&t,t/o&2097151];for(n=6;n>=0;n--)e=s[n>>2]>>>8*n&255,0===e&&0===r||(i[r+1>>2]|=e<<8*(r+1),r+=1);return r=0!==r?r:1,i[0]|=r,{value:r+1>4?i:[i[0]],binLen:8+8*r}}function it(t){return a(rt(t.binLen),t)}function st(t,n){let e,r=rt(n);r=a(r,t);const i=n>>>2,s=(i-r.value.length%i)%i;for(e=0;e<s;e++)r.value.push(0);return r.value}let ot=class extends E{constructor(t,n,e){let r=6,s=0;super(t,n,e);const o=e||{};if(1!==this.numRounds){if(o.kmacKey||o.hmacKey)throw new Error(f);if("CSHAKE128"===this.o||"CSHAKE256"===this.o)throw new Error("Cannot set numRounds for CSHAKE variants")}switch(this.T=1,this.C=i(this.t,this.i,this.T),this.v=et,this.L=nt,this.B=tt,this.U=tt(),this.K=!1,t){case"SHA3-224":this.m=s=1152,this.R=224,this.M=!0,this.g=this.Y;break;case"SHA3-256":this.m=s=1088,this.R=256,this.M=!0,this.g=this.Y;break;case"SHA3-384":this.m=s=832,this.R=384,this.M=!0,this.g=this.Y;break;case"SHA3-512":this.m=s=576,this.R=512,this.M=!0,this.g=this.Y;break;case"SHAKE128":r=31,this.m=s=1344,this.R=-1,this.K=!0,this.M=!1,this.g=null;break;case"SHAKE256":r=31,this.m=s=1088,this.R=-1,this.K=!0,this.M=!1,this.g=null;break;case"KMAC128":r=4,this.m=s=1344,this.X(e),this.R=-1,this.K=!0,this.M=!1,this.g=this._;break;case"KMAC256":r=4,this.m=s=1088,this.X(e),this.R=-1,this.K=!0,this.M=!1,this.g=this._;break;case"CSHAKE128":this.m=s=1344,r=this.O(e),this.R=-1,this.K=!0,this.M=!1,this.g=null;break;case"CSHAKE256":this.m=s=1088,r=this.O(e),this.R=-1,this.K=!0,this.M=!1,this.g=null;break;default:throw new Error(c)}this.F=function(t,n,e,i,o){return function(t,n,e,r,i,s,o){let h,u,w=0;const c=[],f=i>>>5,a=n>>>5;for(h=0;h<a&&n>=i;h+=f)r=et(t.slice(h,h+f),r),n-=i;for(t=t.slice(h),n%=i;t.length<f;)t.push(0);for(h=n>>>3,t[h>>2]^=s<<h%4*8,t[f-1]^=2147483648,r=et(t,r);32*c.length<o&&(u=r[w%5][w/5|0],c.push(u.I),!(32*c.length>=o));)c.push(u.N),w+=1,0==64*w%i&&(et(null,r),w=0);return c}(t,n,0,i,s,r,o)},o.hmacKey&&this.k(A("hmacKey",o.hmacKey,this.T));}O(t,n){const e=function(t){const n=t||{};return {funcName:A("funcName",n.funcName,1,{value:[],binLen:0}),customization:A("Customization",n.customization,1,{value:[],binLen:0})}}(t||{});n&&(e.funcName=n);const r=a(it(e.funcName),it(e.customization));if(0!==e.customization.binLen||0!==e.funcName.binLen){const t=st(r,this.m>>>3);for(let n=0;n<t.length;n+=this.m>>>5)this.U=this.v(t.slice(n,n+(this.m>>>5)),this.U),this.A+=this.m;return 4}return 31}X(t){const n=function(t){const n=t||{};return {kmacKey:A("kmacKey",n.kmacKey,1),funcName:{value:[1128353099],binLen:32},customization:A("Customization",n.customization,1,{value:[],binLen:0})}}(t||{});this.O(t,n.funcName);const e=st(it(n.kmacKey),this.m>>>3);for(let t=0;t<e.length;t+=this.m>>>5)this.U=this.v(e.slice(t,t+(this.m>>>5)),this.U),this.A+=this.m;this.H=!0;}_(t){const n=a({value:this.h.slice(),binLen:this.u},function(t){let n,e,r=0;const i=[0,0],s=[4294967295&t,t/o&2097151];for(n=6;n>=0;n--)e=s[n>>2]>>>8*n&255,0===e&&0===r||(i[r>>2]|=e<<8*r,r+=1);return r=0!==r?r:1,i[r>>2]|=r<<8*r,{value:r+1>4?i:[i[0]],binLen:8+8*r}}(t.outputLen));return this.F(n.value,n.binLen,this.A,this.L(this.U),t.outputLen)}};class ht{constructor(t,n,e){if("SHA-1"==t)this.P=new L(t,n,e);else if("SHA-224"==t||"SHA-256"==t)this.P=new k(t,n,e);else if("SHA-384"==t||"SHA-512"==t)this.P=new Q(t,n,e);else {if("SHA3-224"!=t&&"SHA3-256"!=t&&"SHA3-384"!=t&&"SHA3-512"!=t&&"SHAKE128"!=t&&"SHAKE256"!=t&&"CSHAKE128"!=t&&"CSHAKE256"!=t&&"KMAC128"!=t&&"KMAC256"!=t)throw new Error(c);this.P=new ot(t,n,e);}}update(t){return this.P.update(t),this}getHash(t,n){return this.P.getHash(t,n)}setHMACKey(t,n,e){this.P.setHMACKey(t,n,e);}getHMAC(t,n){return this.P.getHMAC(t,n)}}

	class TOTP {
	    static generate(key, options) {
	        const _options = { digits: 6, algorithm: "SHA-1", period: 30, timestamp: Date.now(), ...options };
	        const epoch = Math.floor(_options.timestamp / 1000.0);
	        const time = this.leftpad(this.dec2hex(Math.floor(epoch / _options.period)), 16, "0");
	        const shaObj = new ht(_options.algorithm, "HEX");
	        shaObj.setHMACKey(this.base32tohex(key), "HEX");
	        shaObj.update(time);
	        const hmac = shaObj.getHMAC("HEX");
	        const offset = this.hex2dec(hmac.substring(hmac.length - 1));
	        let otp = (this.hex2dec(hmac.substr(offset * 2, 8)) & this.hex2dec("7fffffff")) + "";
	        const start = Math.max(otp.length - _options.digits, 0);
	        otp = otp.substring(start, start + _options.digits);
	        const expires = Math.ceil((_options.timestamp + 1) / (_options.period * 1000)) * _options.period * 1000;
	        return { otp, expires };
	    }
	    static hex2dec(hex) {
	        return parseInt(hex, 16);
	    }
	    static dec2hex(dec) {
	        return (dec < 15.5 ? "0" : "") + Math.round(dec).toString(16);
	    }
	    static base32tohex(base32) {
	        const base32chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
	        let bits = "";
	        let hex = "";
	        const _base32 = base32.replace(/=+$/, "");
	        for (let i = 0; i < _base32.length; i++) {
	            const val = base32chars.indexOf(base32.charAt(i).toUpperCase());
	            if (val === -1)
	                throw new Error("Invalid base32 character in key");
	            bits += this.leftpad(val.toString(2), 5, "0");
	        }
	        for (let i = 0; i + 8 <= bits.length; i += 8) {
	            const chunk = bits.substr(i, 8);
	            hex = hex + this.leftpad(parseInt(chunk, 2).toString(16), 2, "0");
	        }
	        return hex;
	    }
	    static leftpad(str, len, pad) {
	        if (len + 1 >= str.length) {
	            str = Array(len + 1 - str.length).join(pad) + str;
	        }
	        return str;
	    }
	}

	/* src/lib/components/popup/components/CircularProgressBar.svelte generated by Svelte v4.2.19 */
	const file$I = "src/lib/components/popup/components/CircularProgressBar.svelte";

	function create_fragment$I(ctx) {
		let div2;
		let div1;
		let div0;
		let t0;
		let t1;
		let svg;
		let circle0;
		let circle1;

		const block = {
			c: function create() {
				div2 = element("div");
				div1 = element("div");
				div0 = element("div");
				t0 = text(/*counter*/ ctx[0]);
				t1 = space();
				svg = svg_element("svg");
				circle0 = svg_element("circle");
				circle1 = svg_element("circle");
				attr_dev(div0, "id", "number");
				attr_dev(div0, "class", "svelte-55ppma");
				add_location(div0, file$I, 96, 2, 1844);
				attr_dev(div1, "class", "inner svelte-55ppma");
				add_location(div1, file$I, 95, 1, 1822);
				attr_dev(circle0, "class", "track svelte-55ppma");
				attr_dev(circle0, "cx", "50%");
				attr_dev(circle0, "cy", "50%");
				attr_dev(circle0, "r", "10");
				attr_dev(circle0, "stroke-linecap", "round");
				add_location(circle0, file$I, 105, 2, 1981);
				attr_dev(circle1, "class", "progress svelte-55ppma");
				attr_dev(circle1, "cx", "50%");
				attr_dev(circle1, "cy", "50%");
				attr_dev(circle1, "r", "10");
				attr_dev(circle1, "stroke-linecap", "round");
				add_location(circle1, file$I, 107, 2, 2066);
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "version", "1.1");
				attr_dev(svg, "width", "24px");
				attr_dev(svg, "height", "24px");
				attr_dev(svg, "class", "svelte-55ppma");
				add_location(svg, file$I, 99, 1, 1887);
				attr_dev(div2, "class", "skill svelte-55ppma");
				add_location(div2, file$I, 94, 0, 1801);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div2, anchor);
				append_dev(div2, div1);
				append_dev(div1, div0);
				append_dev(div0, t0);
				append_dev(div2, t1);
				append_dev(div2, svg);
				append_dev(svg, circle0);
				append_dev(svg, circle1);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*counter*/ 1) set_data_dev(t0, /*counter*/ ctx[0]);
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div2);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$I.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function updateCircle(value) {
		const circle = document.querySelector("circle.progress");
		const radius = circle.r.baseVal.value;
		const circumference = radius * 2 * Math.PI;
		circle.style.strokeDasharray = `${circumference}`;
		const offset = value * circumference;
		circle.style.strokeDashoffset = `${circumference - offset}`;
	}

	function instance$I($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('CircularProgressBar', slots, []);
		let { counter } = $$props;
		let progress = 1;

		onMount(() => {
			// Initialize the circle when the component mounts
			updateCircle(progress);
		});

		afterUpdate(() => {
			// Update progress based on the new counter value
			progress = counter / 30; // Assuming 30 is the initial value

			updateCircle(progress);
		});

		$$self.$$.on_mount.push(function () {
			if (counter === undefined && !('counter' in $$props || $$self.$$.bound[$$self.$$.props['counter']])) {
				console.warn("<CircularProgressBar> was created without expected prop 'counter'");
			}
		});

		const writable_props = ['counter'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CircularProgressBar> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('counter' in $$props) $$invalidate(0, counter = $$props.counter);
		};

		$$self.$capture_state = () => ({
			onMount,
			onDestroy,
			afterUpdate,
			counter,
			progress,
			updateCircle
		});

		$$self.$inject_state = $$props => {
			if ('counter' in $$props) $$invalidate(0, counter = $$props.counter);
			if ('progress' in $$props) progress = $$props.progress;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [counter];
	}

	class CircularProgressBar extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$I, create_fragment$I, safe_not_equal, { counter: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "CircularProgressBar",
				options,
				id: create_fragment$I.name
			});
		}

		get counter() {
			throw new Error("<CircularProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set counter(value) {
			throw new Error("<CircularProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/credentials/EncryptedField.svelte generated by Svelte v4.2.19 */
	const file$H = "src/lib/components/dashboard/credentials/EncryptedField.svelte";

	// (89:3) {:else}
	function create_else_block_3$1(ctx) {
		let span;

		let t_value = (/*decrypted*/ ctx[4] && /*visibility*/ ctx[3]
		? /*decryptedValue*/ ctx[5]
		: ("*").repeat(8)) + "";

		let t;

		const block = {
			c: function create() {
				span = element("span");
				t = text(t_value);
				attr_dev(span, "class", "overflow-hidden whitespace-nowrap text-ellipsis");
				add_location(span, file$H, 108, 4, 2868);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				append_dev(span, t);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*decrypted, visibility, decryptedValue*/ 56 && t_value !== (t_value = (/*decrypted*/ ctx[4] && /*visibility*/ ctx[3]
				? /*decryptedValue*/ ctx[5]
				: ("*").repeat(8)) + "")) set_data_dev(t, t_value);
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_3$1.name,
			type: "else",
			source: "(89:3) {:else}",
			ctx
		});

		return block;
	}

	// (86:3) {#if fieldType === "totp" && decrypted}
	function create_if_block_5$7(ctx) {
		let span;
		let t0;
		let t1;
		let circularprogressbar;
		let current;

		circularprogressbar = new CircularProgressBar({
				props: { counter: /*timeRemaining*/ ctx[8] },
				$$inline: true
			});

		const block = {
			c: function create() {
				span = element("span");
				t0 = text(/*totpToken*/ ctx[7]);
				t1 = space();
				create_component(circularprogressbar.$$.fragment);
				attr_dev(span, "class", "mr-4");
				add_location(span, file$H, 105, 4, 2760);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				append_dev(span, t0);
				insert_dev(target, t1, anchor);
				mount_component(circularprogressbar, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (!current || dirty & /*totpToken*/ 128) set_data_dev(t0, /*totpToken*/ ctx[7]);
				const circularprogressbar_changes = {};
				if (dirty & /*timeRemaining*/ 256) circularprogressbar_changes.counter = /*timeRemaining*/ ctx[8];
				circularprogressbar.$set(circularprogressbar_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(circularprogressbar.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(circularprogressbar.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
					detach_dev(t1);
				}

				destroy_component(circularprogressbar, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_5$7.name,
			type: "if",
			source: "(86:3) {#if fieldType === \\\"totp\\\" && decrypted}",
			ctx
		});

		return block;
	}

	// (98:2) {:else}
	function create_else_block$m(ctx) {
		let div;
		let t;
		let button;
		let current_block_type_index;
		let if_block1;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*fieldType*/ ctx[1] !== "totp" && create_if_block_3$c(ctx);
		const if_block_creators = [create_if_block_1$o, create_if_block_2$h, create_else_block_1$a];
		const if_blocks = [];

		function select_block_type_3(ctx, dirty) {
			if (/*copied*/ ctx[6]) return 0;
			if (/*hoverEffect*/ ctx[2]) return 1;
			return 2;
		}

		current_block_type_index = select_block_type_3(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				div = element("div");
				if (if_block0) if_block0.c();
				t = space();
				button = element("button");
				if_block1.c();
				add_location(button, file$H, 130, 4, 3533);
				attr_dev(div, "class", "max-w-2/5 flex gap-2 items-center justify-end");
				add_location(div, file$H, 117, 3, 3176);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				if (if_block0) if_block0.m(div, null);
				append_dev(div, t);
				append_dev(div, button);
				if_blocks[current_block_type_index].m(button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", stop_propagation(/*copyToClipboard*/ ctx[11]), false, false, true, false);
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (/*fieldType*/ ctx[1] !== "totp") {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*fieldType*/ 2) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_3$c(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div, t);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_3(ctx);

				if (current_block_type_index !== previous_block_index) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					}

					transition_in(if_block1, 1);
					if_block1.m(button, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if (if_block0) if_block0.d();
				if_blocks[current_block_type_index].d();
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$m.name,
			type: "else",
			source: "(98:2) {:else}",
			ctx
		});

		return block;
	}

	// (94:2) {#if !decrypted}
	function create_if_block$v(ctx) {
		let button;
		let locked;
		let current;
		let mounted;
		let dispose;

		locked = new Locked({
				props: {
					color: /*hoverEffect*/ ctx[2] ? '#89B4FA' : '#4D4F60'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				button = element("button");
				create_component(locked.$$.fragment);
				add_location(button, file$H, 113, 3, 3043);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				mount_component(locked, button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", stop_propagation(/*decrypt*/ ctx[9]), false, false, true, false);
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const locked_changes = {};
				if (dirty & /*hoverEffect*/ 4) locked_changes.color = /*hoverEffect*/ ctx[2] ? '#89B4FA' : '#4D4F60';
				locked.$set(locked_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(locked.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(locked.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(locked);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$v.name,
			type: "if",
			source: "(94:2) {#if !decrypted}",
			ctx
		});

		return block;
	}

	// (100:4) {#if fieldType !== "totp"}
	function create_if_block_3$c(ctx) {
		let button0;
		let unlocked;
		let t;
		let button1;
		let current_block_type_index;
		let if_block;
		let current;
		let mounted;
		let dispose;
		unlocked = new Unlocked({ $$inline: true });
		const if_block_creators = [create_if_block_4$8, create_else_block_2$6];
		const if_blocks = [];

		function select_block_type_2(ctx, dirty) {
			if (/*visibility*/ ctx[3]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_2(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				button0 = element("button");
				create_component(unlocked.$$.fragment);
				t = space();
				button1 = element("button");
				if_block.c();
				add_location(button0, file$H, 119, 5, 3272);
				add_location(button1, file$H, 122, 5, 3364);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button0, anchor);
				mount_component(unlocked, button0, null);
				insert_dev(target, t, anchor);
				insert_dev(target, button1, anchor);
				if_blocks[current_block_type_index].m(button1, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*lockCredential*/ ctx[12]), false, false, true, false),
						listen_dev(button1, "click", stop_propagation(/*toggleVisibility*/ ctx[10]), false, false, true, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_2(ctx);

				if (current_block_type_index !== previous_block_index) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(button1, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(unlocked.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(unlocked.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button0);
					detach_dev(t);
					detach_dev(button1);
				}

				destroy_component(unlocked);
				if_blocks[current_block_type_index].d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$c.name,
			type: "if",
			source: "(100:4) {#if fieldType !== \\\"totp\\\"}",
			ctx
		});

		return block;
	}

	// (107:6) {:else}
	function create_else_block_2$6(ctx) {
		let eye;
		let current;
		eye = new Eye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(eye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(eye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(eye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(eye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(eye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_2$6.name,
			type: "else",
			source: "(107:6) {:else}",
			ctx
		});

		return block;
	}

	// (105:6) {#if visibility}
	function create_if_block_4$8(ctx) {
		let closedeye;
		let current;
		closedeye = new ClosedEye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(closedeye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(closedeye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closedeye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(closedeye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(closedeye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_4$8.name,
			type: "if",
			source: "(105:6) {#if visibility}",
			ctx
		});

		return block;
	}

	// (119:5) {:else}
	function create_else_block_1$a(ctx) {
		let copyicon;
		let current;

		copyicon = new CopyIcon({
				props: { color: '#4D4F60' },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(copyicon.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(copyicon, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(copyicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(copyicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(copyicon, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_1$a.name,
			type: "else",
			source: "(119:5) {:else}",
			ctx
		});

		return block;
	}

	// (117:27) 
	function create_if_block_2$h(ctx) {
		let activecopy;
		let current;
		activecopy = new ActiveCopy({ $$inline: true });

		const block = {
			c: function create() {
				create_component(activecopy.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(activecopy, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(activecopy.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(activecopy.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(activecopy, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$h.name,
			type: "if",
			source: "(117:27) ",
			ctx
		});

		return block;
	}

	// (113:5) {#if copied}
	function create_if_block_1$o(ctx) {
		let span;
		let tick_1;
		let span_intro;
		let current;
		tick_1 = new Tick({ $$inline: true });

		const block = {
			c: function create() {
				span = element("span");
				create_component(tick_1.$$.fragment);
				add_location(span, file$H, 132, 6, 3611);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				mount_component(tick_1, span, null);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(tick_1.$$.fragment, local);

				if (local) {
					if (!span_intro) {
						add_render_callback(() => {
							span_intro = create_in_transition(span, scale, {});
							span_intro.start();
						});
					}
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(tick_1.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				destroy_component(tick_1);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$o.name,
			type: "if",
			source: "(113:5) {#if copied}",
			ctx
		});

		return block;
	}

	function create_fragment$H(ctx) {
		let div2;
		let div0;
		let t0;
		let t1;
		let div1;
		let span;
		let current_block_type_index;
		let if_block0;
		let span_class_value;
		let t2;
		let current_block_type_index_1;
		let if_block1;
		let div1_class_value;
		let div2_intro;
		let div2_outro;
		let current;
		const if_block_creators = [create_if_block_5$7, create_else_block_3$1];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*fieldType*/ ctx[1] === "totp" && /*decrypted*/ ctx[4]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		const if_block_creators_1 = [create_if_block$v, create_else_block$m];
		const if_blocks_1 = [];

		function select_block_type_1(ctx, dirty) {
			if (!/*decrypted*/ ctx[4]) return 0;
			return 1;
		}

		current_block_type_index_1 = select_block_type_1(ctx);
		if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

		const block = {
			c: function create() {
				div2 = element("div");
				div0 = element("div");
				t0 = text(/*fieldName*/ ctx[0]);
				t1 = space();
				div1 = element("div");
				span = element("span");
				if_block0.c();
				t2 = space();
				if_block1.c();
				attr_dev(div0, "class", "label block mb-2 text-left text-osvauld-dusklabel text-xs font-normal cursor-pointer whitespace-nowrap text-ellipsis");
				add_location(div0, file$H, 91, 1, 2160);

				attr_dev(span, "class", span_class_value = "" + (/*fieldType*/ ctx[1] === 'totp'
				? 'min-w-[80%] max-w-[80%] mr-6'
				: 'w-3/5') + " flex justify-between items-center font-normal text-sm");

				add_location(span, file$H, 100, 2, 2566);

				attr_dev(div1, "class", div1_class_value = "py-1 px-3 w-full flex justify-between items-center text-base " + (/*hoverEffect*/ ctx[2]
				? 'text-osvauld-fieldTextActive bg-osvauld-fieldActive rounded-md '
				: 'text-osvauld-fieldText rounded-none border-b border-osvauld-darkLineSeperator'));

				add_location(div1, file$H, 96, 1, 2317);
				attr_dev(div2, "class", "mb-2 mr-1 max-w-full");
				add_location(div2, file$H, 90, 0, 2109);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div2, anchor);
				append_dev(div2, div0);
				append_dev(div0, t0);
				append_dev(div2, t1);
				append_dev(div2, div1);
				append_dev(div1, span);
				if_blocks[current_block_type_index].m(span, null);
				append_dev(div1, t2);
				if_blocks_1[current_block_type_index_1].m(div1, null);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (!current || dirty & /*fieldName*/ 1) set_data_dev(t0, /*fieldName*/ ctx[0]);
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					transition_in(if_block0, 1);
					if_block0.m(span, null);
				}

				if (!current || dirty & /*fieldType*/ 2 && span_class_value !== (span_class_value = "" + (/*fieldType*/ ctx[1] === 'totp'
				? 'min-w-[80%] max-w-[80%] mr-6'
				: 'w-3/5') + " flex justify-between items-center font-normal text-sm")) {
					attr_dev(span, "class", span_class_value);
				}

				let previous_block_index_1 = current_block_type_index_1;
				current_block_type_index_1 = select_block_type_1(ctx);

				if (current_block_type_index_1 === previous_block_index_1) {
					if_blocks_1[current_block_type_index_1].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
						if_blocks_1[previous_block_index_1] = null;
					});

					check_outros();
					if_block1 = if_blocks_1[current_block_type_index_1];

					if (!if_block1) {
						if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div1, null);
				}

				if (!current || dirty & /*hoverEffect*/ 4 && div1_class_value !== (div1_class_value = "py-1 px-3 w-full flex justify-between items-center text-base " + (/*hoverEffect*/ ctx[2]
				? 'text-osvauld-fieldTextActive bg-osvauld-fieldActive rounded-md '
				: 'text-osvauld-fieldText rounded-none border-b border-osvauld-darkLineSeperator'))) {
					attr_dev(div1, "class", div1_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (div2_outro) div2_outro.end(1);
						div2_intro = create_in_transition(div2, fly, {});
						div2_intro.start();
					});
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				if (div2_intro) div2_intro.invalidate();

				if (local) {
					div2_outro = create_out_transition(div2, fly, {});
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div2);
				}

				if_blocks[current_block_type_index].d();
				if_blocks_1[current_block_type_index_1].d();
				if (detaching && div2_outro) div2_outro.end();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$H.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$H($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('EncryptedField', slots, []);
		let { fieldName } = $$props;
		let { fieldValue } = $$props;
		let { fieldType = "sensitive" } = $$props;
		let { hoverEffect } = $$props;
		let visibility = false;
		let decrypted = false;
		let decryptedValue = null;
		let copied = false;
		let totpToken = null;
		let timeRemaining = 0;
		let totpInterval;

		const decrypt = async () => {
			$$invalidate(5, decryptedValue = await sendMessage("decryptField", fieldValue));
			$$invalidate(4, decrypted = true);

			if (fieldType === "totp") {
				generateTotpToken();
			}
		};

		const generateTotpToken = () => {
			const now = Date.now();
			const { otp, expires } = TOTP.generate(decryptedValue || fieldValue);
			$$invalidate(7, totpToken = otp);
			$$invalidate(8, timeRemaining = Math.floor((expires - now) / 1000));

			if (totpInterval) {
				clearInterval(totpInterval);
			}

			totpInterval = setInterval(
				() => {
					const currentTime = Date.now();
					$$invalidate(8, timeRemaining = Math.floor((expires - currentTime) / 1000));

					if (timeRemaining <= 0) {
						const newTotp = TOTP.generate(decryptedValue || fieldValue);
						$$invalidate(7, totpToken = newTotp.otp);
						$$invalidate(8, timeRemaining = Math.floor((newTotp.expires - currentTime) / 1000));
					}
				},
				1000
			);
		};

		const toggleVisibility = () => {
			$$invalidate(3, visibility = !visibility);

			setTimeout(
				() => {
					$$invalidate(3, visibility = false);
				},
				3000
			);
		};

		const copyToClipboard = async () => {
			if (decryptedValue === null) {
				return;
			}

			$$invalidate(6, copied = true);
			await writeToClipboard(decryptedValue);

			setTimeout(
				() => {
					$$invalidate(6, copied = false);
				},
				2000
			);
		};

		const lockCredential = async () => {
			$$invalidate(4, decrypted = false);
			clearInterval(totpInterval);
			$$invalidate(5, decryptedValue = null);
		};

		onDestroy(() => {
			if (totpInterval) {
				clearInterval(totpInterval);
			}
		});

		$$self.$$.on_mount.push(function () {
			if (fieldName === undefined && !('fieldName' in $$props || $$self.$$.bound[$$self.$$.props['fieldName']])) {
				console.warn("<EncryptedField> was created without expected prop 'fieldName'");
			}

			if (fieldValue === undefined && !('fieldValue' in $$props || $$self.$$.bound[$$self.$$.props['fieldValue']])) {
				console.warn("<EncryptedField> was created without expected prop 'fieldValue'");
			}

			if (hoverEffect === undefined && !('hoverEffect' in $$props || $$self.$$.bound[$$self.$$.props['hoverEffect']])) {
				console.warn("<EncryptedField> was created without expected prop 'hoverEffect'");
			}
		});

		const writable_props = ['fieldName', 'fieldValue', 'fieldType', 'hoverEffect'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EncryptedField> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('fieldName' in $$props) $$invalidate(0, fieldName = $$props.fieldName);
			if ('fieldValue' in $$props) $$invalidate(13, fieldValue = $$props.fieldValue);
			if ('fieldType' in $$props) $$invalidate(1, fieldType = $$props.fieldType);
			if ('hoverEffect' in $$props) $$invalidate(2, hoverEffect = $$props.hoverEffect);
		};

		$$self.$capture_state = () => ({
			fly,
			scale,
			Locked,
			Eye,
			Unlocked,
			ActiveCopy,
			ClosedEye,
			CopyIcon,
			Tick,
			TOTP,
			onDestroy,
			writeToClipboard,
			sendMessage,
			CircularProgressBar,
			fieldName,
			fieldValue,
			fieldType,
			hoverEffect,
			visibility,
			decrypted,
			decryptedValue,
			copied,
			totpToken,
			timeRemaining,
			totpInterval,
			decrypt,
			generateTotpToken,
			toggleVisibility,
			copyToClipboard,
			lockCredential
		});

		$$self.$inject_state = $$props => {
			if ('fieldName' in $$props) $$invalidate(0, fieldName = $$props.fieldName);
			if ('fieldValue' in $$props) $$invalidate(13, fieldValue = $$props.fieldValue);
			if ('fieldType' in $$props) $$invalidate(1, fieldType = $$props.fieldType);
			if ('hoverEffect' in $$props) $$invalidate(2, hoverEffect = $$props.hoverEffect);
			if ('visibility' in $$props) $$invalidate(3, visibility = $$props.visibility);
			if ('decrypted' in $$props) $$invalidate(4, decrypted = $$props.decrypted);
			if ('decryptedValue' in $$props) $$invalidate(5, decryptedValue = $$props.decryptedValue);
			if ('copied' in $$props) $$invalidate(6, copied = $$props.copied);
			if ('totpToken' in $$props) $$invalidate(7, totpToken = $$props.totpToken);
			if ('timeRemaining' in $$props) $$invalidate(8, timeRemaining = $$props.timeRemaining);
			if ('totpInterval' in $$props) totpInterval = $$props.totpInterval;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			fieldName,
			fieldType,
			hoverEffect,
			visibility,
			decrypted,
			decryptedValue,
			copied,
			totpToken,
			timeRemaining,
			decrypt,
			toggleVisibility,
			copyToClipboard,
			lockCredential,
			fieldValue
		];
	}

	class EncryptedField extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$H, create_fragment$H, safe_not_equal, {
				fieldName: 0,
				fieldValue: 13,
				fieldType: 1,
				hoverEffect: 2
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "EncryptedField",
				options,
				id: create_fragment$H.name
			});
		}

		get fieldName() {
			throw new Error("<EncryptedField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set fieldName(value) {
			throw new Error("<EncryptedField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get fieldValue() {
			throw new Error("<EncryptedField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set fieldValue(value) {
			throw new Error("<EncryptedField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get fieldType() {
			throw new Error("<EncryptedField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set fieldType(value) {
			throw new Error("<EncryptedField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get hoverEffect() {
			throw new Error("<EncryptedField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set hoverEffect(value) {
			throw new Error("<EncryptedField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/credentials/PlainField.svelte generated by Svelte v4.2.19 */
	const file$G = "src/lib/components/dashboard/credentials/PlainField.svelte";

	// (35:3) {:else}
	function create_else_block$l(ctx) {
		let copyicon;
		let current;

		copyicon = new CopyIcon({
				props: { color: '#4D4F60' },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(copyicon.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(copyicon, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(copyicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(copyicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(copyicon, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$l.name,
			type: "else",
			source: "(35:3) {:else}",
			ctx
		});

		return block;
	}

	// (33:25) 
	function create_if_block_1$n(ctx) {
		let activecopy;
		let current;
		activecopy = new ActiveCopy({ $$inline: true });

		const block = {
			c: function create() {
				create_component(activecopy.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(activecopy, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(activecopy.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(activecopy.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(activecopy, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$n.name,
			type: "if",
			source: "(33:25) ",
			ctx
		});

		return block;
	}

	// (29:3) {#if copied}
	function create_if_block$u(ctx) {
		let span;
		let tick_1;
		let span_intro;
		let current;
		tick_1 = new Tick({ $$inline: true });

		const block = {
			c: function create() {
				span = element("span");
				create_component(tick_1.$$.fragment);
				add_location(span, file$G, 31, 4, 1104);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				mount_component(tick_1, span, null);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(tick_1.$$.fragment, local);

				if (local) {
					if (!span_intro) {
						add_render_callback(() => {
							span_intro = create_in_transition(span, scale, {});
							span_intro.start();
						});
					}
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(tick_1.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				destroy_component(tick_1);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$u.name,
			type: "if",
			source: "(29:3) {#if copied}",
			ctx
		});

		return block;
	}

	function create_fragment$G(ctx) {
		let div1;
		let label;
		let t0;
		let t1;
		let div0;
		let span;
		let t2;
		let t3;
		let button;
		let current_block_type_index;
		let if_block;
		let div0_class_value;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block$u, create_if_block_1$n, create_else_block$l];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*copied*/ ctx[0]) return 0;
			if (/*hoverEffect*/ ctx[3]) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				div1 = element("div");
				label = element("label");
				t0 = text(/*fieldName*/ ctx[1]);
				t1 = space();
				div0 = element("div");
				span = element("span");
				t2 = text(/*fieldValue*/ ctx[2]);
				t3 = space();
				button = element("button");
				if_block.c();
				attr_dev(label, "class", "label block mb-1 text-left text-osvauld-dusklabel whitespace-nowrap text-ellipsis text-xs font-normal cursor-pointer");
				attr_dev(label, "for", "field");
				add_location(label, file$G, 19, 1, 468);
				attr_dev(span, "class", "w-full text-left overflow-x-hidden font-normal whitespace-nowrap text-ellipsis text-sm");
				add_location(span, file$G, 26, 2, 885);
				add_location(button, file$G, 29, 2, 1015);

				attr_dev(div0, "class", div0_class_value = "py-1 px-3 w-full flex justify-between items-center text-base " + (/*hoverEffect*/ ctx[3]
				? 'text-osvauld-fieldTextActive bg-osvauld-fieldActive rounded-md'
				: 'text-osvauld-fieldText rounded-none border-b border-osvauld-darkLineSeperator'));

				add_location(div0, file$G, 22, 1, 637);
				attr_dev(div1, "class", "mb-2.5 mr-1 max-w-full");
				add_location(div1, file$G, 18, 0, 430);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, label);
				append_dev(label, t0);
				append_dev(div1, t1);
				append_dev(div1, div0);
				append_dev(div0, span);
				append_dev(span, t2);
				append_dev(div0, t3);
				append_dev(div0, button);
				if_blocks[current_block_type_index].m(button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", stop_propagation(prevent_default(/*copyToClipboard*/ ctx[4])), false, true, true, false);
					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (!current || dirty & /*fieldName*/ 2) set_data_dev(t0, /*fieldName*/ ctx[1]);
				if (!current || dirty & /*fieldValue*/ 4) set_data_dev(t2, /*fieldValue*/ ctx[2]);
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index !== previous_block_index) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(button, null);
				}

				if (!current || dirty & /*hoverEffect*/ 8 && div0_class_value !== (div0_class_value = "py-1 px-3 w-full flex justify-between items-center text-base " + (/*hoverEffect*/ ctx[3]
				? 'text-osvauld-fieldTextActive bg-osvauld-fieldActive rounded-md'
				: 'text-osvauld-fieldText rounded-none border-b border-osvauld-darkLineSeperator'))) {
					attr_dev(div0, "class", div0_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$G.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$G($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('PlainField', slots, []);
		let { fieldName } = $$props;
		let { fieldValue } = $$props;
		let { hoverEffect } = $$props;
		let { copied = false } = $$props;

		const copyToClipboard = async () => {
			$$invalidate(0, copied = true);
			await writeToClipboard(fieldValue);

			setTimeout(
				() => {
					$$invalidate(0, copied = false);
				},
				2000
			);
		};

		$$self.$$.on_mount.push(function () {
			if (fieldName === undefined && !('fieldName' in $$props || $$self.$$.bound[$$self.$$.props['fieldName']])) {
				console.warn("<PlainField> was created without expected prop 'fieldName'");
			}

			if (fieldValue === undefined && !('fieldValue' in $$props || $$self.$$.bound[$$self.$$.props['fieldValue']])) {
				console.warn("<PlainField> was created without expected prop 'fieldValue'");
			}

			if (hoverEffect === undefined && !('hoverEffect' in $$props || $$self.$$.bound[$$self.$$.props['hoverEffect']])) {
				console.warn("<PlainField> was created without expected prop 'hoverEffect'");
			}
		});

		const writable_props = ['fieldName', 'fieldValue', 'hoverEffect', 'copied'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlainField> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('fieldName' in $$props) $$invalidate(1, fieldName = $$props.fieldName);
			if ('fieldValue' in $$props) $$invalidate(2, fieldValue = $$props.fieldValue);
			if ('hoverEffect' in $$props) $$invalidate(3, hoverEffect = $$props.hoverEffect);
			if ('copied' in $$props) $$invalidate(0, copied = $$props.copied);
		};

		$$self.$capture_state = () => ({
			scale,
			ActiveCopy,
			Tick,
			CopyIcon,
			writeToClipboard,
			fieldName,
			fieldValue,
			hoverEffect,
			copied,
			copyToClipboard
		});

		$$self.$inject_state = $$props => {
			if ('fieldName' in $$props) $$invalidate(1, fieldName = $$props.fieldName);
			if ('fieldValue' in $$props) $$invalidate(2, fieldValue = $$props.fieldValue);
			if ('hoverEffect' in $$props) $$invalidate(3, hoverEffect = $$props.hoverEffect);
			if ('copied' in $$props) $$invalidate(0, copied = $$props.copied);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [copied, fieldName, fieldValue, hoverEffect, copyToClipboard];
	}

	class PlainField extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$G, create_fragment$G, safe_not_equal, {
				fieldName: 1,
				fieldValue: 2,
				hoverEffect: 3,
				copied: 0
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "PlainField",
				options,
				id: create_fragment$G.name
			});
		}

		get fieldName() {
			throw new Error("<PlainField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set fieldName(value) {
			throw new Error("<PlainField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get fieldValue() {
			throw new Error("<PlainField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set fieldValue(value) {
			throw new Error("<PlainField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get hoverEffect() {
			throw new Error("<PlainField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set hoverEffect(value) {
			throw new Error("<PlainField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get copied() {
			throw new Error("<PlainField>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set copied(value) {
			throw new Error("<PlainField>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/**
	 * @param {any} obj
	 * @returns {boolean}
	 */
	function is_date(obj) {
		return Object.prototype.toString.call(obj) === '[object Date]';
	}

	/** @returns {(t: any) => any} */
	function get_interpolator(a, b) {
		if (a === b || a !== a) return () => a;
		const type = typeof a;
		if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
			throw new Error('Cannot interpolate values of different type');
		}
		if (Array.isArray(a)) {
			const arr = b.map((bi, i) => {
				return get_interpolator(a[i], bi);
			});
			return (t) => arr.map((fn) => fn(t));
		}
		if (type === 'object') {
			if (!a || !b) throw new Error('Object cannot be null');
			if (is_date(a) && is_date(b)) {
				a = a.getTime();
				b = b.getTime();
				const delta = b - a;
				return (t) => new Date(a + t * delta);
			}
			const keys = Object.keys(b);
			const interpolators = {};
			keys.forEach((key) => {
				interpolators[key] = get_interpolator(a[key], b[key]);
			});
			return (t) => {
				const result = {};
				keys.forEach((key) => {
					result[key] = interpolators[key](t);
				});
				return result;
			};
		}
		if (type === 'number') {
			const delta = b - a;
			return (t) => a + t * delta;
		}
		throw new Error(`Cannot interpolate ${type} values`);
	}

	/**
	 * A tweened store in Svelte is a special type of store that provides smooth transitions between state values over time.
	 *
	 * https://svelte.dev/docs/svelte-motion#tweened
	 * @template T
	 * @param {T} [value]
	 * @param {import('./private.js').TweenedOptions<T>} [defaults]
	 * @returns {import('./public.js').Tweened<T>}
	 */
	function tweened(value, defaults = {}) {
		const store = writable(value);
		/** @type {import('../internal/private.js').Task} */
		let task;
		let target_value = value;
		/**
		 * @param {T} new_value
		 * @param {import('./private.js').TweenedOptions<T>} [opts]
		 */
		function set(new_value, opts) {
			if (value == null) {
				store.set((value = new_value));
				return Promise.resolve();
			}
			target_value = new_value;
			let previous_task = task;
			let started = false;
			let {
				delay = 0,
				duration = 400,
				easing = identity,
				interpolate = get_interpolator
			} = assign(assign({}, defaults), opts);
			if (duration === 0) {
				if (previous_task) {
					previous_task.abort();
					previous_task = null;
				}
				store.set((value = target_value));
				return Promise.resolve();
			}
			const start = now() + delay;
			let fn;
			task = loop((now) => {
				if (now < start) return true;
				if (!started) {
					fn = interpolate(value, new_value);
					if (typeof duration === 'function') duration = duration(value, new_value);
					started = true;
				}
				if (previous_task) {
					previous_task.abort();
					previous_task = null;
				}
				const elapsed = now - start;
				if (elapsed > /** @type {number} */ (duration)) {
					store.set((value = new_value));
					return false;
				}
				// @ts-ignore
				store.set((value = fn(easing(elapsed / duration))));
				return true;
			});
			return task.promise;
		}
		return {
			set,
			update: (fn, opts) => set(fn(target_value, value), opts),
			subscribe: store.subscribe
		};
	}

	/* src/lib/components/dashboard/credentials/CredentialCard.svelte generated by Svelte v4.2.19 */
	const file$F = "src/lib/components/dashboard/credentials/CredentialCard.svelte";

	function get_each_context$f(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[19] = list[i];
		return child_ctx;
	}

	function get_each_context_1$2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[19] = list[i];
		return child_ctx;
	}

	// (132:3) {#if credential.accessType === "manager" && !privateFolder}
	function create_if_block_5$6(ctx) {
		let input;
		let input_id_value;
		let input_class_value;
		let mounted;
		let dispose;

		const block = {
			c: function create() {
				input = element("input");
				attr_dev(input, "type", "checkbox");
				attr_dev(input, "id", input_id_value = /*credential*/ ctx[1].credentialId);

				attr_dev(input, "class", input_class_value = "bg-osvauld-cardshade mr-2 " + (/*hoverEffect*/ ctx[4]
				? 'border-osvauld-placeholderblack'
				: 'border-osvauld-darkLineSeperator') + " checked:bg-osvauld-activelavender focus:text-osvauld-activelavender hover:text-osvauld-activelavender active:outline-none focus:ring-offset-0 focus:ring-0 cursor-pointer" + " svelte-12kbqpt");

				input.checked = /*checked*/ ctx[0];
				add_location(input, file$F, 145, 4, 3825);
			},
			m: function mount(target, anchor) {
				insert_dev(target, input, anchor);

				if (!mounted) {
					dispose = listen_dev(input, "change", stop_propagation(/*change_handler*/ ctx[14]), false, false, true, false);
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (dirty & /*credential*/ 2 && input_id_value !== (input_id_value = /*credential*/ ctx[1].credentialId)) {
					attr_dev(input, "id", input_id_value);
				}

				if (dirty & /*hoverEffect*/ 16 && input_class_value !== (input_class_value = "bg-osvauld-cardshade mr-2 " + (/*hoverEffect*/ ctx[4]
				? 'border-osvauld-placeholderblack'
				: 'border-osvauld-darkLineSeperator') + " checked:bg-osvauld-activelavender focus:text-osvauld-activelavender hover:text-osvauld-activelavender active:outline-none focus:ring-offset-0 focus:ring-0 cursor-pointer" + " svelte-12kbqpt")) {
					attr_dev(input, "class", input_class_value);
				}

				if (dirty & /*checked*/ 1) {
					prop_dev(input, "checked", /*checked*/ ctx[0]);
				}
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(input);
				}

				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_5$6.name,
			type: "if",
			source: "(132:3) {#if credential.accessType === \\\"manager\\\" && !privateFolder}",
			ctx
		});

		return block;
	}

	// (154:3) {#if credential.accessType === "manager"}
	function create_if_block_4$7(ctx) {
		let button;
		let more;
		let current;
		let mounted;
		let dispose;
		more = new More({ $$inline: true });

		const block = {
			c: function create() {
				button = element("button");
				create_component(more.$$.fragment);
				attr_dev(button, "class", "pr-2");
				add_location(button, file$F, 167, 4, 4644);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				mount_component(more, button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", /*triggerMoreActions*/ ctx[10], false, false, false, false);
					mounted = true;
				}
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(more.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(more.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(more);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_4$7.name,
			type: "if",
			source: "(154:3) {#if credential.accessType === \\\"manager\\\"}",
			ctx
		});

		return block;
	}

	// (192:3) {:else}
	function create_else_block$k(ctx) {
		let div1;
		let label;
		let t1;
		let div0;
		let t2_value = /*credential*/ ctx[1].fields[0].fieldValue + "";
		let t2;
		let div0_class_value;

		const block = {
			c: function create() {
				div1 = element("div");
				label = element("label");
				label.textContent = "Note";
				t1 = space();
				div0 = element("div");
				t2 = text(t2_value);
				attr_dev(label, "class", "text-osvauld-dusklabel block text-left text-xs font-normal");
				attr_dev(label, "for", "Note");
				add_location(label, file$F, 206, 5, 5690);

				attr_dev(div0, "class", div0_class_value = "mt-1 w-[14.3rem] h-[10rem] py-1 px-2 overflow-y-scroll rounded-lg text-left scrollbar-thin resize-none text-sm " + (/*hoverEffect*/ ctx[4]
				? 'text-osvauld-fieldTextActive bg-osvauld-fieldActive'
				: 'text-osvauld-fieldText'));

				attr_dev(div0, "id", "credential-description");
				add_location(div0, file$F, 212, 5, 5824);
				add_location(div1, file$F, 205, 4, 5679);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, label);
				append_dev(div1, t1);
				append_dev(div1, div0);
				append_dev(div0, t2);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*credential*/ 2 && t2_value !== (t2_value = /*credential*/ ctx[1].fields[0].fieldValue + "")) set_data_dev(t2, t2_value);

				if (dirty & /*hoverEffect*/ 16 && div0_class_value !== (div0_class_value = "mt-1 w-[14.3rem] h-[10rem] py-1 px-2 overflow-y-scroll rounded-lg text-left scrollbar-thin resize-none text-sm " + (/*hoverEffect*/ ctx[4]
				? 'text-osvauld-fieldTextActive bg-osvauld-fieldActive'
				: 'text-osvauld-fieldText'))) {
					attr_dev(div0, "class", div0_class_value);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$k.name,
			type: "else",
			source: "(192:3) {:else}",
			ctx
		});

		return block;
	}

	// (170:3) {#if credential.credentialType !== "Note"}
	function create_if_block$t(ctx) {
		let t;
		let if_block_anchor;
		let current;
		let each_value_1 = ensure_array_like_dev(/*credential*/ ctx[1].fields);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let if_block = /*sensitiveFields*/ ctx[3] && create_if_block_1$m(ctx);

		const block = {
			c: function create() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert_dev(target, t, anchor);
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty & /*credential, hoverEffect*/ 18) {
					each_value_1 = ensure_array_like_dev(/*credential*/ ctx[1].fields);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1$2(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(t.parentNode, t);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (/*sensitiveFields*/ ctx[3]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*sensitiveFields*/ 8) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_1$m(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
					detach_dev(if_block_anchor);
				}

				destroy_each(each_blocks, detaching);
				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$t.name,
			type: "if",
			source: "(170:3) {#if credential.credentialType !== \\\"Note\\\"}",
			ctx
		});

		return block;
	}

	// (172:5) {#if field.fieldName !== "Domain" && field.fieldName && field.fieldValue}
	function create_if_block_3$b(ctx) {
		let plainfield;
		let current;

		plainfield = new PlainField({
				props: {
					fieldName: /*field*/ ctx[19].fieldName,
					fieldValue: /*field*/ ctx[19].fieldValue,
					hoverEffect: /*hoverEffect*/ ctx[4]
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(plainfield.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(plainfield, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const plainfield_changes = {};
				if (dirty & /*credential*/ 2) plainfield_changes.fieldName = /*field*/ ctx[19].fieldName;
				if (dirty & /*credential*/ 2) plainfield_changes.fieldValue = /*field*/ ctx[19].fieldValue;
				if (dirty & /*hoverEffect*/ 16) plainfield_changes.hoverEffect = /*hoverEffect*/ ctx[4];
				plainfield.$set(plainfield_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(plainfield.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(plainfield.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(plainfield, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$b.name,
			type: "if",
			source: "(172:5) {#if field.fieldName !== \\\"Domain\\\" && field.fieldName && field.fieldValue}",
			ctx
		});

		return block;
	}

	// (171:4) {#each credential.fields as field}
	function create_each_block_1$2(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*field*/ ctx[19].fieldName !== "Domain" && /*field*/ ctx[19].fieldName && /*field*/ ctx[19].fieldValue && create_if_block_3$b(ctx);

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (/*field*/ ctx[19].fieldName !== "Domain" && /*field*/ ctx[19].fieldName && /*field*/ ctx[19].fieldValue) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*credential*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_3$b(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block_1$2.name,
			type: "each",
			source: "(171:4) {#each credential.fields as field}",
			ctx
		});

		return block;
	}

	// (180:4) {#if sensitiveFields}
	function create_if_block_1$m(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like_dev(/*sensitiveFields*/ ctx[3]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m: function mount(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert_dev(target, each_1_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty & /*sensitiveFields, hoverEffect*/ 24) {
					each_value = ensure_array_like_dev(/*sensitiveFields*/ ctx[3]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$f(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$f(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$m.name,
			type: "if",
			source: "(180:4) {#if sensitiveFields}",
			ctx
		});

		return block;
	}

	// (182:6) {#if field.fieldName && field.fieldValue}
	function create_if_block_2$g(ctx) {
		let encryptedfield;
		let current;

		encryptedfield = new EncryptedField({
				props: {
					fieldName: /*field*/ ctx[19].fieldName,
					fieldValue: /*field*/ ctx[19].fieldValue,
					fieldType: /*field*/ ctx[19].fieldType,
					hoverEffect: /*hoverEffect*/ ctx[4]
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(encryptedfield.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(encryptedfield, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const encryptedfield_changes = {};
				if (dirty & /*sensitiveFields*/ 8) encryptedfield_changes.fieldName = /*field*/ ctx[19].fieldName;
				if (dirty & /*sensitiveFields*/ 8) encryptedfield_changes.fieldValue = /*field*/ ctx[19].fieldValue;
				if (dirty & /*sensitiveFields*/ 8) encryptedfield_changes.fieldType = /*field*/ ctx[19].fieldType;
				if (dirty & /*hoverEffect*/ 16) encryptedfield_changes.hoverEffect = /*hoverEffect*/ ctx[4];
				encryptedfield.$set(encryptedfield_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(encryptedfield.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(encryptedfield.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(encryptedfield, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$g.name,
			type: "if",
			source: "(182:6) {#if field.fieldName && field.fieldValue}",
			ctx
		});

		return block;
	}

	// (181:5) {#each sensitiveFields as field}
	function create_each_block$f(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*field*/ ctx[19].fieldName && /*field*/ ctx[19].fieldValue && create_if_block_2$g(ctx);

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (/*field*/ ctx[19].fieldName && /*field*/ ctx[19].fieldValue) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*sensitiveFields*/ 8) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_2$g(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$f.name,
			type: "each",
			source: "(181:5) {#each sensitiveFields as field}",
			ctx
		});

		return block;
	}

	function create_fragment$F(ctx) {
		let button2;
		let button1;
		let button0;
		let t0;
		let label0;
		let t1_value = /*credential*/ ctx[1].name + "";
		let t1;
		let label0_class_value;
		let label0_for_value;
		let t2;
		let button0_class_value;
		let t3;
		let div0;
		let t4;
		let div1;
		let current_block_type_index;
		let if_block2;
		let div1_class_value;
		let t5;
		let div3;
		let label1;
		let t7;
		let div2;
		let t8_value = /*credential*/ ctx[1].description + "";
		let t8;
		let div2_class_value;
		let div3_class_value;
		let button2_class_value;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*credential*/ ctx[1].accessType === "manager" && !/*privateFolder*/ ctx[2] && create_if_block_5$6(ctx);
		let if_block1 = /*credential*/ ctx[1].accessType === "manager" && create_if_block_4$7(ctx);
		const if_block_creators = [create_if_block$t, create_else_block$k];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*credential*/ ctx[1].credentialType !== "Note") return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				button2 = element("button");
				button1 = element("button");
				button0 = element("button");
				if (if_block0) if_block0.c();
				t0 = space();
				label0 = element("label");
				t1 = text(t1_value);
				t2 = space();
				if (if_block1) if_block1.c();
				t3 = space();
				div0 = element("div");
				t4 = space();
				div1 = element("div");
				if_block2.c();
				t5 = space();
				div3 = element("div");
				label1 = element("label");
				label1.textContent = "Description";
				t7 = space();
				div2 = element("div");
				t8 = text(t8_value);

				attr_dev(label0, "class", label0_class_value = "text-lg font-light text-left ml-2 cursor-pointer w-[10rem] overflow-x-hidden whitespace-nowrap " + (/*hoverEffect*/ ctx[4]
				? 'text-osvauld-sideListTextActive'
				: 'text-osvauld-fieldTextActive ') + "");

				attr_dev(label0, "for", label0_for_value = /*credential*/ ctx[1].credentialId);
				add_location(label0, file$F, 158, 3, 4311);

				attr_dev(button0, "class", button0_class_value = "flex " + (/*credential*/ ctx[1].accessType !== 'manager' && !/*privateFolder*/ ctx[2]
				? 'justify-start'
				: 'justify-center') + " items-center border-osvauld-iconblack pb-2");

				add_location(button0, file$F, 138, 2, 3558);
				attr_dev(div0, "class", "border-b border-osvauld-iconblack w-[calc(100%+1.5rem)] -translate-x-3");
				add_location(div0, file$F, 172, 2, 4749);

				attr_dev(div1, "class", div1_class_value = "w-[15rem] " + (/*credential*/ ctx[1].description.length !== 0
				? 'h-[11.5rem]'
				: 'h-[15rem]') + " overflow-y-scroll scrollbar-thin pr-0 " + (/*hoverEffect*/ ctx[4] ? 'active' : '') + " mt-2");

				add_location(div1, file$F, 175, 2, 4848);
				attr_dev(label1, "class", "text-osvauld-dusklabel block text-left text-xs font-normal");
				attr_dev(label1, "for", "credential-description");
				add_location(label1, file$F, 227, 3, 6280);

				attr_dev(div2, "class", div2_class_value = "mt-1 w-[14.3rem] " + (/*credential*/ ctx[1].description.length !== 0
				? 'h-[4rem]'
				: '') + " py-1 px-2 overflow-y-scroll rounded-lg text-left scrollbar-thin resize-none text-sm " + (/*hoverEffect*/ ctx[4]
				? 'text-osvauld-fieldTextActive bg-osvauld-fieldActive'
				: 'text-osvauld-fieldText'));

				attr_dev(div2, "id", "credential-description");
				add_location(div2, file$F, 233, 3, 6427);

				attr_dev(div3, "class", div3_class_value = /*credential*/ ctx[1].description.length !== 0
				? 'visible'
				: 'invisible');

				add_location(div3, file$F, 224, 2, 6193);
				attr_dev(button1, "class", "container mx-auto py-3 pl-3 pr-1 relative group bg-osvauld-cardshade rounded-xl");
				add_location(button1, file$F, 134, 1, 3418);
				attr_dev(button2, "class", button2_class_value = "mb-1 overflow-x-hidden flex-none rounded-xl text-osvauld-chalkwhite border border-osvauld-iconblack " + (/*checked*/ ctx[0] && 'shadow-[0_0_0_1px_#B4BEFE]'));
				set_style(button2, "border", /*$borderHighLight*/ ctx[5] ? '1px solid #89B4FA' : '');
				add_location(button2, file$F, 126, 0, 3093);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, button2, anchor);
				append_dev(button2, button1);
				append_dev(button1, button0);
				if (if_block0) if_block0.m(button0, null);
				append_dev(button0, t0);
				append_dev(button0, label0);
				append_dev(label0, t1);
				append_dev(button0, t2);
				if (if_block1) if_block1.m(button0, null);
				append_dev(button1, t3);
				append_dev(button1, div0);
				append_dev(button1, t4);
				append_dev(button1, div1);
				if_blocks[current_block_type_index].m(div1, null);
				append_dev(button1, t5);
				append_dev(button1, div3);
				append_dev(div3, label1);
				append_dev(div3, t7);
				append_dev(div3, div2);
				append_dev(div2, t8);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*click_handler*/ ctx[13]), false, false, true, false),
						listen_dev(button2, "mouseenter", /*handleMouseEnter*/ ctx[8], false, false, false, false),
						listen_dev(button2, "mouseleave", /*handleMouseLeave*/ ctx[9], false, false, false, false),
						listen_dev(button2, "click", /*handleClick*/ ctx[11], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (/*credential*/ ctx[1].accessType === "manager" && !/*privateFolder*/ ctx[2]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_5$6(ctx);
						if_block0.c();
						if_block0.m(button0, t0);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if ((!current || dirty & /*credential*/ 2) && t1_value !== (t1_value = /*credential*/ ctx[1].name + "")) set_data_dev(t1, t1_value);

				if (!current || dirty & /*hoverEffect*/ 16 && label0_class_value !== (label0_class_value = "text-lg font-light text-left ml-2 cursor-pointer w-[10rem] overflow-x-hidden whitespace-nowrap " + (/*hoverEffect*/ ctx[4]
				? 'text-osvauld-sideListTextActive'
				: 'text-osvauld-fieldTextActive ') + "")) {
					attr_dev(label0, "class", label0_class_value);
				}

				if (!current || dirty & /*credential*/ 2 && label0_for_value !== (label0_for_value = /*credential*/ ctx[1].credentialId)) {
					attr_dev(label0, "for", label0_for_value);
				}

				if (/*credential*/ ctx[1].accessType === "manager") {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*credential*/ 2) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_4$7(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(button0, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*credential, privateFolder*/ 6 && button0_class_value !== (button0_class_value = "flex " + (/*credential*/ ctx[1].accessType !== 'manager' && !/*privateFolder*/ ctx[2]
				? 'justify-start'
				: 'justify-center') + " items-center border-osvauld-iconblack pb-2")) {
					attr_dev(button0, "class", button0_class_value);
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block2 = if_blocks[current_block_type_index];

					if (!if_block2) {
						if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block2.c();
					} else {
						if_block2.p(ctx, dirty);
					}

					transition_in(if_block2, 1);
					if_block2.m(div1, null);
				}

				if (!current || dirty & /*credential, hoverEffect*/ 18 && div1_class_value !== (div1_class_value = "w-[15rem] " + (/*credential*/ ctx[1].description.length !== 0
				? 'h-[11.5rem]'
				: 'h-[15rem]') + " overflow-y-scroll scrollbar-thin pr-0 " + (/*hoverEffect*/ ctx[4] ? 'active' : '') + " mt-2")) {
					attr_dev(div1, "class", div1_class_value);
				}

				if ((!current || dirty & /*credential*/ 2) && t8_value !== (t8_value = /*credential*/ ctx[1].description + "")) set_data_dev(t8, t8_value);

				if (!current || dirty & /*credential, hoverEffect*/ 18 && div2_class_value !== (div2_class_value = "mt-1 w-[14.3rem] " + (/*credential*/ ctx[1].description.length !== 0
				? 'h-[4rem]'
				: '') + " py-1 px-2 overflow-y-scroll rounded-lg text-left scrollbar-thin resize-none text-sm " + (/*hoverEffect*/ ctx[4]
				? 'text-osvauld-fieldTextActive bg-osvauld-fieldActive'
				: 'text-osvauld-fieldText'))) {
					attr_dev(div2, "class", div2_class_value);
				}

				if (!current || dirty & /*credential*/ 2 && div3_class_value !== (div3_class_value = /*credential*/ ctx[1].description.length !== 0
				? 'visible'
				: 'invisible')) {
					attr_dev(div3, "class", div3_class_value);
				}

				if (!current || dirty & /*checked*/ 1 && button2_class_value !== (button2_class_value = "mb-1 overflow-x-hidden flex-none rounded-xl text-osvauld-chalkwhite border border-osvauld-iconblack " + (/*checked*/ ctx[0] && 'shadow-[0_0_0_1px_#B4BEFE]'))) {
					attr_dev(button2, "class", button2_class_value);
				}

				if (!current || dirty & /*$borderHighLight*/ 32) {
					set_style(button2, "border", /*$borderHighLight*/ ctx[5] ? '1px solid #89B4FA' : '');
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block1);
				transition_in(if_block2);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block1);
				transition_out(if_block2);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button2);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				if_blocks[current_block_type_index].d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$F.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$F($$self, $$props, $$invalidate) {
		let $showCredentialDetailsDrawer;
		let $searchedCredential;
		let $borderHighLight;
		validate_store(showCredentialDetailsDrawer, 'showCredentialDetailsDrawer');
		component_subscribe($$self, showCredentialDetailsDrawer, $$value => $$invalidate(17, $showCredentialDetailsDrawer = $$value));
		validate_store(searchedCredential, 'searchedCredential');
		component_subscribe($$self, searchedCredential, $$value => $$invalidate(12, $searchedCredential = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('CredentialCard', slots, []);
		const dispatch = createEventDispatcher();
		let { credential } = $$props;
		let { checked = false } = $$props;
		let { privateFolder } = $$props;
		let sensitiveFields = [];
		let decrypted = false;
		let hoverEffect = false;
		let hoverTimeout;
		let borderHighLight = tweened(0, { duration: 700 });
		validate_store(borderHighLight, 'borderHighLight');
		component_subscribe($$self, borderHighLight, value => $$invalidate(5, $borderHighLight = value));

		function toggleCheck() {
			$$invalidate(0, checked = !checked);
			dispatch("check", checked);
		}

		function handleMouseEnter() {
			$$invalidate(4, hoverEffect = true);

			if (!decrypted) {
				hoverTimeout = setTimeout(
					async () => {
						const response = await fetchSensitiveFieldsByCredentialId(credential.credentialId);
						$$invalidate(3, sensitiveFields = response.data);
					},
					300
				);
			}
		}

		function handleMouseLeave() {
			if (!$showCredentialDetailsDrawer) {
				$$invalidate(3, sensitiveFields = []);
			}

			clearTimeout(hoverTimeout);
			decrypted = false;
			$$invalidate(4, hoverEffect = false);
		}

		const triggerMoreActions = e => {
			buttonRef.set(e.currentTarget);

			modalManager.set({
				id: credential.credentialId,
				name: credential.name,
				type: "Credential"
			});

			dispatch("action", true);
			showMoreOptions.set(true);
		};

		const handleClick = async () => {
			if (sensitiveFields.length) {
				clearTimeout(hoverTimeout);
				const response = await fetchSensitiveFieldsByCredentialId(credential.credentialId);
				$$invalidate(3, sensitiveFields = response.data);
			}

			dispatch("select", sensitiveFields);
			$$invalidate(3, sensitiveFields = []);
		}; /* eslint-disable */

		$$self.$$.on_mount.push(function () {
			if (credential === undefined && !('credential' in $$props || $$self.$$.bound[$$self.$$.props['credential']])) {
				console.warn("<CredentialCard> was created without expected prop 'credential'");
			}

			if (privateFolder === undefined && !('privateFolder' in $$props || $$self.$$.bound[$$self.$$.props['privateFolder']])) {
				console.warn("<CredentialCard> was created without expected prop 'privateFolder'");
			}
		});

		const writable_props = ['credential', 'checked', 'privateFolder'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CredentialCard> was created with unknown prop '${key}'`);
		});

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		const change_handler = e => {
			toggleCheck();
		};

		$$self.$$set = $$props => {
			if ('credential' in $$props) $$invalidate(1, credential = $$props.credential);
			if ('checked' in $$props) $$invalidate(0, checked = $$props.checked);
			if ('privateFolder' in $$props) $$invalidate(2, privateFolder = $$props.privateFolder);
		};

		$$self.$capture_state = () => ({
			createEventDispatcher,
			fetchSensitiveFieldsByCredentialId,
			EncryptedField,
			PlainField,
			More,
			showCredentialDetailsDrawer,
			searchedCredential,
			showMoreOptions,
			buttonRef,
			modalManager,
			tweened,
			dispatch,
			credential,
			checked,
			privateFolder,
			sensitiveFields,
			decrypted,
			hoverEffect,
			hoverTimeout,
			borderHighLight,
			toggleCheck,
			handleMouseEnter,
			handleMouseLeave,
			triggerMoreActions,
			handleClick,
			$showCredentialDetailsDrawer,
			$searchedCredential,
			$borderHighLight
		});

		$$self.$inject_state = $$props => {
			if ('credential' in $$props) $$invalidate(1, credential = $$props.credential);
			if ('checked' in $$props) $$invalidate(0, checked = $$props.checked);
			if ('privateFolder' in $$props) $$invalidate(2, privateFolder = $$props.privateFolder);
			if ('sensitiveFields' in $$props) $$invalidate(3, sensitiveFields = $$props.sensitiveFields);
			if ('decrypted' in $$props) decrypted = $$props.decrypted;
			if ('hoverEffect' in $$props) $$invalidate(4, hoverEffect = $$props.hoverEffect);
			if ('hoverTimeout' in $$props) hoverTimeout = $$props.hoverTimeout;
			if ('borderHighLight' in $$props) $$invalidate(6, borderHighLight = $$props.borderHighLight);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*$searchedCredential, credential*/ 4098) {
				{
					if ($searchedCredential?.credentialId === credential.credentialId) {
						borderHighLight.set(1);

						setTimeout(
							() => {
								borderHighLight.set(0);
								searchedCredential.set(null);
							},
							500
						);
					}
				}
			}
		};

		return [
			checked,
			credential,
			privateFolder,
			sensitiveFields,
			hoverEffect,
			$borderHighLight,
			borderHighLight,
			toggleCheck,
			handleMouseEnter,
			handleMouseLeave,
			triggerMoreActions,
			handleClick,
			$searchedCredential,
			click_handler,
			change_handler
		];
	}

	class CredentialCard extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$F, create_fragment$F, safe_not_equal, {
				credential: 1,
				checked: 0,
				privateFolder: 2
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "CredentialCard",
				options,
				id: create_fragment$F.name
			});
		}

		get credential() {
			throw new Error("<CredentialCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set credential(value) {
			throw new Error("<CredentialCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get checked() {
			throw new Error("<CredentialCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set checked(value) {
			throw new Error("<CredentialCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get privateFolder() {
			throw new Error("<CredentialCard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set privateFolder(value) {
			throw new Error("<CredentialCard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/components/ExistingListItem.svelte generated by Svelte v4.2.19 */
	const file$E = "src/lib/components/dashboard/components/ExistingListItem.svelte";

	// (83:66) 
	function create_if_block_5$5(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*editPermissionTrigger*/ ctx[3] && create_if_block_6$5(ctx);

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (/*editPermissionTrigger*/ ctx[3]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*editPermissionTrigger*/ 8) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_6$5(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_5$5.name,
			type: "if",
			source: "(83:66) ",
			ctx
		});

		return block;
	}

	// (68:1) {#if (item.accessSource && item.accessSource === "acquired") || !item.accessSource}
	function create_if_block_1$l(ctx) {
		let t;
		let if_block1_anchor;
		let current;
		let if_block0 = /*accessSelectorIdentifier*/ ctx[5] === /*index*/ ctx[1] && create_if_block_4$6(ctx);
		let if_block1 = /*editPermissionTrigger*/ ctx[3] && create_if_block_2$f(ctx);

		const block = {
			c: function create() {
				if (if_block0) if_block0.c();
				t = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
			},
			m: function mount(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert_dev(target, t, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert_dev(target, if_block1_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (/*accessSelectorIdentifier*/ ctx[5] === /*index*/ ctx[1]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*accessSelectorIdentifier, index*/ 34) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_4$6(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t.parentNode, t);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*editPermissionTrigger*/ ctx[3]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*editPermissionTrigger*/ 8) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_2$f(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
					detach_dev(if_block1_anchor);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$l.name,
			type: "if",
			source: "(68:1) {#if (item.accessSource && item.accessSource === \\\"acquired\\\") || !item.accessSource}",
			ctx
		});

		return block;
	}

	// (84:2) {#if editPermissionTrigger}
	function create_if_block_6$5(ctx) {
		let span;
		let infoicon;
		let t;
		let current;
		let mounted;
		let dispose;
		infoicon = new InfoIcon({ $$inline: true });
		let if_block = /*showTooltip*/ ctx[6] && create_if_block_7$3(ctx);

		const block = {
			c: function create() {
				span = element("span");
				create_component(infoicon.$$.fragment);
				t = space();
				if (if_block) if_block.c();
				attr_dev(span, "class", "ml-auto relative");
				attr_dev(span, "role", "button");
				attr_dev(span, "tabindex", "-1");
				add_location(span, file$E, 93, 3, 2539);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				mount_component(infoicon, span, null);
				append_dev(span, t);
				if (if_block) if_block.m(span, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(span, "mouseenter", /*mouseenter_handler*/ ctx[13], false, false, false, false),
						listen_dev(span, "mouseleave", /*mouseleave_handler*/ ctx[14], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (/*showTooltip*/ ctx[6]) {
					if (if_block) ; else {
						if_block = create_if_block_7$3(ctx);
						if_block.c();
						if_block.m(span, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(infoicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(infoicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				destroy_component(infoicon);
				if (if_block) if_block.d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_6$5.name,
			type: "if",
			source: "(84:2) {#if editPermissionTrigger}",
			ctx
		});

		return block;
	}

	// (93:4) {#if showTooltip}
	function create_if_block_7$3(ctx) {
		let div;

		const block = {
			c: function create() {
				div = element("div");
				div.textContent = "Inherited from folder";
				attr_dev(div, "class", "tooltip svelte-1bdwav");
				add_location(div, file$E, 102, 5, 2758);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_7$3.name,
			type: "if",
			source: "(93:4) {#if showTooltip}",
			ctx
		});

		return block;
	}

	// (69:2) {#if accessSelectorIdentifier === index}
	function create_if_block_4$6(ctx) {
		let accessselector;
		let current;

		accessselector = new AccessSelector({
				props: { reverseModal: /*reverseModal*/ ctx[4] },
				$$inline: true
			});

		accessselector.$on("select", /*select_handler*/ ctx[11]);
		accessselector.$on("closeSelector", /*closeSelector_handler*/ ctx[12]);

		const block = {
			c: function create() {
				create_component(accessselector.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(accessselector, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const accessselector_changes = {};
				if (dirty & /*reverseModal*/ 16) accessselector_changes.reverseModal = /*reverseModal*/ ctx[4];
				accessselector.$set(accessselector_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(accessselector.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(accessselector.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(accessselector, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_4$6.name,
			type: "if",
			source: "(69:2) {#if accessSelectorIdentifier === index}",
			ctx
		});

		return block;
	}

	// (76:2) {#if editPermissionTrigger}
	function create_if_block_2$f(ctx) {
		let button;
		let current;
		let mounted;
		let dispose;
		let if_block = (/*item*/ ctx[0].accessSource === "acquired" || !/*isUser*/ ctx[2]) && create_if_block_3$a(ctx);

		const block = {
			c: function create() {
				button = element("button");
				if (if_block) if_block.c();
				attr_dev(button, "class", "ml-auto");
				add_location(button, file$E, 85, 3, 2282);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				if (if_block) if_block.m(button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", /*handleItemRemove*/ ctx[8], false, false, false, false);
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (/*item*/ ctx[0].accessSource === "acquired" || !/*isUser*/ ctx[2]) {
					if (if_block) {
						if (dirty & /*item, isUser*/ 5) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_3$a(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(button, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				if (if_block) if_block.d();
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$f.name,
			type: "if",
			source: "(76:2) {#if editPermissionTrigger}",
			ctx
		});

		return block;
	}

	// (78:4) {#if item.accessSource === "acquired" || !isUser}
	function create_if_block_3$a(ctx) {
		let binicon;
		let current;
		binicon = new BinIcon({ $$inline: true });

		const block = {
			c: function create() {
				create_component(binicon.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(binicon, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(binicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(binicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(binicon, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$a.name,
			type: "if",
			source: "(78:4) {#if item.accessSource === \\\"acquired\\\" || !isUser}",
			ctx
		});

		return block;
	}

	// (105:3) {#if editPermissionTrigger && ((item.accessSource && item.accessSource === "acquired") || !item.accessSource)}
	function create_if_block$s(ctx) {
		let downarrow;
		let current;

		downarrow = new DownArrow({
				props: { type: /*item*/ ctx[0].accessType },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(downarrow.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(downarrow, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const downarrow_changes = {};
				if (dirty & /*item*/ 1) downarrow_changes.type = /*item*/ ctx[0].accessType;
				downarrow.$set(downarrow_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(downarrow.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(downarrow.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(downarrow, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$s.name,
			type: "if",
			source: "(105:3) {#if editPermissionTrigger && ((item.accessSource && item.accessSource === \\\"acquired\\\") || !item.accessSource)}",
			ctx
		});

		return block;
	}

	function create_fragment$E(ctx) {
		let div2;
		let div0;
		let p;
		let t0_value = /*item*/ ctx[0].name + "";
		let t0;
		let t1;
		let current_block_type_index;
		let if_block0;
		let t2;
		let div1;
		let button;
		let span;

		let t3_value = (/*item*/ ctx[0].accessType === "manager"
		? "Manager"
		: "Reader") + "";

		let t3;
		let t4;
		let button_class_value;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block_1$l, create_if_block_5$5];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*item*/ ctx[0].accessSource && /*item*/ ctx[0].accessSource === "acquired" || !/*item*/ ctx[0].accessSource) return 0;
			if (/*item*/ ctx[0].accessSource && /*item*/ ctx[0].accessSource === "inherited") return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		let if_block1 = /*editPermissionTrigger*/ ctx[3] && (/*item*/ ctx[0].accessSource && /*item*/ ctx[0].accessSource === "acquired" || !/*item*/ ctx[0].accessSource) && create_if_block$s(ctx);

		const block = {
			c: function create() {
				div2 = element("div");
				div0 = element("div");
				p = element("p");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				div1 = element("div");
				button = element("button");
				span = element("span");
				t3 = text(t3_value);
				t4 = space();
				if (if_block1) if_block1.c();
				attr_dev(p, "class", "p-1 w-3/4 whitespace-nowrap");
				add_location(p, file$E, 72, 2, 1894);
				attr_dev(div0, "class", "flex items-center justify-start");
				add_location(div0, file$E, 71, 1, 1846);
				add_location(span, file$E, 112, 3, 3059);
				attr_dev(button, "class", button_class_value = "w-[9.8rem] rounded-md cursor-pointer px-1 py-0.5 flex justify-around items-center " + /*background*/ ctx[7] + " svelte-1bdwav");
				add_location(button, file$E, 108, 2, 2898);
				attr_dev(div1, "class", "flex justify-center items-center ml-2");
				add_location(div1, file$E, 107, 1, 2844);
				attr_dev(div2, "class", "relative w-full my-2 pl-1 pr-0.5 border border-osvauld-iconblack rounded-lg cursor-pointer flex items-center justify-between text-osvauld-sheffieldgrey font-normal text-base");
				add_location(div2, file$E, 68, 0, 1655);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div2, anchor);
				append_dev(div2, div0);
				append_dev(div0, p);
				append_dev(p, t0);
				append_dev(div2, t1);

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(div2, null);
				}

				append_dev(div2, t2);
				append_dev(div2, div1);
				append_dev(div1, button);
				append_dev(button, span);
				append_dev(span, t3);
				append_dev(button, t4);
				if (if_block1) if_block1.m(button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", /*changePermissionHandler*/ ctx[10], false, false, false, false);
					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if ((!current || dirty & /*item*/ 1) && t0_value !== (t0_value = /*item*/ ctx[0].name + "")) set_data_dev(t0, t0_value);
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) {
						if_blocks[current_block_type_index].p(ctx, dirty);
					}
				} else {
					if (if_block0) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block0 = if_blocks[current_block_type_index];

						if (!if_block0) {
							if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block0.c();
						} else {
							if_block0.p(ctx, dirty);
						}

						transition_in(if_block0, 1);
						if_block0.m(div2, t2);
					} else {
						if_block0 = null;
					}
				}

				if ((!current || dirty & /*item*/ 1) && t3_value !== (t3_value = (/*item*/ ctx[0].accessType === "manager"
				? "Manager"
				: "Reader") + "")) set_data_dev(t3, t3_value);

				if (/*editPermissionTrigger*/ ctx[3] && (/*item*/ ctx[0].accessSource && /*item*/ ctx[0].accessSource === "acquired" || !/*item*/ ctx[0].accessSource)) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*editPermissionTrigger, item*/ 9) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block$s(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(button, null);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (!current || dirty & /*background*/ 128 && button_class_value !== (button_class_value = "w-[9.8rem] rounded-md cursor-pointer px-1 py-0.5 flex justify-around items-center " + /*background*/ ctx[7] + " svelte-1bdwav")) {
					attr_dev(button, "class", button_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div2);
				}

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d();
				}

				if (if_block1) if_block1.d();
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$E.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$E($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ExistingListItem', slots, []);
		const dispatch = createEventDispatcher();
		let { item } = $$props;
		let { index } = $$props;
		let { isUser } = $$props;
		let { editPermissionTrigger } = $$props;
		let { reverseModal } = $$props;
		let permissionChanged = false;
		let accessSelectorIdentifier = null;
		let showTooltip = false;

		const handleItemRemove = () => {
			dispatch("remove");
		};

		const eventPasser = e => {
			$$invalidate(0, item = { ...item, accessType: e.detail.permission });
			permissionChanged = !permissionChanged;
			dispatch("permissonChange", e.detail.permission);
			$$invalidate(5, accessSelectorIdentifier = null);
		};

		const changePermissionHandler = () => {
			if (editPermissionTrigger) {
				if (item.accessSource && item.accessSource === "acquired" || !item.accessSource) {
					permissionChanged = !permissionChanged;
					$$invalidate(5, accessSelectorIdentifier = index);
				}
			}
		};

		let background;

		onMount(() => {
			if (item.accessType) {
				$$invalidate(7, background = setbackground(item.accessType));
			}
		});

		$$self.$$.on_mount.push(function () {
			if (item === undefined && !('item' in $$props || $$self.$$.bound[$$self.$$.props['item']])) {
				console.warn("<ExistingListItem> was created without expected prop 'item'");
			}

			if (index === undefined && !('index' in $$props || $$self.$$.bound[$$self.$$.props['index']])) {
				console.warn("<ExistingListItem> was created without expected prop 'index'");
			}

			if (isUser === undefined && !('isUser' in $$props || $$self.$$.bound[$$self.$$.props['isUser']])) {
				console.warn("<ExistingListItem> was created without expected prop 'isUser'");
			}

			if (editPermissionTrigger === undefined && !('editPermissionTrigger' in $$props || $$self.$$.bound[$$self.$$.props['editPermissionTrigger']])) {
				console.warn("<ExistingListItem> was created without expected prop 'editPermissionTrigger'");
			}

			if (reverseModal === undefined && !('reverseModal' in $$props || $$self.$$.bound[$$self.$$.props['reverseModal']])) {
				console.warn("<ExistingListItem> was created without expected prop 'reverseModal'");
			}
		});

		const writable_props = ['item', 'index', 'isUser', 'editPermissionTrigger', 'reverseModal'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ExistingListItem> was created with unknown prop '${key}'`);
		});

		const select_handler = e => eventPasser(e);
		const closeSelector_handler = () => $$invalidate(5, accessSelectorIdentifier = null);
		const mouseenter_handler = () => $$invalidate(6, showTooltip = true);
		const mouseleave_handler = () => $$invalidate(6, showTooltip = false);

		$$self.$$set = $$props => {
			if ('item' in $$props) $$invalidate(0, item = $$props.item);
			if ('index' in $$props) $$invalidate(1, index = $$props.index);
			if ('isUser' in $$props) $$invalidate(2, isUser = $$props.isUser);
			if ('editPermissionTrigger' in $$props) $$invalidate(3, editPermissionTrigger = $$props.editPermissionTrigger);
			if ('reverseModal' in $$props) $$invalidate(4, reverseModal = $$props.reverseModal);
		};

		$$self.$capture_state = () => ({
			setbackground,
			BinIcon,
			DownArrow,
			createEventDispatcher,
			AccessSelector,
			InfoIcon,
			onMount,
			dispatch,
			item,
			index,
			isUser,
			editPermissionTrigger,
			reverseModal,
			permissionChanged,
			accessSelectorIdentifier,
			showTooltip,
			handleItemRemove,
			eventPasser,
			changePermissionHandler,
			background
		});

		$$self.$inject_state = $$props => {
			if ('item' in $$props) $$invalidate(0, item = $$props.item);
			if ('index' in $$props) $$invalidate(1, index = $$props.index);
			if ('isUser' in $$props) $$invalidate(2, isUser = $$props.isUser);
			if ('editPermissionTrigger' in $$props) $$invalidate(3, editPermissionTrigger = $$props.editPermissionTrigger);
			if ('reverseModal' in $$props) $$invalidate(4, reverseModal = $$props.reverseModal);
			if ('permissionChanged' in $$props) permissionChanged = $$props.permissionChanged;
			if ('accessSelectorIdentifier' in $$props) $$invalidate(5, accessSelectorIdentifier = $$props.accessSelectorIdentifier);
			if ('showTooltip' in $$props) $$invalidate(6, showTooltip = $$props.showTooltip);
			if ('background' in $$props) $$invalidate(7, background = $$props.background);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*editPermissionTrigger*/ 8) {
				if (!editPermissionTrigger) $$invalidate(5, accessSelectorIdentifier = null);
			}
		};

		return [
			item,
			index,
			isUser,
			editPermissionTrigger,
			reverseModal,
			accessSelectorIdentifier,
			showTooltip,
			background,
			handleItemRemove,
			eventPasser,
			changePermissionHandler,
			select_handler,
			closeSelector_handler,
			mouseenter_handler,
			mouseleave_handler
		];
	}

	class ExistingListItem extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$E, create_fragment$E, safe_not_equal, {
				item: 0,
				index: 1,
				isUser: 2,
				editPermissionTrigger: 3,
				reverseModal: 4
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ExistingListItem",
				options,
				id: create_fragment$E.name
			});
		}

		get item() {
			throw new Error("<ExistingListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set item(value) {
			throw new Error("<ExistingListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get index() {
			throw new Error("<ExistingListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set index(value) {
			throw new Error("<ExistingListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isUser() {
			throw new Error("<ExistingListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isUser(value) {
			throw new Error("<ExistingListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get editPermissionTrigger() {
			throw new Error("<ExistingListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set editPermissionTrigger(value) {
			throw new Error("<ExistingListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get reverseModal() {
			throw new Error("<ExistingListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set reverseModal(value) {
			throw new Error("<ExistingListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/credentials/CredentialDetails.svelte generated by Svelte v4.2.19 */

	const { Object: Object_1$1 } = globals;
	const file$D = "src/lib/components/dashboard/credentials/CredentialDetails.svelte";

	function get_each_context_3(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[38] = list[i];
		child_ctx[37] = i;
		return child_ctx;
	}

	function get_each_context_2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[35] = list[i];
		child_ctx[37] = i;
		return child_ctx;
	}

	function get_each_context$e(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[30] = list[i];
		return child_ctx;
	}

	function get_each_context_1$1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[30] = list[i];
		return child_ctx;
	}

	// (120:0) {#if showEditCredentialModal}
	function create_if_block_8$2(ctx) {
		let div;
		let button;
		let credentialeditor;
		let current;
		let mounted;
		let dispose;

		credentialeditor = new CredentialEditor({
				props: {
					edit: true,
					credentialId: /*credential*/ ctx[1].credentialId,
					name: /*credential*/ ctx[1].name,
					description: /*credential*/ ctx[1].description,
					credentialType: /*credential*/ ctx[1].credentialType,
					credentialFields: /*fieldsForEdit*/ ctx[9]
				},
				$$inline: true
			});

		credentialeditor.$on("close", /*closeCredentialEditor*/ ctx[16]);

		const block = {
			c: function create() {
				div = element("div");
				button = element("button");
				create_component(credentialeditor.$$.fragment);
				attr_dev(button, "class", "p-6 rounded bg-transparent");
				add_location(button, file$D, 170, 2, 4938);
				attr_dev(div, "class", "fixed inset-0 flex items-center justify-center z-50 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px]");
				add_location(div, file$D, 167, 1, 4804);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, button);
				mount_component(credentialeditor, button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", stop_propagation(/*click_handler*/ ctx[17]), false, false, true, false);
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const credentialeditor_changes = {};
				if (dirty[0] & /*credential*/ 2) credentialeditor_changes.credentialId = /*credential*/ ctx[1].credentialId;
				if (dirty[0] & /*credential*/ 2) credentialeditor_changes.name = /*credential*/ ctx[1].name;
				if (dirty[0] & /*credential*/ 2) credentialeditor_changes.description = /*credential*/ ctx[1].description;
				if (dirty[0] & /*credential*/ 2) credentialeditor_changes.credentialType = /*credential*/ ctx[1].credentialType;
				credentialeditor.$set(credentialeditor_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(credentialeditor.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(credentialeditor.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(credentialeditor);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_8$2.name,
			type: "if",
			source: "(120:0) {#if showEditCredentialModal}",
			ctx
		});

		return block;
	}

	// (151:3) {#if credential.accessType === "manager" && !accessListSelected}
	function create_if_block_7$2(ctx) {
		let button;
		let editicon;
		let button_class_value;
		let current;
		let mounted;
		let dispose;
		editicon = new EditIcon({ $$inline: true });

		const block = {
			c: function create() {
				button = element("button");
				create_component(editicon.$$.fragment);

				attr_dev(button, "class", button_class_value = "p-2 mr-3 rounded-lg " + (/*showEditCredentialModal*/ ctx[6]
				? 'bg-osvauld-sensitivebgblue'
				: ''));

				add_location(button, file$D, 198, 4, 5816);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				mount_component(editicon, button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", /*handleEditCredential*/ ctx[15], false, false, false, false);
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (!current || dirty[0] & /*showEditCredentialModal*/ 64 && button_class_value !== (button_class_value = "p-2 mr-3 rounded-lg " + (/*showEditCredentialModal*/ ctx[6]
				? 'bg-osvauld-sensitivebgblue'
				: ''))) {
					attr_dev(button, "class", button_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(editicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(editicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(editicon);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_7$2.name,
			type: "if",
			source: "(151:3) {#if credential.accessType === \\\"manager\\\" && !accessListSelected}",
			ctx
		});

		return block;
	}

	// (227:3) {:else}
	function create_else_block$j(ctx) {
		let div1;
		let toggle;
		let t0;
		let div0;
		let t1;
		let div2;
		let current_block_type_index;
		let if_block1;
		let t2;
		let if_block2_anchor;
		let current;
		toggle = new Toggle({ $$inline: true });
		toggle.$on("select", /*toggleSelect*/ ctx[10]);
		let if_block0 = /*credential*/ ctx[1].accessType === "manager" && create_if_block_6$4(ctx);
		const if_block_creators = [create_if_block_4$5, create_if_block_5$4];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*selectedTab*/ ctx[2] == "Groups") return 0;
			if (/*selectedTab*/ ctx[2] == "Users") return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type_1(ctx))) {
			if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		let if_block2 = /*accessChangeDetected*/ ctx[4] && create_if_block_3$9(ctx);

		const block = {
			c: function create() {
				div1 = element("div");
				create_component(toggle.$$.fragment);
				t0 = space();
				div0 = element("div");
				if (if_block0) if_block0.c();
				t1 = space();
				div2 = element("div");
				if (if_block1) if_block1.c();
				t2 = space();
				if (if_block2) if_block2.c();
				if_block2_anchor = empty();
				attr_dev(div0, "class", "mr-3");
				add_location(div0, file$D, 276, 5, 8224);
				attr_dev(div1, "class", "flex justify-between items-center");
				add_location(div1, file$D, 274, 4, 8128);
				attr_dev(div2, "class", "items-left");
				add_location(div2, file$D, 291, 4, 8602);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				mount_component(toggle, div1, null);
				append_dev(div1, t0);
				append_dev(div1, div0);
				if (if_block0) if_block0.m(div0, null);
				insert_dev(target, t1, anchor);
				insert_dev(target, div2, anchor);

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(div2, null);
				}

				insert_dev(target, t2, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert_dev(target, if_block2_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (/*credential*/ ctx[1].accessType === "manager") {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*credential*/ 2) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_6$4(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div0, null);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index === previous_block_index) {
					if (~current_block_type_index) {
						if_blocks[current_block_type_index].p(ctx, dirty);
					}
				} else {
					if (if_block1) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block1 = if_blocks[current_block_type_index];

						if (!if_block1) {
							if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block1.c();
						} else {
							if_block1.p(ctx, dirty);
						}

						transition_in(if_block1, 1);
						if_block1.m(div2, null);
					} else {
						if_block1 = null;
					}
				}

				if (/*accessChangeDetected*/ ctx[4]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);
					} else {
						if_block2 = create_if_block_3$9(ctx);
						if_block2.c();
						if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
					}
				} else if (if_block2) {
					if_block2.d(1);
					if_block2 = null;
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(toggle.$$.fragment, local);
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o: function outro(local) {
				transition_out(toggle.$$.fragment, local);
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
					detach_dev(t1);
					detach_dev(div2);
					detach_dev(t2);
					detach_dev(if_block2_anchor);
				}

				destroy_component(toggle);
				if (if_block0) if_block0.d();

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d();
				}

				if (if_block2) if_block2.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$j.name,
			type: "else",
			source: "(227:3) {:else}",
			ctx
		});

		return block;
	}

	// (195:3) {#if !accessListSelected}
	function create_if_block$r(ctx) {
		let t0;
		let t1;
		let if_block1_anchor;
		let current;
		let each_value_1 = ensure_array_like_dev(/*credential*/ ctx[1].fields);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let if_block0 = /*sensitiveFields*/ ctx[0] && create_if_block_2$e(ctx);
		let if_block1 = /*credential*/ ctx[1].description.length !== 0 && create_if_block_1$k(ctx);

		const block = {
			c: function create() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t0 = space();
				if (if_block0) if_block0.c();
				t1 = space();
				if (if_block1) if_block1.c();
				if_block1_anchor = empty();
			},
			m: function mount(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert_dev(target, t0, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert_dev(target, t1, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert_dev(target, if_block1_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*credential*/ 2) {
					each_value_1 = ensure_array_like_dev(/*credential*/ ctx[1].fields);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_1$1(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(t0.parentNode, t0);
						}
					}

					group_outros();

					for (i = each_value_1.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (/*sensitiveFields*/ ctx[0]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*sensitiveFields*/ 1) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_2$e(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t1.parentNode, t1);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*credential*/ ctx[1].description.length !== 0) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block_1$k(ctx);
						if_block1.c();
						if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value_1.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(if_block0);
				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(if_block0);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t0);
					detach_dev(t1);
					detach_dev(if_block1_anchor);
				}

				destroy_each(each_blocks, detaching);
				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$r.name,
			type: "if",
			source: "(195:3) {#if !accessListSelected}",
			ctx
		});

		return block;
	}

	// (231:6) {#if credential.accessType === "manager"}
	function create_if_block_6$4(ctx) {
		let button;
		let editicon;
		let button_class_value;
		let current;
		let mounted;
		let dispose;
		editicon = new EditIcon({ $$inline: true });

		const block = {
			c: function create() {
				button = element("button");
				create_component(editicon.$$.fragment);

				attr_dev(button, "class", button_class_value = "p-2 rounded-lg " + (/*editPermissionTrigger*/ ctx[5]
				? 'bg-osvauld-sensitivebgblue ml-2'
				: ''));

				add_location(button, file$D, 278, 7, 8298);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				mount_component(editicon, button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", /*click_handler_4*/ ctx[21], false, false, false, false);
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (!current || dirty[0] & /*editPermissionTrigger*/ 32 && button_class_value !== (button_class_value = "p-2 rounded-lg " + (/*editPermissionTrigger*/ ctx[5]
				? 'bg-osvauld-sensitivebgblue ml-2'
				: ''))) {
					attr_dev(button, "class", button_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(editicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(editicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(editicon);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_6$4.name,
			type: "if",
			source: "(231:6) {#if credential.accessType === \\\"manager\\\"}",
			ctx
		});

		return block;
	}

	// (259:38) 
	function create_if_block_5$4(ctx) {
		let each_1_anchor;
		let current;
		let each_value_3 = ensure_array_like_dev(/*users*/ ctx[7]);
		let each_blocks = [];

		for (let i = 0; i < each_value_3.length; i += 1) {
			each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m: function mount(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert_dev(target, each_1_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*users, editPermissionTrigger, removeUserFromCredentialHandler, permissionChangeHandler*/ 20640) {
					each_value_3 = ensure_array_like_dev(/*users*/ ctx[7]);
					let i;

					for (i = 0; i < each_value_3.length; i += 1) {
						const child_ctx = get_each_context_3(ctx, each_value_3, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_3(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value_3.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value_3.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_5$4.name,
			type: "if",
			source: "(259:38) ",
			ctx
		});

		return block;
	}

	// (246:5) {#if selectedTab == "Groups"}
	function create_if_block_4$5(ctx) {
		let each_1_anchor;
		let current;
		let each_value_2 = ensure_array_like_dev(/*groups*/ ctx[8]);
		let each_blocks = [];

		for (let i = 0; i < each_value_2.length; i += 1) {
			each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m: function mount(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert_dev(target, each_1_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*groups, editPermissionTrigger, removeGroupFromCredentialHandler, permissionChangeHandler*/ 18720) {
					each_value_2 = ensure_array_like_dev(/*groups*/ ctx[8]);
					let i;

					for (i = 0; i < each_value_2.length; i += 1) {
						const child_ctx = get_each_context_2(ctx, each_value_2, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block_2(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value_2.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value_2.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_4$5.name,
			type: "if",
			source: "(246:5) {#if selectedTab == \\\"Groups\\\"}",
			ctx
		});

		return block;
	}

	// (260:6) {#each users as user, index}
	function create_each_block_3(ctx) {
		let existinglistitem;
		let current;

		function remove_handler_1() {
			return /*remove_handler_1*/ ctx[24](/*user*/ ctx[38]);
		}

		function permissonChange_handler_1(...args) {
			return /*permissonChange_handler_1*/ ctx[25](/*user*/ ctx[38], ...args);
		}

		existinglistitem = new ExistingListItem({
				props: {
					isUser: true,
					item: /*user*/ ctx[38],
					index: /*index*/ ctx[37],
					reverseModal: false,
					editPermissionTrigger: /*editPermissionTrigger*/ ctx[5]
				},
				$$inline: true
			});

		existinglistitem.$on("remove", remove_handler_1);
		existinglistitem.$on("permissonChange", permissonChange_handler_1);

		const block = {
			c: function create() {
				create_component(existinglistitem.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(existinglistitem, target, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const existinglistitem_changes = {};
				if (dirty[0] & /*users*/ 128) existinglistitem_changes.item = /*user*/ ctx[38];
				if (dirty[0] & /*editPermissionTrigger*/ 32) existinglistitem_changes.editPermissionTrigger = /*editPermissionTrigger*/ ctx[5];
				existinglistitem.$set(existinglistitem_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(existinglistitem.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(existinglistitem.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(existinglistitem, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block_3.name,
			type: "each",
			source: "(260:6) {#each users as user, index}",
			ctx
		});

		return block;
	}

	// (247:6) {#each groups as group, index}
	function create_each_block_2(ctx) {
		let existinglistitem;
		let current;

		function remove_handler() {
			return /*remove_handler*/ ctx[22](/*group*/ ctx[35]);
		}

		function permissonChange_handler(...args) {
			return /*permissonChange_handler*/ ctx[23](/*group*/ ctx[35], ...args);
		}

		existinglistitem = new ExistingListItem({
				props: {
					isUser: false,
					item: /*group*/ ctx[35],
					index: /*index*/ ctx[37],
					reverseModal: false,
					editPermissionTrigger: /*editPermissionTrigger*/ ctx[5]
				},
				$$inline: true
			});

		existinglistitem.$on("remove", remove_handler);
		existinglistitem.$on("permissonChange", permissonChange_handler);

		const block = {
			c: function create() {
				create_component(existinglistitem.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(existinglistitem, target, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const existinglistitem_changes = {};
				if (dirty[0] & /*groups*/ 256) existinglistitem_changes.item = /*group*/ ctx[35];
				if (dirty[0] & /*editPermissionTrigger*/ 32) existinglistitem_changes.editPermissionTrigger = /*editPermissionTrigger*/ ctx[5];
				existinglistitem.$set(existinglistitem_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(existinglistitem.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(existinglistitem.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(existinglistitem, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block_2.name,
			type: "each",
			source: "(247:6) {#each groups as group, index}",
			ctx
		});

		return block;
	}

	// (274:4) {#if accessChangeDetected}
	function create_if_block_3$9(ctx) {
		let div;
		let button0;
		let t1;
		let button1;
		let mounted;
		let dispose;

		const block = {
			c: function create() {
				div = element("div");
				button0 = element("button");
				button0.textContent = "Cancel";
				t1 = space();
				button1 = element("button");
				button1.textContent = "Save Changes";
				attr_dev(button0, "class", "px-3 py-1.5 bg-osvauld-cancelBackground rounded-md text-osvauld-quarzowhite text-base font-normal");
				add_location(button0, file$D, 322, 6, 9560);
				attr_dev(button1, "class", "px-3 py-1.5 bg-osvauld-carolinablue text-osvauld-frameblack font-normal text-base rounded-md");
				add_location(button1, file$D, 329, 6, 9824);
				attr_dev(div, "class", "flex justify-end items-center gap-4");
				add_location(div, file$D, 321, 5, 9504);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, button0);
				append_dev(div, t1);
				append_dev(div, button1);

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", /*click_handler_5*/ ctx[26], false, false, false, false),
						listen_dev(button1, "click", /*click_handler_6*/ ctx[27], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$9.name,
			type: "if",
			source: "(274:4) {#if accessChangeDetected}",
			ctx
		});

		return block;
	}

	// (196:4) {#each credential.fields as field}
	function create_each_block_1$1(ctx) {
		let plainfield;
		let current;

		plainfield = new PlainField({
				props: {
					fieldName: /*field*/ ctx[30].fieldName,
					fieldValue: /*field*/ ctx[30].fieldValue,
					hoverEffect: true
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(plainfield.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(plainfield, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const plainfield_changes = {};
				if (dirty[0] & /*credential*/ 2) plainfield_changes.fieldName = /*field*/ ctx[30].fieldName;
				if (dirty[0] & /*credential*/ 2) plainfield_changes.fieldValue = /*field*/ ctx[30].fieldValue;
				plainfield.$set(plainfield_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(plainfield.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(plainfield.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(plainfield, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block_1$1.name,
			type: "each",
			source: "(196:4) {#each credential.fields as field}",
			ctx
		});

		return block;
	}

	// (203:4) {#if sensitiveFields}
	function create_if_block_2$e(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like_dev(/*sensitiveFields*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m: function mount(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert_dev(target, each_1_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*sensitiveFields*/ 1) {
					each_value = ensure_array_like_dev(/*sensitiveFields*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$e(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$e(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$e.name,
			type: "if",
			source: "(203:4) {#if sensitiveFields}",
			ctx
		});

		return block;
	}

	// (204:5) {#each sensitiveFields as field}
	function create_each_block$e(ctx) {
		let encryptedfield;
		let current;

		encryptedfield = new EncryptedField({
				props: {
					fieldName: /*field*/ ctx[30].fieldName,
					fieldValue: /*field*/ ctx[30].fieldValue,
					fieldType: /*field*/ ctx[30].fieldType,
					hoverEffect: true
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(encryptedfield.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(encryptedfield, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const encryptedfield_changes = {};
				if (dirty[0] & /*sensitiveFields*/ 1) encryptedfield_changes.fieldName = /*field*/ ctx[30].fieldName;
				if (dirty[0] & /*sensitiveFields*/ 1) encryptedfield_changes.fieldValue = /*field*/ ctx[30].fieldValue;
				if (dirty[0] & /*sensitiveFields*/ 1) encryptedfield_changes.fieldType = /*field*/ ctx[30].fieldType;
				encryptedfield.$set(encryptedfield_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(encryptedfield.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(encryptedfield.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(encryptedfield, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$e.name,
			type: "each",
			source: "(204:5) {#each sensitiveFields as field}",
			ctx
		});

		return block;
	}

	// (213:4) {#if credential.description.length !== 0}
	function create_if_block_1$k(ctx) {
		let label;
		let t1;
		let div;
		let t2_value = /*credential*/ ctx[1].description + "";
		let t2;

		const block = {
			c: function create() {
				label = element("label");
				label.textContent = "Description";
				t1 = space();
				div = element("div");
				t2 = text(t2_value);
				attr_dev(label, "class", "text-osvauld-dusklabel block text-left text-sm font-normal");
				attr_dev(label, "for", "credential-description");
				add_location(label, file$D, 260, 5, 7686);
				attr_dev(div, "class", "mt-4 w-full h-[4rem] py-1 px-2 overflow-y-scroll bg-osvauld-fieldActive rounded-lg text-left scrollbar-thin resize-none text-base text-osvauld-quarzowhite");
				attr_dev(div, "id", "credential-description");
				add_location(div, file$D, 266, 5, 7845);
			},
			m: function mount(target, anchor) {
				insert_dev(target, label, anchor);
				insert_dev(target, t1, anchor);
				insert_dev(target, div, anchor);
				append_dev(div, t2);
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*credential*/ 2 && t2_value !== (t2_value = /*credential*/ ctx[1].description + "")) set_data_dev(t2, t2_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(label);
					detach_dev(t1);
					detach_dev(div);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$k.name,
			type: "if",
			source: "(213:4) {#if credential.description.length !== 0}",
			ctx
		});

		return block;
	}

	function create_fragment$D(ctx) {
		let t0;
		let div5;
		let div4;
		let div1;
		let div0;
		let span0;
		let t1_value = /*credential*/ ctx[1].name + "";
		let t1;
		let t2;
		let t3;
		let button0;
		let closepanel;
		let t4;
		let div2;
		let button1;
		let filetext;
		let t5;
		let span1;
		let t6;
		let span1_class_value;
		let button1_class_value;
		let t7;
		let button2;
		let eyescan;
		let t8;
		let span2;
		let t9;
		let span2_class_value;
		let button2_class_value;
		let t10;
		let div3;
		let current_block_type_index;
		let if_block2;
		let div5_intro;
		let div5_outro;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*showEditCredentialModal*/ ctx[6] && create_if_block_8$2(ctx);
		let if_block1 = /*credential*/ ctx[1].accessType === "manager" && !/*accessListSelected*/ ctx[3] && create_if_block_7$2(ctx);
		closepanel = new ClosePanel({ $$inline: true });

		filetext = new FileText({
				props: {
					color: !/*accessListSelected*/ ctx[3] ? '#89B4FA' : '#85889C'
				},
				$$inline: true
			});

		eyescan = new EyeScan({
				props: {
					color: /*accessListSelected*/ ctx[3] ? '#89B4FA' : '#85889C'
				},
				$$inline: true
			});

		const if_block_creators = [create_if_block$r, create_else_block$j];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (!/*accessListSelected*/ ctx[3]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				if (if_block0) if_block0.c();
				t0 = space();
				div5 = element("div");
				div4 = element("div");
				div1 = element("div");
				div0 = element("div");
				span0 = element("span");
				t1 = text(t1_value);
				t2 = space();
				if (if_block1) if_block1.c();
				t3 = space();
				button0 = element("button");
				create_component(closepanel.$$.fragment);
				t4 = space();
				div2 = element("div");
				button1 = element("button");
				create_component(filetext.$$.fragment);
				t5 = space();
				span1 = element("span");
				t6 = text("Details");
				t7 = space();
				button2 = element("button");
				create_component(eyescan.$$.fragment);
				t8 = space();
				span2 = element("span");
				t9 = text("Access List");
				t10 = space();
				div3 = element("div");
				if_block2.c();
				attr_dev(span0, "class", "");
				add_location(span0, file$D, 195, 4, 5694);
				attr_dev(div0, "class", "text-3xl font-semibold w-full text-left ml-2 max-w-full overflow-hidden text-ellipsis whitespace-nowrap");
				add_location(div0, file$D, 192, 3, 5564);
				attr_dev(button0, "class", "p-2");
				add_location(button0, file$D, 207, 3, 6020);
				attr_dev(div1, "class", "flex pb-4");
				add_location(div1, file$D, 191, 2, 5537);

				attr_dev(span1, "class", span1_class_value = "" + ((!/*accessListSelected*/ ctx[3]
				? 'text-osvauld-carolinablue'
				: 'text-osvauld-fieldText ') + " ml-2"));

				add_location(span1, file$D, 220, 4, 6508);
				attr_dev(button1, "class", button1_class_value = "px-4 py-1.5 flex items-center text-sm font-light rounded-md mr-2 " + (!/*accessListSelected*/ ctx[3] && ' text-osvauld-carolinablue bg-osvauld-modalFieldActive'));
				add_location(button1, file$D, 214, 3, 6204);

				attr_dev(span2, "class", span2_class_value = "ml-2 " + (/*accessListSelected*/ ctx[3]
				? 'text-osvauld-carolinablue'
				: 'text-osvauld-fieldText '));

				add_location(span2, file$D, 233, 4, 6946);
				attr_dev(button2, "class", button2_class_value = "rounded-md flex justify-around items-center px-4 py-1.5 text-sm " + (/*accessListSelected*/ ctx[3] && 'bg-osvauld-modalFieldActive') + " ''}");
				add_location(button2, file$D, 226, 3, 6660);
				attr_dev(div2, "class", "flex justify-start items-center mb-6");
				add_location(div2, file$D, 213, 2, 6150);
				attr_dev(div3, "class", "border border-osvauld-iconblack rounded-xl p-3");
				add_location(div3, file$D, 240, 2, 7109);
				attr_dev(div4, "class", "w-[30vw] h-screen shadow-xl translate-x-0 bg-osvauld-frameblack p-6 overflow-y-auto scrollbar-thin");
				add_location(div4, file$D, 188, 1, 5418);
				attr_dev(div5, "class", "fixed top-0 right-0 z-0 flex justify-end rounded-xl blur-none");
				add_location(div5, file$D, 183, 0, 5322);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert_dev(target, t0, anchor);
				insert_dev(target, div5, anchor);
				append_dev(div5, div4);
				append_dev(div4, div1);
				append_dev(div1, div0);
				append_dev(div0, span0);
				append_dev(span0, t1);
				append_dev(div1, t2);
				if (if_block1) if_block1.m(div1, null);
				append_dev(div1, t3);
				append_dev(div1, button0);
				mount_component(closepanel, button0, null);
				append_dev(div4, t4);
				append_dev(div4, div2);
				append_dev(div2, button1);
				mount_component(filetext, button1, null);
				append_dev(button1, t5);
				append_dev(button1, span1);
				append_dev(span1, t6);
				append_dev(div2, t7);
				append_dev(div2, button2);
				mount_component(eyescan, button2, null);
				append_dev(button2, t8);
				append_dev(button2, span2);
				append_dev(span2, t9);
				append_dev(div4, t10);
				append_dev(div4, div3);
				if_blocks[current_block_type_index].m(div3, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", /*click_handler_1*/ ctx[18], false, false, false, false),
						listen_dev(button1, "click", /*click_handler_2*/ ctx[19], false, false, false, false),
						listen_dev(button2, "click", /*click_handler_3*/ ctx[20], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (/*showEditCredentialModal*/ ctx[6]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*showEditCredentialModal*/ 64) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_8$2(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if ((!current || dirty[0] & /*credential*/ 2) && t1_value !== (t1_value = /*credential*/ ctx[1].name + "")) set_data_dev(t1, t1_value);

				if (/*credential*/ ctx[1].accessType === "manager" && !/*accessListSelected*/ ctx[3]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*credential, accessListSelected*/ 10) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_7$2(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div1, t3);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				const filetext_changes = {};
				if (dirty[0] & /*accessListSelected*/ 8) filetext_changes.color = !/*accessListSelected*/ ctx[3] ? '#89B4FA' : '#85889C';
				filetext.$set(filetext_changes);

				if (!current || dirty[0] & /*accessListSelected*/ 8 && span1_class_value !== (span1_class_value = "" + ((!/*accessListSelected*/ ctx[3]
				? 'text-osvauld-carolinablue'
				: 'text-osvauld-fieldText ') + " ml-2"))) {
					attr_dev(span1, "class", span1_class_value);
				}

				if (!current || dirty[0] & /*accessListSelected*/ 8 && button1_class_value !== (button1_class_value = "px-4 py-1.5 flex items-center text-sm font-light rounded-md mr-2 " + (!/*accessListSelected*/ ctx[3] && ' text-osvauld-carolinablue bg-osvauld-modalFieldActive'))) {
					attr_dev(button1, "class", button1_class_value);
				}

				const eyescan_changes = {};
				if (dirty[0] & /*accessListSelected*/ 8) eyescan_changes.color = /*accessListSelected*/ ctx[3] ? '#89B4FA' : '#85889C';
				eyescan.$set(eyescan_changes);

				if (!current || dirty[0] & /*accessListSelected*/ 8 && span2_class_value !== (span2_class_value = "ml-2 " + (/*accessListSelected*/ ctx[3]
				? 'text-osvauld-carolinablue'
				: 'text-osvauld-fieldText '))) {
					attr_dev(span2, "class", span2_class_value);
				}

				if (!current || dirty[0] & /*accessListSelected*/ 8 && button2_class_value !== (button2_class_value = "rounded-md flex justify-around items-center px-4 py-1.5 text-sm " + (/*accessListSelected*/ ctx[3] && 'bg-osvauld-modalFieldActive') + " ''}")) {
					attr_dev(button2, "class", button2_class_value);
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block2 = if_blocks[current_block_type_index];

					if (!if_block2) {
						if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block2.c();
					} else {
						if_block2.p(ctx, dirty);
					}

					transition_in(if_block2, 1);
					if_block2.m(div3, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(closepanel.$$.fragment, local);
				transition_in(filetext.$$.fragment, local);
				transition_in(eyescan.$$.fragment, local);
				transition_in(if_block2);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (div5_outro) div5_outro.end(1);
						div5_intro = create_in_transition(div5, fly, {});
						div5_intro.start();
					});
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(closepanel.$$.fragment, local);
				transition_out(filetext.$$.fragment, local);
				transition_out(eyescan.$$.fragment, local);
				transition_out(if_block2);
				if (div5_intro) div5_intro.invalidate();

				if (local) {
					div5_outro = create_out_transition(div5, fly, {});
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t0);
					detach_dev(div5);
				}

				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d();
				destroy_component(closepanel);
				destroy_component(filetext);
				destroy_component(eyescan);
				if_blocks[current_block_type_index].d();
				if (detaching && div5_outro) div5_outro.end();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$D.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$D($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('CredentialDetails', slots, []);
		let { credential } = $$props;
		let { sensitiveFields } = $$props;
		let selectedTab = "Groups";
		let accessListSelected = false;
		let accessChangeDetected = false;
		let fieldsForEdit = [];
		let editPermissionTrigger = false;
		let userPermissions;
		let groupPermissions;
		let showEditCredentialModal = false;
		let users = [];
		let groups = [];

		const toggleSelect = async e => {
			$$invalidate(2, selectedTab = e.detail);

			if (selectedTab == "Users") {
				const usersResponse = await fetchCredentialUsers(credential.credentialId);
				$$invalidate(7, users = usersResponse.data);
			} else if (selectedTab == "Groups") {
				const groupsResponse = await fetchCredentialGroups(credential.credentialId);
				$$invalidate(8, groups = groupsResponse.data);
			}
		};

		const removeGroupFromCredentialHandler = async group => {
			await removeGroupFromCredential(credential.credentialId, group.groupId);
			await toggleSelect({ detail: "Groups" });
		};

		const removeUserFromCredentialHandler = async user => {
			await removeUserFromCredential(credential.credentialId, user.id);
			await toggleSelect({ detail: "Users" });
		};

		const savePermissions = async () => {
			if (userPermissions && Object.keys(userPermissions).length !== 0) {
				const userPermissionSaveResponse = await editUserPermissionForCredential(userPermissions.credentialId, userPermissions.userId, userPermissions.accessType);
				await toggleSelect({ detail: "Users" });
				$$invalidate(4, accessChangeDetected = false);

				const message = userPermissionSaveResponse.message
				? userPermissionSaveResponse.message
				: "Does not have access";

				toastStore.set({ message, type: true, show: true });
			} else if (Object.keys(groupPermissions).length !== 0) {
				const groupPermissionSaveResponse = await editGroupPermissionForCredential(groupPermissions.credentialId, groupPermissions.groupId, groupPermissions.accessType);
				await toggleSelect({ detail: "Groups" });
				$$invalidate(4, accessChangeDetected = false);

				const message = groupPermissionSaveResponse.message
				? groupPermissionSaveResponse.message
				: "Does not have access";

				toastStore.set({ message, type: true, show: true });
			}

			$$invalidate(4, accessChangeDetected = false);
		};

		const permissionChangeHandler = async (e, id, type) => {
			$$invalidate(4, accessChangeDetected = true);

			if (type == "user") {
				userPermissions = {
					credentialId: credential.credentialId,
					userId: id,
					accessType: e.detail
				};
			} else {
				groupPermissions = {
					credentialId: credential.credentialId,
					groupId: id,
					accessType: e.detail
				};
			}
		};

		const handleEditCredential = async () => {
			for (let field of sensitiveFields) {
				const decryptedValue = await sendMessage("decryptField", field.fieldValue);

				fieldsForEdit.push({
					fieldId: field.fieldId,
					fieldName: field.fieldName,
					fieldValue: decryptedValue,
					fieldType: field.fieldType,
					sensitive: true
				});
			}

			for (let field of credential.fields) {
				fieldsForEdit.push({
					fieldId: field.fieldId,
					fieldName: field.fieldName,
					fieldValue: field.fieldValue,
					fieldType: field.fieldType,
					sensitive: false
				});
			}

			$$invalidate(6, showEditCredentialModal = true);
		};

		const closeCredentialEditor = async () => {
			$$invalidate(6, showEditCredentialModal = false);
			await setCredentialStore();
			showCredentialDetailsDrawer.set(false);
		};

		onMount(async () => {
			const groupsResponse = await fetchCredentialGroups(credential.credentialId);
			$$invalidate(8, groups = groupsResponse.data);

			if (sensitiveFields.length === 0) {
				const sensitiveFieldsResponse = await fetchSensitiveFieldsByCredentialId(credential.credentialId);
				$$invalidate(0, sensitiveFields = sensitiveFieldsResponse.data);
			}
		});

		$$self.$$.on_mount.push(function () {
			if (credential === undefined && !('credential' in $$props || $$self.$$.bound[$$self.$$.props['credential']])) {
				console.warn("<CredentialDetails> was created without expected prop 'credential'");
			}

			if (sensitiveFields === undefined && !('sensitiveFields' in $$props || $$self.$$.bound[$$self.$$.props['sensitiveFields']])) {
				console.warn("<CredentialDetails> was created without expected prop 'sensitiveFields'");
			}
		});

		const writable_props = ['credential', 'sensitiveFields'];

		Object_1$1.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CredentialDetails> was created with unknown prop '${key}'`);
		});

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		const click_handler_1 = () => showCredentialDetailsDrawer.set(false);
		const click_handler_2 = () => $$invalidate(3, accessListSelected = false);
		const click_handler_3 = () => $$invalidate(3, accessListSelected = true);

		const click_handler_4 = () => {
			$$invalidate(5, editPermissionTrigger = !editPermissionTrigger);
		};

		const remove_handler = group => removeGroupFromCredentialHandler(group);
		const permissonChange_handler = (group, e) => permissionChangeHandler(e, group.groupId, 'group');
		const remove_handler_1 = user => removeUserFromCredentialHandler(user);
		const permissonChange_handler_1 = (user, e) => permissionChangeHandler(e, user.id, 'user');

		const click_handler_5 = () => {
			$$invalidate(5, editPermissionTrigger = false);
			$$invalidate(4, accessChangeDetected = false);
		};

		const click_handler_6 = () => {
			savePermissions();
			$$invalidate(5, editPermissionTrigger = false);
		};

		$$self.$$set = $$props => {
			if ('credential' in $$props) $$invalidate(1, credential = $$props.credential);
			if ('sensitiveFields' in $$props) $$invalidate(0, sensitiveFields = $$props.sensitiveFields);
		};

		$$self.$capture_state = () => ({
			fly,
			EncryptedField,
			PlainField,
			Toggle,
			fetchCredentialUsers,
			fetchCredentialGroups,
			removeGroupFromCredential,
			removeUserFromCredential,
			editGroupPermissionForCredential,
			editUserPermissionForCredential,
			fetchSensitiveFieldsByCredentialId,
			showCredentialDetailsDrawer,
			toastStore,
			ClosePanel,
			EditIcon,
			EyeScan,
			onMount,
			ExistingListItem,
			CredentialEditor,
			sendMessage,
			FileText,
			setCredentialStore,
			credential,
			sensitiveFields,
			selectedTab,
			accessListSelected,
			accessChangeDetected,
			fieldsForEdit,
			editPermissionTrigger,
			userPermissions,
			groupPermissions,
			showEditCredentialModal,
			users,
			groups,
			toggleSelect,
			removeGroupFromCredentialHandler,
			removeUserFromCredentialHandler,
			savePermissions,
			permissionChangeHandler,
			handleEditCredential,
			closeCredentialEditor
		});

		$$self.$inject_state = $$props => {
			if ('credential' in $$props) $$invalidate(1, credential = $$props.credential);
			if ('sensitiveFields' in $$props) $$invalidate(0, sensitiveFields = $$props.sensitiveFields);
			if ('selectedTab' in $$props) $$invalidate(2, selectedTab = $$props.selectedTab);
			if ('accessListSelected' in $$props) $$invalidate(3, accessListSelected = $$props.accessListSelected);
			if ('accessChangeDetected' in $$props) $$invalidate(4, accessChangeDetected = $$props.accessChangeDetected);
			if ('fieldsForEdit' in $$props) $$invalidate(9, fieldsForEdit = $$props.fieldsForEdit);
			if ('editPermissionTrigger' in $$props) $$invalidate(5, editPermissionTrigger = $$props.editPermissionTrigger);
			if ('userPermissions' in $$props) userPermissions = $$props.userPermissions;
			if ('groupPermissions' in $$props) groupPermissions = $$props.groupPermissions;
			if ('showEditCredentialModal' in $$props) $$invalidate(6, showEditCredentialModal = $$props.showEditCredentialModal);
			if ('users' in $$props) $$invalidate(7, users = $$props.users);
			if ('groups' in $$props) $$invalidate(8, groups = $$props.groups);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			sensitiveFields,
			credential,
			selectedTab,
			accessListSelected,
			accessChangeDetected,
			editPermissionTrigger,
			showEditCredentialModal,
			users,
			groups,
			fieldsForEdit,
			toggleSelect,
			removeGroupFromCredentialHandler,
			removeUserFromCredentialHandler,
			savePermissions,
			permissionChangeHandler,
			handleEditCredential,
			closeCredentialEditor,
			click_handler,
			click_handler_1,
			click_handler_2,
			click_handler_3,
			click_handler_4,
			remove_handler,
			permissonChange_handler,
			remove_handler_1,
			permissonChange_handler_1,
			click_handler_5,
			click_handler_6
		];
	}

	class CredentialDetails extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$D, create_fragment$D, safe_not_equal, { credential: 1, sensitiveFields: 0 }, null, [-1, -1]);

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "CredentialDetails",
				options,
				id: create_fragment$D.name
			});
		}

		get credential() {
			throw new Error("<CredentialDetails>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set credential(value) {
			throw new Error("<CredentialDetails>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get sensitiveFields() {
			throw new Error("<CredentialDetails>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set sensitiveFields(value) {
			throw new Error("<CredentialDetails>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/components/Placeholder.svelte generated by Svelte v4.2.19 */
	const file$C = "src/lib/components/dashboard/components/Placeholder.svelte";

	function create_fragment$C(ctx) {
		let div7;
		let div0;
		let h1;
		let t0;
		let t1;
		let t2;
		let p0;
		let t4;
		let div3;
		let div1;
		let h20;
		let t6;
		let p1;
		let t8;
		let button0;
		let span0;
		let t10;
		let add0;
		let button0_class_value;
		let t11;
		let div2;
		let h21;
		let t13;
		let p2;
		let t15;
		let button1;
		let span1;
		let t17;
		let add1;
		let button1_class_value;
		let t18;
		let div6;
		let div4;
		let a0;
		let t20;
		let div5;
		let a1;
		let current;
		let mounted;
		let dispose;

		add0 = new Add({
				props: {
					color: /*isFirstCardHovered*/ ctx[0] ? '#000' : '#A3A4B5'
				},
				$$inline: true
			});

		add1 = new Add({
				props: {
					color: /*isSecondCardHovered*/ ctx[1] ? '#000' : '#A3A4B5'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				div7 = element("div");
				div0 = element("div");
				h1 = element("h1");
				t0 = text("Welcome, ");
				t1 = text(/*username*/ ctx[2]);
				t2 = space();
				p0 = element("p");
				p0.textContent = "Lets Jump right onto things!";
				t4 = space();
				div3 = element("div");
				div1 = element("div");
				h20 = element("h2");
				h20.textContent = "Organize your credentials";
				t6 = space();
				p1 = element("p");
				p1.textContent = "Create a new folder to securely store your credentials. Stay organized\n\t\t\t\tand access them easily whenever you need.";
				t8 = space();
				button0 = element("button");
				span0 = element("span");
				span0.textContent = "Create new folder";
				t10 = space();
				create_component(add0.$$.fragment);
				t11 = space();
				div2 = element("div");
				h21 = element("h2");
				h21.textContent = "Collaborate with teams";
				t13 = space();
				p2 = element("p");
				p2.textContent = "Start a new group to collaborate, share your credentials, manage access,\n\t\t\t\tand streamline your workflows.";
				t15 = space();
				button1 = element("button");
				span1 = element("span");
				span1.textContent = "Start new group";
				t17 = space();
				create_component(add1.$$.fragment);
				t18 = space();
				div6 = element("div");
				div4 = element("div");
				a0 = element("a");
				a0.textContent = "Visit osvauld.com";
				t20 = space();
				div5 = element("div");
				a1 = element("a");
				a1.textContent = "Read osvauld docs";
				attr_dev(h1, "class", "font-Jakarta text-5xl");
				add_location(h1, file$C, 35, 2, 910);
				attr_dev(p0, "class", "font-sans text-base font-light mt-4");
				add_location(p0, file$C, 36, 2, 971);
				attr_dev(div0, "class", "w-full flex flex-col justify-center items-start font-Jakarta text-6xl text-osvauld-textActive");
				add_location(div0, file$C, 32, 1, 796);
				attr_dev(h20, "class", "text-3xl");
				add_location(h20, file$C, 51, 3, 1740);
				attr_dev(p1, "class", "text-base");
				add_location(p1, file$C, 52, 3, 1795);
				attr_dev(span0, "class", "mr-1 whitespace-nowrap");
				add_location(span0, file$C, 61, 4, 2255);
				attr_dev(button0, "class", button0_class_value = "flex justify-center items-center text-base border text-osvauld-textActive border-osvauld-iconblack rounded-md px-4 py-1 " + (/*isFirstCardHovered*/ ctx[0] && 'bg-osvauld-carolinablue !text-osvauld-frameblack') + " transition-colors duration-300 !ease-in");
				add_location(button0, file$C, 56, 3, 1949);
				attr_dev(div1, "class", "bg-osvauld-cardshade h-[80%] w-[48%] rounded-3xl flex flex-col gap-7 justify-center items-start p-14 border border-transparent transition duration-300 ease-in-out hover:border-osvauld-iconblack hover:-translate-y-1 hover:scale-101 cursor-pointer hover:shadow-[0_14px_15px_rgba(0,0,0,0.25),0_10px_10px_rgba(0,0,0,0.22)] text-osvauld-textActive overflow-hidden");
				attr_dev(div1, "role", "option");
				attr_dev(div1, "tabindex", "0");
				attr_dev(div1, "aria-selected", /*isFirstCardHovered*/ ctx[0]);
				add_location(div1, file$C, 43, 2, 1174);
				attr_dev(h21, "class", "text-3xl");
				add_location(h21, file$C, 74, 3, 2973);
				attr_dev(p2, "class", "text-base");
				add_location(p2, file$C, 75, 3, 3025);
				attr_dev(span1, "class", "mr-1 whitespace-nowrap");
				add_location(span1, file$C, 84, 4, 3476);
				attr_dev(button1, "class", button1_class_value = "flex justify-center items-center text-base border text-osvauld-textActive border-osvauld-iconblack rounded-md px-4 py-1 " + (/*isSecondCardHovered*/ ctx[1] && 'bg-osvauld-carolinablue !text-osvauld-frameblack') + " transition-colors duration-300 !ease-in");
				add_location(button1, file$C, 79, 3, 3170);
				attr_dev(div2, "class", "bg-osvauld-cardshade h-[80%] w-[48%] rounded-3xl flex flex-col justify-center gap-7 items-start p-14 border border-transparent transition duration-300 ease-in-out hover:border-osvauld-iconblack hover:-translate-y-1 hover:scale-101 cursor-pointer hover:shadow-[0_14px_28px_rgba(0,0,0,0.25),0_10px_10px_rgba(0,0,0,0.22)] text-osvauld-textActive overflow-hidden");
				attr_dev(div2, "role", "option");
				attr_dev(div2, "tabindex", "0");
				attr_dev(div2, "aria-selected", /*isSecondCardHovered*/ ctx[1]);
				add_location(div2, file$C, 66, 2, 2404);
				attr_dev(div3, "class", "flex justify-around items-center flex-wrap gap-4 min-w-[40rem] max-w-[60rem] h-[30rem]");
				add_location(div3, file$C, 40, 1, 1067);
				attr_dev(a0, "href", "https://osvauld.com");
				attr_dev(a0, "target", "_blank");
				attr_dev(a0, "rel", "noopener noreferrer");
				add_location(a0, file$C, 93, 3, 3787);
				attr_dev(div4, "class", "w-1/2 h-10 flex justify-end items-center text-sm text-osvauld-textActive pr-4");
				add_location(div4, file$C, 90, 2, 3686);
				attr_dev(a1, "href", "https://docs.osvauld.com/introduction/overview/");
				attr_dev(a1, "target", "_blank");
				attr_dev(a1, "rel", "noopener noreferrer");
				add_location(a1, file$C, 100, 3, 4038);
				attr_dev(div5, "class", "w-1/2 h-10 flex justify-start items-center border-l border-osvauld-iconblack text-sm text-osvauld-textActive pl-4");
				add_location(div5, file$C, 97, 2, 3901);
				attr_dev(div6, "class", "w-full flex justify-center items-center");
				add_location(div6, file$C, 89, 1, 3630);
				attr_dev(div7, "class", "px-[11.30rem] py-[3.25rem] w-full h-[40rem] bg-osvauld-frameblack text-osvauld-sheffieldgrey font-normal text-xl flex flex-col gap-4 justify-center items-center");
				add_location(div7, file$C, 29, 0, 618);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div7, anchor);
				append_dev(div7, div0);
				append_dev(div0, h1);
				append_dev(h1, t0);
				append_dev(h1, t1);
				append_dev(div0, t2);
				append_dev(div0, p0);
				append_dev(div7, t4);
				append_dev(div7, div3);
				append_dev(div3, div1);
				append_dev(div1, h20);
				append_dev(div1, t6);
				append_dev(div1, p1);
				append_dev(div1, t8);
				append_dev(div1, button0);
				append_dev(button0, span0);
				append_dev(button0, t10);
				mount_component(add0, button0, null);
				append_dev(div3, t11);
				append_dev(div3, div2);
				append_dev(div2, h21);
				append_dev(div2, t13);
				append_dev(div2, p2);
				append_dev(div2, t15);
				append_dev(div2, button1);
				append_dev(button1, span1);
				append_dev(button1, t17);
				mount_component(add1, button1, null);
				append_dev(div7, t18);
				append_dev(div7, div6);
				append_dev(div6, div4);
				append_dev(div4, a0);
				append_dev(div6, t20);
				append_dev(div6, div5);
				append_dev(div5, a1);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", /*createFolderManager*/ ctx[4], false, false, false, false),
						listen_dev(div1, "mouseenter", /*mouseenter_handler*/ ctx[5], false, false, false, false),
						listen_dev(div1, "mouseleave", /*mouseleave_handler*/ ctx[6], false, false, false, false),
						listen_dev(button1, "click", /*createGroupManager*/ ctx[3], false, false, false, false),
						listen_dev(div2, "mouseenter", /*mouseenter_handler_1*/ ctx[7], false, false, false, false),
						listen_dev(div2, "mouseleave", /*mouseleave_handler_1*/ ctx[8], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (!current || dirty & /*username*/ 4) set_data_dev(t1, /*username*/ ctx[2]);
				const add0_changes = {};
				if (dirty & /*isFirstCardHovered*/ 1) add0_changes.color = /*isFirstCardHovered*/ ctx[0] ? '#000' : '#A3A4B5';
				add0.$set(add0_changes);

				if (!current || dirty & /*isFirstCardHovered*/ 1 && button0_class_value !== (button0_class_value = "flex justify-center items-center text-base border text-osvauld-textActive border-osvauld-iconblack rounded-md px-4 py-1 " + (/*isFirstCardHovered*/ ctx[0] && 'bg-osvauld-carolinablue !text-osvauld-frameblack') + " transition-colors duration-300 !ease-in")) {
					attr_dev(button0, "class", button0_class_value);
				}

				if (!current || dirty & /*isFirstCardHovered*/ 1) {
					attr_dev(div1, "aria-selected", /*isFirstCardHovered*/ ctx[0]);
				}

				const add1_changes = {};
				if (dirty & /*isSecondCardHovered*/ 2) add1_changes.color = /*isSecondCardHovered*/ ctx[1] ? '#000' : '#A3A4B5';
				add1.$set(add1_changes);

				if (!current || dirty & /*isSecondCardHovered*/ 2 && button1_class_value !== (button1_class_value = "flex justify-center items-center text-base border text-osvauld-textActive border-osvauld-iconblack rounded-md px-4 py-1 " + (/*isSecondCardHovered*/ ctx[1] && 'bg-osvauld-carolinablue !text-osvauld-frameblack') + " transition-colors duration-300 !ease-in")) {
					attr_dev(button1, "class", button1_class_value);
				}

				if (!current || dirty & /*isSecondCardHovered*/ 2) {
					attr_dev(div2, "aria-selected", /*isSecondCardHovered*/ ctx[1]);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(add0.$$.fragment, local);
				transition_in(add1.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(add0.$$.fragment, local);
				transition_out(add1.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div7);
				}

				destroy_component(add0);
				destroy_component(add1);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$C.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$C($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Placeholder', slots, []);
		let isFirstCardHovered = false;
		let isSecondCardHovered = false;
		let username = "";

		const createGroupManager = () => {
			selectedPage.set("Groups");
			showAddGroupDrawer.set(true);
		};

		const createFolderManager = () => {
			showAddFolderDrawer.set(true);
		};

		onMount(async () => {
			const accountDetails = await getUserDetails();
			$$invalidate(2, username = accountDetails.username);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Placeholder> was created with unknown prop '${key}'`);
		});

		const mouseenter_handler = () => $$invalidate(0, isFirstCardHovered = true);
		const mouseleave_handler = () => $$invalidate(0, isFirstCardHovered = false);
		const mouseenter_handler_1 = () => $$invalidate(1, isSecondCardHovered = true);
		const mouseleave_handler_1 = () => $$invalidate(1, isSecondCardHovered = false);

		$$self.$capture_state = () => ({
			onMount,
			showAddFolderDrawer,
			showAddGroupDrawer,
			selectedPage,
			Add,
			getUserDetails,
			isFirstCardHovered,
			isSecondCardHovered,
			username,
			createGroupManager,
			createFolderManager
		});

		$$self.$inject_state = $$props => {
			if ('isFirstCardHovered' in $$props) $$invalidate(0, isFirstCardHovered = $$props.isFirstCardHovered);
			if ('isSecondCardHovered' in $$props) $$invalidate(1, isSecondCardHovered = $$props.isSecondCardHovered);
			if ('username' in $$props) $$invalidate(2, username = $$props.username);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			isFirstCardHovered,
			isSecondCardHovered,
			username,
			createGroupManager,
			createFolderManager,
			mouseenter_handler,
			mouseleave_handler,
			mouseenter_handler_1,
			mouseleave_handler_1
		];
	}

	class Placeholder extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$C, create_fragment$C, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Placeholder",
				options,
				id: create_fragment$C.name
			});
		}
	}

	const extractUsername = (username, email) => {
	    return username || email;
	};
	const extractTOTPSecret = (uri) => {
	    const match = uri.match(/[?&]secret=([^&]+)/);
	    return match ? match[1] : null;
	};
	const isSafariCredential = (credential) => {
	    return "Title" in credential && "URL" in credential;
	};
	const isFirefoxCredential = (credential) => {
	    return "url" in credential && "guid" in credential;
	};
	// Chrome, edge CSVs and Opera CSVs follow similar format
	const isDashlaneCredential = (credential) => {
	    return ("username" in credential && "url" in credential && "note" in credential);
	};
	const isKeepassCredential = (credential) => {
	    return ("Web Site" in credential &&
	        "Login Name" in credential &&
	        "Comments" in credential);
	};
	const isRoboformCredential = (credential) => {
	    return ("MatchUrl" in credential && "Pwd" in credential && "Login" in credential);
	};
	const isNordpassCredential = (credential) => {
	    return "name" in credential && "url" in credential && "note" in credential;
	};
	const is1passwordCredential = (credential) => {
	    return ("Title" in credential && "Url" in credential && "OTPAuth" in credential);
	};
	const isChromeCredential = (credential) => {
	    return "name" in credential && "url" in credential && "note" in credential;
	};
	const isLastpassCredential = (credential) => {
	    return "name" in credential && "url" in credential;
	};
	const isBitwardenCredential = (credential) => {
	    return "login_username" in credential && "login_uri" in credential;
	};
	const isProtonCredential = (credential) => {
	    return "username" in credential && "email" in credential;
	};
	const transformSafariCredentials = (parsedData) => {
	    return parsedData.filter(isSafariCredential).map((credential) => ({
	        name: credential.Title,
	        description: credential.Notes,
	        domain: credential.URL,
	        username: credential.Username,
	        password: credential.Password,
	    }));
	};
	const transformFirefoxCredentials = (parsedData) => {
	    return parsedData.filter(isFirefoxCredential).map((credential) => ({
	        name: `Login - ${new URL(credential.url).hostname}`,
	        description: `Created on ${new Date(+credential.timeCreated)}`,
	        domain: credential.url,
	        username: credential.username,
	        password: credential.password,
	    }));
	};
	const transformChromeCredentials = (parsedData) => {
	    return parsedData.filter(isChromeCredential).map((credential) => ({
	        name: credential.name,
	        description: credential.note,
	        domain: credential.url,
	        username: credential.username,
	        password: credential.password,
	    }));
	};
	const transformLastpassCredentials = (parsedData) => {
	    return parsedData
	        .filter(isLastpassCredential)
	        .filter((credential) => credential.username && credential.password)
	        .map((credential) => ({
	        name: credential.name,
	        description: credential.extra,
	        domain: credential.url,
	        username: credential.username,
	        password: credential.password,
	        totp: credential.totp,
	    }));
	};
	const transformBitwardenCredentials = (parsedData) => {
	    return parsedData
	        .filter(isBitwardenCredential)
	        .filter((credential) => credential.type === "login")
	        .map((credential) => ({
	        name: credential.name,
	        description: credential.notes,
	        domain: credential.login_uri,
	        username: credential.login_username,
	        password: credential.login_password,
	        totp: credential.login_totp,
	    }));
	};
	const transformProtonpassCredentials = (parsedData) => {
	    return parsedData
	        .filter(isProtonCredential)
	        .filter((credential) => credential.type === "login")
	        .map((credential) => {
	        const extractedUsername = extractUsername(credential.username, credential.email);
	        const result = {
	            name: credential.name,
	            description: credential.note,
	            domain: credential.url,
	            username: extractedUsername,
	            password: credential.password,
	        };
	        if (extractedUsername === credential.username && credential.email) {
	            result.email = credential.email;
	        }
	        if (credential.totp) {
	            const parsedTotp = extractTOTPSecret(credential.totp);
	            if (parsedTotp) {
	                result.totp = parsedTotp;
	            }
	        }
	        return result;
	    });
	};
	const transformDashlaneCredentials = (parsedData) => {
	    return parsedData.filter(isDashlaneCredential).map((credential) => ({
	        name: credential.title,
	        description: credential.note,
	        domain: credential.url,
	        username: credential.username,
	        password: credential.password,
	        totp: credential.otpSecret,
	    }));
	};
	const transformNordpassCredentials = (parsedData) => {
	    return parsedData
	        .filter(isNordpassCredential)
	        .filter((credential) => credential.type === "password")
	        .map((credential) => ({
	        name: credential.name,
	        description: credential.note,
	        domain: credential.url,
	        username: credential.username,
	        password: credential.password,
	    }));
	};
	const transformKeepassCredentials = (parsedData) => {
	    return parsedData.filter(isKeepassCredential).map((credential) => ({
	        name: `Login - ${new URL(credential["Web Site"]).hostname}`,
	        description: credential.Comments,
	        domain: credential["Web Site"],
	        username: credential["Login Name"],
	        password: credential.Password,
	    }));
	};
	const transformRoboformCredentials = (parsedData) => {
	    return parsedData.filter(isRoboformCredential).map((credential) => ({
	        name: credential.Name,
	        description: credential.Note,
	        domain: credential.Url,
	        username: credential.Login,
	        password: credential.Pwd,
	    }));
	};
	const transformOnepasswordCredentials = (parsedData) => {
	    return parsedData.filter(is1passwordCredential).map((credential) => ({
	        name: credential.Title,
	        description: credential.Notes,
	        domain: credential.Url,
	        username: credential.Username,
	        password: credential.Password,
	        totp: credential.OTPAuth,
	    }));
	};
	const finalProcessing = async (folderId, usersToShare, credentialData) => {
	    try {
	        const fieldPayload = [];
	        let addCredentialPayload = {
	            name: "",
	            folderId: "",
	            description: "",
	            credentialType: "Login",
	            userFields: [],
	            domain: "",
	        };
	        if (credentialData.username) {
	            fieldPayload.push({
	                fieldName: "Username",
	                fieldValue: credentialData.username,
	                fieldType: "meta",
	            });
	        }
	        if (credentialData.password) {
	            fieldPayload.push({
	                fieldName: "Password",
	                fieldValue: credentialData.password,
	                fieldType: "sensitive",
	            });
	        }
	        if (credentialData.domain) {
	            fieldPayload.push({
	                fieldName: "Domain",
	                fieldValue: credentialData.domain,
	                fieldType: "additional",
	            }, {
	                fieldName: "URL",
	                fieldValue: credentialData.domain,
	                fieldType: "meta",
	            });
	        }
	        if (credentialData.totp) {
	            fieldPayload.push({
	                fieldName: "TOTP",
	                fieldValue: credentialData.totp,
	                fieldType: "totp",
	            });
	        }
	        if (credentialData.email) {
	            fieldPayload.push({
	                fieldName: "Email",
	                fieldValue: credentialData.email,
	                fieldType: "sensitive",
	            });
	        }
	        addCredentialPayload.folderId = folderId;
	        const userFields = await sendMessage("addCredential", {
	            users: usersToShare,
	            addCredentialFields: fieldPayload,
	        });
	        if (credentialData.name) {
	            addCredentialPayload.name = credentialData.name;
	        }
	        if (credentialData.description) {
	            addCredentialPayload.description = credentialData.description;
	        }
	        addCredentialPayload.userFields = userFields;
	        const response = await addCredential(addCredentialPayload);
	        return { success: true, response };
	    }
	    catch (error) {
	        console.error("Error posting credential:", error);
	        return { success: false, error };
	    }
	};

	var papaparse_min = {exports: {}};

	/* @license
	Papa Parse
	v5.4.1
	https://github.com/mholt/PapaParse
	License: MIT
	*/

	(function (module, exports) {
		!function(e,t){module.exports=t();}(commonjsGlobal,function s(){var f="undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==f?f:{};var n=!f.document&&!!f.postMessage,o=f.IS_PAPA_WORKER||!1,a={},u=0,b={parse:function(e,t){var r=(t=t||{}).dynamicTyping||!1;J(r)&&(t.dynamicTypingFunction=r,r={});if(t.dynamicTyping=r,t.transform=!!J(t.transform)&&t.transform,t.worker&&b.WORKERS_SUPPORTED){var i=function(){if(!b.WORKERS_SUPPORTED)return !1;var e=(r=f.URL||f.webkitURL||null,i=s.toString(),b.BLOB_URL||(b.BLOB_URL=r.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ","(",i,")();"],{type:"text/javascript"})))),t=new f.Worker(e);var r,i;return t.onmessage=_,t.id=u++,a[t.id]=t}();return i.userStep=t.step,i.userChunk=t.chunk,i.userComplete=t.complete,i.userError=t.error,t.step=J(t.step),t.chunk=J(t.chunk),t.complete=J(t.complete),t.error=J(t.error),delete t.worker,void i.postMessage({input:e,config:t,workerId:i.id})}var n=null;b.NODE_STREAM_INPUT,"string"==typeof e?(e=function(e){if(65279===e.charCodeAt(0))return e.slice(1);return e}(e),n=t.download?new l(t):new p(t)):!0===e.readable&&J(e.read)&&J(e.on)?n=new g(t):(f.File&&e instanceof File||e instanceof Object)&&(n=new c(t));return n.stream(e)},unparse:function(e,t){var n=!1,_=!0,m=",",y="\r\n",s='"',a=s+s,r=!1,i=null,o=!1;!function(){if("object"!=typeof t)return;"string"!=typeof t.delimiter||b.BAD_DELIMITERS.filter(function(e){return -1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter);("boolean"==typeof t.quotes||"function"==typeof t.quotes||Array.isArray(t.quotes))&&(n=t.quotes);"boolean"!=typeof t.skipEmptyLines&&"string"!=typeof t.skipEmptyLines||(r=t.skipEmptyLines);"string"==typeof t.newline&&(y=t.newline);"string"==typeof t.quoteChar&&(s=t.quoteChar);"boolean"==typeof t.header&&(_=t.header);if(Array.isArray(t.columns)){if(0===t.columns.length)throw new Error("Option columns is empty");i=t.columns;}void 0!==t.escapeChar&&(a=t.escapeChar+s);("boolean"==typeof t.escapeFormulae||t.escapeFormulae instanceof RegExp)&&(o=t.escapeFormulae instanceof RegExp?t.escapeFormulae:/^[=+\-@\t\r].*$/);}();var u=new RegExp(Q(s),"g");"string"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return h(null,e,r);if("object"==typeof e[0])return h(i||Object.keys(e[0]),e,r)}else if("object"==typeof e)return "string"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields||i),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:"object"==typeof e.data[0]?Object.keys(e.data[0]):[]),Array.isArray(e.data[0])||"object"==typeof e.data[0]||(e.data=[e.data])),h(e.fields||[],e.data||[],r);throw new Error("Unable to serialize unrecognized input");function h(e,t,r){var i="";"string"==typeof e&&(e=JSON.parse(e)),"string"==typeof t&&(t=JSON.parse(t));var n=Array.isArray(e)&&0<e.length,s=!Array.isArray(t[0]);if(n&&_){for(var a=0;a<e.length;a++)0<a&&(i+=m),i+=v(e[a],a);0<t.length&&(i+=y);}for(var o=0;o<t.length;o++){var u=n?e.length:t[o].length,h=!1,f=n?0===Object.keys(t[o]).length:0===t[o].length;if(r&&!n&&(h="greedy"===r?""===t[o].join("").trim():1===t[o].length&&0===t[o][0].length),"greedy"===r&&n){for(var d=[],l=0;l<u;l++){var c=s?e[l]:l;d.push(t[o][c]);}h=""===d.join("").trim();}if(!h){for(var p=0;p<u;p++){0<p&&!f&&(i+=m);var g=n&&s?e[p]:p;i+=v(t[o][g],p);}o<t.length-1&&(!r||0<u&&!f)&&(i+=y);}}return i}function v(e,t){if(null==e)return "";if(e.constructor===Date)return JSON.stringify(e).slice(1,25);var r=!1;o&&"string"==typeof e&&o.test(e)&&(e="'"+e,r=!0);var i=e.toString().replace(u,a);return (r=r||!0===n||"function"==typeof n&&n(e,t)||Array.isArray(n)&&n[t]||function(e,t){for(var r=0;r<t.length;r++)if(-1<e.indexOf(t[r]))return !0;return !1}(i,b.BAD_DELIMITERS)||-1<i.indexOf(m)||" "===i.charAt(0)||" "===i.charAt(i.length-1))?s+i+s:i}}};if(b.RECORD_SEP=String.fromCharCode(30),b.UNIT_SEP=String.fromCharCode(31),b.BYTE_ORDER_MARK="\ufeff",b.BAD_DELIMITERS=["\r","\n",'"',b.BYTE_ORDER_MARK],b.WORKERS_SUPPORTED=!n&&!!f.Worker,b.NODE_STREAM_INPUT=1,b.LocalChunkSize=10485760,b.RemoteChunkSize=5242880,b.DefaultDelimiter=",",b.Parser=E,b.ParserHandle=r,b.NetworkStreamer=l,b.FileStreamer=c,b.StringStreamer=p,b.ReadableStreamStreamer=g,f.jQuery){var d=f.jQuery;d.fn.parse=function(o){var r=o.config||{},u=[];return this.each(function(e){if(!("INPUT"===d(this).prop("tagName").toUpperCase()&&"file"===d(this).attr("type").toLowerCase()&&f.FileReader)||!this.files||0===this.files.length)return !0;for(var t=0;t<this.files.length;t++)u.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},r)});}),e(),this;function e(){if(0!==u.length){var e,t,r,i,n=u[0];if(J(o.before)){var s=o.before(n.file,n.inputElem);if("object"==typeof s){if("abort"===s.action)return e="AbortError",t=n.file,r=n.inputElem,i=s.reason,void(J(o.error)&&o.error({name:e},t,r,i));if("skip"===s.action)return void h();"object"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config));}else if("skip"===s)return void h()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){J(a)&&a(e,n.file,n.inputElem),h();},b.parse(n.file,n.instanceConfig);}else J(o.complete)&&o.complete();}function h(){u.splice(0,1),e();}};}function h(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine="",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=w(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new r(t),(this._handle.streamer=this)._config=t;}.call(this,e),this.parseChunk=function(e,t){if(this.isFirstChunk&&J(this._config.beforeFirstChunk)){var r=this._config.beforeFirstChunk(e);void 0!==r&&(e=r);}this.isFirstChunk=!1,this._halted=!1;var i=this._partialLine+e;this._partialLine="";var n=this._handle.parse(i,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var s=n.meta.cursor;this._finished||(this._partialLine=i.substring(s-this._baseIndex),this._baseIndex=s),n&&n.data&&(this._rowCount+=n.data.length);var a=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(o)f.postMessage({results:n,workerId:b.WORKER_ID,finished:a});else if(J(this._config.chunk)&&!t){if(this._config.chunk(n,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);n=void 0,this._completeResults=void 0;}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(n.data),this._completeResults.errors=this._completeResults.errors.concat(n.errors),this._completeResults.meta=n.meta),this._completed||!a||!J(this._config.complete)||n&&n.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),a||n&&n.meta.paused||this._nextChunk(),n}this._halted=!0;},this._sendError=function(e){J(this._config.error)?this._config.error(e):o&&this._config.error&&f.postMessage({workerId:b.WORKER_ID,error:e,finished:!1});};}function l(e){var i;(e=e||{}).chunkSize||(e.chunkSize=b.RemoteChunkSize),h.call(this,e),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded();}:function(){this._readChunk();},this.stream=function(e){this._input=e,this._nextChunk();},this._readChunk=function(){if(this._finished)this._chunkLoaded();else {if(i=new XMLHttpRequest,this._config.withCredentials&&(i.withCredentials=this._config.withCredentials),n||(i.onload=v(this._chunkLoaded,this),i.onerror=v(this._chunkError,this)),i.open(this._config.downloadRequestBody?"POST":"GET",this._input,!n),this._config.downloadRequestHeaders){var e=this._config.downloadRequestHeaders;for(var t in e)i.setRequestHeader(t,e[t]);}if(this._config.chunkSize){var r=this._start+this._config.chunkSize-1;i.setRequestHeader("Range","bytes="+this._start+"-"+r);}try{i.send(this._config.downloadRequestBody);}catch(e){this._chunkError(e.message);}n&&0===i.status&&this._chunkError();}},this._chunkLoaded=function(){4===i.readyState&&(i.status<200||400<=i.status?this._chunkError():(this._start+=this._config.chunkSize?this._config.chunkSize:i.responseText.length,this._finished=!this._config.chunkSize||this._start>=function(e){var t=e.getResponseHeader("Content-Range");if(null===t)return -1;return parseInt(t.substring(t.lastIndexOf("/")+1))}(i),this.parseChunk(i.responseText)));},this._chunkError=function(e){var t=i.statusText||e;this._sendError(new Error(t));};}function c(e){var i,n;(e=e||{}).chunkSize||(e.chunkSize=b.LocalChunkSize),h.call(this,e);var s="undefined"!=typeof FileReader;this.stream=function(e){this._input=e,n=e.slice||e.webkitSlice||e.mozSlice,s?((i=new FileReader).onload=v(this._chunkLoaded,this),i.onerror=v(this._chunkError,this)):i=new FileReaderSync,this._nextChunk();},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk();},this._readChunk=function(){var e=this._input;if(this._config.chunkSize){var t=Math.min(this._start+this._config.chunkSize,this._input.size);e=n.call(e,this._start,t);}var r=i.readAsText(e,this._config.encoding);s||this._chunkLoaded({target:{result:r}});},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result);},this._chunkError=function(){this._sendError(i.error);};}function p(e){var r;h.call(this,e=e||{}),this.stream=function(e){return r=e,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var e,t=this._config.chunkSize;return t?(e=r.substring(0,t),r=r.substring(t)):(e=r,r=""),this._finished=!r,this.parseChunk(e)}};}function g(e){h.call(this,e=e||{});var t=[],r=!0,i=!1;this.pause=function(){h.prototype.pause.apply(this,arguments),this._input.pause();},this.resume=function(){h.prototype.resume.apply(this,arguments),this._input.resume();},this.stream=function(e){this._input=e,this._input.on("data",this._streamData),this._input.on("end",this._streamEnd),this._input.on("error",this._streamError);},this._checkIsFinished=function(){i&&1===t.length&&(this._finished=!0);},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):r=!0;},this._streamData=v(function(e){try{t.push("string"==typeof e?e:e.toString(this._config.encoding)),r&&(r=!1,this._checkIsFinished(),this.parseChunk(t.shift()));}catch(e){this._streamError(e);}},this),this._streamError=v(function(e){this._streamCleanUp(),this._sendError(e);},this),this._streamEnd=v(function(){this._streamCleanUp(),i=!0,this._streamData("");},this),this._streamCleanUp=v(function(){this._input.removeListener("data",this._streamData),this._input.removeListener("end",this._streamEnd),this._input.removeListener("error",this._streamError);},this);}function r(m){var a,o,u,i=Math.pow(2,53),n=-i,s=/^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,h=/^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/,t=this,r=0,f=0,d=!1,e=!1,l=[],c={data:[],errors:[],meta:{}};if(J(m.step)){var p=m.step;m.step=function(e){if(c=e,_())g();else {if(g(),0===c.data.length)return;r+=e.data.length,m.preview&&r>m.preview?o.abort():(c.data=c.data[0],p(c,t));}};}function y(e){return "greedy"===m.skipEmptyLines?""===e.join("").trim():1===e.length&&0===e[0].length}function g(){return c&&u&&(k("Delimiter","UndetectableDelimiter","Unable to auto-detect delimiting character; defaulted to '"+b.DefaultDelimiter+"'"),u=!1),m.skipEmptyLines&&(c.data=c.data.filter(function(e){return !y(e)})),_()&&function(){if(!c)return;function e(e,t){J(m.transformHeader)&&(e=m.transformHeader(e,t)),l.push(e);}if(Array.isArray(c.data[0])){for(var t=0;_()&&t<c.data.length;t++)c.data[t].forEach(e);c.data.splice(0,1);}else c.data.forEach(e);}(),function(){if(!c||!m.header&&!m.dynamicTyping&&!m.transform)return c;function e(e,t){var r,i=m.header?{}:[];for(r=0;r<e.length;r++){var n=r,s=e[r];m.header&&(n=r>=l.length?"__parsed_extra":l[r]),m.transform&&(s=m.transform(s,n)),s=v(n,s),"__parsed_extra"===n?(i[n]=i[n]||[],i[n].push(s)):i[n]=s;}return m.header&&(r>l.length?k("FieldMismatch","TooManyFields","Too many fields: expected "+l.length+" fields but parsed "+r,f+t):r<l.length&&k("FieldMismatch","TooFewFields","Too few fields: expected "+l.length+" fields but parsed "+r,f+t)),i}var t=1;!c.data.length||Array.isArray(c.data[0])?(c.data=c.data.map(e),t=c.data.length):c.data=e(c.data,0);m.header&&c.meta&&(c.meta.fields=l);return f+=t,c}()}function _(){return m.header&&0===l.length}function v(e,t){return r=e,m.dynamicTypingFunction&&void 0===m.dynamicTyping[r]&&(m.dynamicTyping[r]=m.dynamicTypingFunction(r)),!0===(m.dynamicTyping[r]||m.dynamicTyping)?"true"===t||"TRUE"===t||"false"!==t&&"FALSE"!==t&&(function(e){if(s.test(e)){var t=parseFloat(e);if(n<t&&t<i)return !0}return !1}(t)?parseFloat(t):h.test(t)?new Date(t):""===t?null:t):t;var r;}function k(e,t,r,i){var n={type:e,code:t,message:r};void 0!==i&&(n.row=i),c.errors.push(n);}this.parse=function(e,t,r){var i=m.quoteChar||'"';if(m.newline||(m.newline=function(e,t){e=e.substring(0,1048576);var r=new RegExp(Q(t)+"([^]*?)"+Q(t),"gm"),i=(e=e.replace(r,"")).split("\r"),n=e.split("\n"),s=1<n.length&&n[0].length<i[0].length;if(1===i.length||s)return "\n";for(var a=0,o=0;o<i.length;o++)"\n"===i[o][0]&&a++;return a>=i.length/2?"\r\n":"\r"}(e,i)),u=!1,m.delimiter)J(m.delimiter)&&(m.delimiter=m.delimiter(e),c.meta.delimiter=m.delimiter);else {var n=function(e,t,r,i,n){var s,a,o,u;n=n||[",","\t","|",";",b.RECORD_SEP,b.UNIT_SEP];for(var h=0;h<n.length;h++){var f=n[h],d=0,l=0,c=0;o=void 0;for(var p=new E({comments:i,delimiter:f,newline:t,preview:10}).parse(e),g=0;g<p.data.length;g++)if(r&&y(p.data[g]))c++;else {var _=p.data[g].length;l+=_,void 0!==o?0<_&&(d+=Math.abs(_-o),o=_):o=_;}0<p.data.length&&(l/=p.data.length-c),(void 0===a||d<=a)&&(void 0===u||u<l)&&1.99<l&&(a=d,s=f,u=l);}return {successful:!!(m.delimiter=s),bestDelimiter:s}}(e,m.newline,m.skipEmptyLines,m.comments,m.delimitersToGuess);n.successful?m.delimiter=n.bestDelimiter:(u=!0,m.delimiter=b.DefaultDelimiter),c.meta.delimiter=m.delimiter;}var s=w(m);return m.preview&&m.header&&s.preview++,a=e,o=new E(s),c=o.parse(a,t,r),g(),d?{meta:{paused:!0}}:c||{meta:{paused:!1}}},this.paused=function(){return d},this.pause=function(){d=!0,o.abort(),a=J(m.chunk)?"":a.substring(o.getCharIndex());},this.resume=function(){t.streamer._halted?(d=!1,t.streamer.parseChunk(a,!0)):setTimeout(t.resume,3);},this.aborted=function(){return e},this.abort=function(){e=!0,o.abort(),c.meta.aborted=!0,J(m.complete)&&m.complete(c),a="";};}function Q(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function E(j){var z,M=(j=j||{}).delimiter,P=j.newline,U=j.comments,q=j.step,N=j.preview,B=j.fastMode,K=z=void 0===j.quoteChar||null===j.quoteChar?'"':j.quoteChar;if(void 0!==j.escapeChar&&(K=j.escapeChar),("string"!=typeof M||-1<b.BAD_DELIMITERS.indexOf(M))&&(M=","),U===M)throw new Error("Comment character same as delimiter");!0===U?U="#":("string"!=typeof U||-1<b.BAD_DELIMITERS.indexOf(U))&&(U=!1),"\n"!==P&&"\r"!==P&&"\r\n"!==P&&(P="\n");var W=0,H=!1;this.parse=function(i,t,r){if("string"!=typeof i)throw new Error("Input must be a string");var n=i.length,e=M.length,s=P.length,a=U.length,o=J(q),u=[],h=[],f=[],d=W=0;if(!i)return L();if(j.header&&!t){var l=i.split(P)[0].split(M),c=[],p={},g=!1;for(var _ in l){var m=l[_];J(j.transformHeader)&&(m=j.transformHeader(m,_));var y=m,v=p[m]||0;for(0<v&&(g=!0,y=m+"_"+v),p[m]=v+1;c.includes(y);)y=y+"_"+v;c.push(y);}if(g){var k=i.split(P);k[0]=c.join(M),i=k.join(P);}}if(B||!1!==B&&-1===i.indexOf(z)){for(var b=i.split(P),E=0;E<b.length;E++){if(f=b[E],W+=f.length,E!==b.length-1)W+=P.length;else if(r)return L();if(!U||f.substring(0,a)!==U){if(o){if(u=[],I(f.split(M)),F(),H)return L()}else I(f.split(M));if(N&&N<=E)return u=u.slice(0,N),L(!0)}}return L()}for(var w=i.indexOf(M,W),R=i.indexOf(P,W),C=new RegExp(Q(K)+Q(z),"g"),S=i.indexOf(z,W);;)if(i[W]!==z)if(U&&0===f.length&&i.substring(W,W+a)===U){if(-1===R)return L();W=R+s,R=i.indexOf(P,W),w=i.indexOf(M,W);}else if(-1!==w&&(w<R||-1===R))f.push(i.substring(W,w)),W=w+e,w=i.indexOf(M,W);else {if(-1===R)break;if(f.push(i.substring(W,R)),D(R+s),o&&(F(),H))return L();if(N&&u.length>=N)return L(!0)}else for(S=W,W++;;){if(-1===(S=i.indexOf(z,S+1)))return r||h.push({type:"Quotes",code:"MissingQuotes",message:"Quoted field unterminated",row:u.length,index:W}),T();if(S===n-1)return T(i.substring(W,S).replace(C,z));if(z!==K||i[S+1]!==K){if(z===K||0===S||i[S-1]!==K){-1!==w&&w<S+1&&(w=i.indexOf(M,S+1)),-1!==R&&R<S+1&&(R=i.indexOf(P,S+1));var O=A(-1===R?w:Math.min(w,R));if(i.substr(S+1+O,e)===M){f.push(i.substring(W,S).replace(C,z)),i[W=S+1+O+e]!==z&&(S=i.indexOf(z,W)),w=i.indexOf(M,W),R=i.indexOf(P,W);break}var x=A(R);if(i.substring(S+1+x,S+1+x+s)===P){if(f.push(i.substring(W,S).replace(C,z)),D(S+1+x+s),w=i.indexOf(M,W),S=i.indexOf(z,W),o&&(F(),H))return L();if(N&&u.length>=N)return L(!0);break}h.push({type:"Quotes",code:"InvalidQuotes",message:"Trailing quote on quoted field is malformed",row:u.length,index:W}),S++;}}else S++;}return T();function I(e){u.push(e),d=W;}function A(e){var t=0;if(-1!==e){var r=i.substring(S+1,e);r&&""===r.trim()&&(t=r.length);}return t}function T(e){return r||(void 0===e&&(e=i.substring(W)),f.push(e),W=n,I(f),o&&F()),L()}function D(e){W=e,I(f),f=[],R=i.indexOf(P,W);}function L(e){return {data:u,errors:h,meta:{delimiter:M,linebreak:P,aborted:H,truncated:!!e,cursor:d+(t||0)}}}function F(){q(L()),u=[],h=[];}},this.abort=function(){H=!0;},this.getCharIndex=function(){return W};}function _(e){var t=e.data,r=a[t.workerId],i=!1;if(t.error)r.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){i=!0,m(t.workerId,{data:[],errors:[],meta:{aborted:!0}});},pause:y,resume:y};if(J(r.userStep)){for(var s=0;s<t.results.data.length&&(r.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},n),!i);s++);delete t.results;}else J(r.userChunk)&&(r.userChunk(t.results,n,t.file),delete t.results);}t.finished&&!i&&m(t.workerId,t.results);}function m(e,t){var r=a[e];J(r.userComplete)&&r.userComplete(t),r.terminate(),delete a[e];}function y(){throw new Error("Not implemented.")}function w(e){if("object"!=typeof e||null===e)return e;var t=Array.isArray(e)?[]:{};for(var r in e)t[r]=w(e[r]);return t}function v(e,t){return function(){e.apply(t,arguments);}}function J(e){return "function"==typeof e}return o&&(f.onmessage=function(e){var t=e.data;void 0===b.WORKER_ID&&t&&(b.WORKER_ID=t.workerId);if("string"==typeof t.input)f.postMessage({workerId:b.WORKER_ID,results:b.parse(t.input,t.config),finished:!0});else if(f.File&&t.input instanceof File||t.input instanceof Object){var r=b.parse(t.input,t.config);r&&f.postMessage({workerId:b.WORKER_ID,results:r,finished:!0});}}),(l.prototype=Object.create(h.prototype)).constructor=l,(c.prototype=Object.create(h.prototype)).constructor=c,(p.prototype=Object.create(p.prototype)).constructor=p,(g.prototype=Object.create(h.prototype)).constructor=g,b}); 
	} (papaparse_min));

	var papaparse_minExports = papaparse_min.exports;
	var Papa = /*@__PURE__*/getDefaultExportFromCjs(papaparse_minExports);

	const manageParsedData = (platform, parsedData) => {
	    //only logins are handled for now
	    switch (platform) {
	        case "Safari": {
	            return transformSafariCredentials(parsedData);
	        }
	        case "Firefox": {
	            return transformFirefoxCredentials(parsedData);
	        }
	        case "Chrome":
	        case "Opera":
	        case "Edge": {
	            return transformChromeCredentials(parsedData);
	        }
	        case "Lastpass": {
	            return transformLastpassCredentials(parsedData);
	        }
	        case "Bitwarden": {
	            return transformBitwardenCredentials(parsedData);
	        }
	        case "Protonpass": {
	            return transformProtonpassCredentials(parsedData);
	        }
	        case "Dashlane": {
	            return transformDashlaneCredentials(parsedData);
	        }
	        case "Nordpass": {
	            return transformNordpassCredentials(parsedData);
	        }
	        case "Keepass": {
	            return transformKeepassCredentials(parsedData);
	        }
	        case "Roboform": {
	            return transformRoboformCredentials(parsedData);
	        }
	        case "1password": {
	            return transformOnepasswordCredentials(parsedData);
	        }
	        default: {
	            console.warn(`Unsupported platform: ${platform}`);
	            return [];
	        }
	    }
	};
	const papaparseWrapper = (file) => {
	    return new Promise((resolve, reject) => {
	        Papa.parse(file, {
	            complete: (results) => {
	                const parsedData = results.data;
	                resolve(parsedData);
	            },
	            header: true,
	            skipEmptyLines: true,
	            error: (error) => {
	                console.error("Error parsing CSV:", error);
	                reject(error);
	            },
	        });
	    });
	};
	const parseCsvLogins = async (file, platform) => {
	    let parsedData = [];
	    let intermediateData = [];
	    try {
	        parsedData = await papaparseWrapper(file);
	        intermediateData = manageParsedData(platform, parsedData);
	    }
	    catch (e) {
	        console.error("Parsing error");
	    }
	    return intermediateData;
	};
	const approvedCredentialSubmit = async ({ folderId, ...otherData }) => {
	    const response = await fetchFolderUsersForDataSync(folderId);
	    const usersToShare = response.data;
	    try {
	        const operationCompletionStatus = await Promise.allSettled(Object.values(otherData).map((data) => finalProcessing(folderId, usersToShare, data)));
	        const operationsCompletion = operationCompletionStatus.every((result) => result.status === "fulfilled" && result.value.success);
	        return operationsCompletion;
	    }
	    catch (error) {
	        console.error("Error in approvedCredentialSubmit:", error);
	        return false;
	    }
	};

	/* src/lib/components/dashboard/credentials/ImportTable.svelte generated by Svelte v4.2.19 */

	const { Object: Object_1 } = globals;
	const file$B = "src/lib/components/dashboard/credentials/ImportTable.svelte";

	function get_each_context$d(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[9] = list[i];
		child_ctx[10] = list;
		child_ctx[11] = i;
		return child_ctx;
	}

	// (39:3) {#each dataFromParser as cred, index}
	function create_each_block$d(ctx) {
		let tr;
		let td0;
		let input;
		let t0;
		let td1;
		let t1_value = /*cred*/ ctx[9].name + "";
		let t1;
		let t2;
		let td2;
		let t3_value = /*cred*/ ctx[9].username + "";
		let t3;
		let t4;
		let td3;
		let t5_value = /*cred*/ ctx[9].domain + "";
		let t5;
		let t6;
		let mounted;
		let dispose;

		function input_change_handler() {
			/*input_change_handler*/ ctx[5].call(input, /*index*/ ctx[11]);
		}

		function click_handler() {
			return /*click_handler*/ ctx[6](/*index*/ ctx[11]);
		}

		const block = {
			c: function create() {
				tr = element("tr");
				td0 = element("td");
				input = element("input");
				t0 = space();
				td1 = element("td");
				t1 = text(t1_value);
				t2 = space();
				td2 = element("td");
				t3 = text(t3_value);
				t4 = space();
				td3 = element("td");
				t5 = text(t5_value);
				t6 = space();
				attr_dev(input, "type", "checkbox");
				attr_dev(input, "class", "w-5 h-5 text-osvauld-carolinablue bg-osvauld-iconblack border border-osvauld-sheffieldgrey rounded active:outline-none focus:ring-offset-0 focus:ring-0 cursor-pointer");
				add_location(input, file$B, 56, 6, 1547);
				attr_dev(td0, "class", "px-6 py-4 text-center cursor-pointer");
				add_location(td0, file$B, 52, 5, 1431);
				attr_dev(td1, "class", "px-6 py-4");
				add_location(td1, file$B, 62, 5, 1835);
				attr_dev(td2, "class", "px-6 py-4");
				add_location(td2, file$B, 63, 5, 1879);
				attr_dev(td3, "class", "px-6 py-4");
				add_location(td3, file$B, 64, 5, 1927);
				attr_dev(tr, "class", "border-b border-osvauld-iconblack");
				add_location(tr, file$B, 51, 4, 1379);
			},
			m: function mount(target, anchor) {
				insert_dev(target, tr, anchor);
				append_dev(tr, td0);
				append_dev(td0, input);
				input.checked = /*selectedCredentials*/ ctx[1][/*index*/ ctx[11]];
				append_dev(tr, t0);
				append_dev(tr, td1);
				append_dev(td1, t1);
				append_dev(tr, t2);
				append_dev(tr, td2);
				append_dev(td2, t3);
				append_dev(tr, t4);
				append_dev(tr, td3);
				append_dev(td3, t5);
				append_dev(tr, t6);

				if (!mounted) {
					dispose = [
						listen_dev(input, "change", input_change_handler),
						listen_dev(td0, "click", click_handler, false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*selectedCredentials*/ 2) {
					input.checked = /*selectedCredentials*/ ctx[1][/*index*/ ctx[11]];
				}

				if (dirty & /*dataFromParser*/ 1 && t1_value !== (t1_value = /*cred*/ ctx[9].name + "")) set_data_dev(t1, t1_value);
				if (dirty & /*dataFromParser*/ 1 && t3_value !== (t3_value = /*cred*/ ctx[9].username + "")) set_data_dev(t3, t3_value);
				if (dirty & /*dataFromParser*/ 1 && t5_value !== (t5_value = /*cred*/ ctx[9].domain + "")) set_data_dev(t5, t5_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(tr);
				}

				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$d.name,
			type: "each",
			source: "(39:3) {#each dataFromParser as cred, index}",
			ctx
		});

		return block;
	}

	function create_fragment$B(ctx) {
		let div0;
		let table;
		let thead;
		let tr;
		let th0;
		let t0;
		let span;
		let t1;
		let t2;
		let t3;
		let t4;
		let th1;
		let t6;
		let th2;
		let t8;
		let th3;
		let t10;
		let tbody;
		let t11;
		let div1;
		let button;
		let mounted;
		let dispose;
		let each_value = ensure_array_like_dev(/*dataFromParser*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
		}

		const block = {
			c: function create() {
				div0 = element("div");
				table = element("table");
				thead = element("thead");
				tr = element("tr");
				th0 = element("th");
				t0 = text("Select ");
				span = element("span");
				t1 = text("(");
				t2 = text(/*selectionLength*/ ctx[2]);
				t3 = text(")");
				t4 = space();
				th1 = element("th");
				th1.textContent = "Name";
				t6 = space();
				th2 = element("th");
				th2.textContent = "Username";
				t8 = space();
				th3 = element("th");
				th3.textContent = "Domain";
				t10 = space();
				tbody = element("tbody");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t11 = space();
				div1 = element("div");
				button = element("button");
				button.textContent = "Proceed";
				add_location(span, file$B, 42, 13, 1147);
				attr_dev(th0, "class", "px-6 py-3 flex flex-col justify-center items-center");
				add_location(th0, file$B, 41, 4, 1070);
				attr_dev(th1, "class", "px-6 py-3");
				add_location(th1, file$B, 44, 4, 1194);
				attr_dev(th2, "class", "px-6 py-3");
				add_location(th2, file$B, 45, 4, 1230);
				attr_dev(th3, "class", "px-6 py-3");
				add_location(th3, file$B, 46, 4, 1270);
				add_location(tr, file$B, 40, 3, 1061);
				attr_dev(thead, "class", "text-xs uppercase sticky top-0 bg-osvauld-frameblack");
				add_location(thead, file$B, 39, 2, 989);
				add_location(tbody, file$B, 49, 2, 1326);
				attr_dev(table, "class", "w-full text-sm text-left text-osvauld-chalkwhite");
				add_location(table, file$B, 38, 1, 922);
				attr_dev(div0, "class", "w-full h-full overflow-y-auto overflow-x-hidden scrollbar-thin");
				add_location(div0, file$B, 37, 0, 844);
				attr_dev(button, "class", "px-6 py-2 bg-osvauld-carolinablue text-osvauld-frameblack rounded-lg hover:bg-osvauld-frameblack hover:text-osvauld-carolinablue border border-osvauld-carolinablue transition-all duration-300 ease-in-out");
				add_location(button, file$B, 72, 1, 2058);
				attr_dev(div1, "class", "flex justify-center mt-4");
				add_location(div1, file$B, 71, 0, 2018);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div0, anchor);
				append_dev(div0, table);
				append_dev(table, thead);
				append_dev(thead, tr);
				append_dev(tr, th0);
				append_dev(th0, t0);
				append_dev(th0, span);
				append_dev(span, t1);
				append_dev(span, t2);
				append_dev(span, t3);
				append_dev(tr, t4);
				append_dev(tr, th1);
				append_dev(tr, t6);
				append_dev(tr, th2);
				append_dev(tr, t8);
				append_dev(tr, th3);
				append_dev(table, t10);
				append_dev(table, tbody);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(tbody, null);
					}
				}

				insert_dev(target, t11, anchor);
				insert_dev(target, div1, anchor);
				append_dev(div1, button);

				if (!mounted) {
					dispose = listen_dev(button, "click", /*handleProceed*/ ctx[3], false, false, false, false);
					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*selectionLength*/ 4) set_data_dev(t2, /*selectionLength*/ ctx[2]);

				if (dirty & /*dataFromParser, changeSelection, selectedCredentials*/ 19) {
					each_value = ensure_array_like_dev(/*dataFromParser*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$d(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$d(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(tbody, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div0);
					detach_dev(t11);
					detach_dev(div1);
				}

				destroy_each(each_blocks, detaching);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$B.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$B($$self, $$props, $$invalidate) {
		let $selectedFolder;
		validate_store(selectedFolder, 'selectedFolder');
		component_subscribe($$self, selectedFolder, $$value => $$invalidate(7, $selectedFolder = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ImportTable', slots, []);
		let { dataFromParser } = $$props;
		const dispatch = createEventDispatcher();
		let selectedCredentials = {};
		let selectionLength;

		const handleProceed = () => {
			const filteredData = dataFromParser.filter((_, index) => selectedCredentials[index]);

			if ($selectedFolder) {
				dispatch("approved", {
					...filteredData,
					folderId: $selectedFolder.id
				});
			}
		};

		const changeSelection = index => {
			$$invalidate(1, selectedCredentials[index] = !selectedCredentials[index], selectedCredentials);
		};

		$$self.$$.on_mount.push(function () {
			if (dataFromParser === undefined && !('dataFromParser' in $$props || $$self.$$.bound[$$self.$$.props['dataFromParser']])) {
				console.warn("<ImportTable> was created without expected prop 'dataFromParser'");
			}
		});

		const writable_props = ['dataFromParser'];

		Object_1.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ImportTable> was created with unknown prop '${key}'`);
		});

		function input_change_handler(index) {
			selectedCredentials[index] = this.checked;
			($$invalidate(1, selectedCredentials), $$invalidate(0, dataFromParser));
		}

		const click_handler = index => changeSelection(index);

		$$self.$$set = $$props => {
			if ('dataFromParser' in $$props) $$invalidate(0, dataFromParser = $$props.dataFromParser);
		};

		$$self.$capture_state = () => ({
			createEventDispatcher,
			selectedFolder,
			dataFromParser,
			dispatch,
			selectedCredentials,
			selectionLength,
			handleProceed,
			changeSelection,
			$selectedFolder
		});

		$$self.$inject_state = $$props => {
			if ('dataFromParser' in $$props) $$invalidate(0, dataFromParser = $$props.dataFromParser);
			if ('selectedCredentials' in $$props) $$invalidate(1, selectedCredentials = $$props.selectedCredentials);
			if ('selectionLength' in $$props) $$invalidate(2, selectionLength = $$props.selectionLength);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*dataFromParser, selectedCredentials*/ 3) {
				{
					dataFromParser.forEach((_, index) => {
						if (!(index in selectedCredentials)) {
							$$invalidate(1, selectedCredentials[index] = true, selectedCredentials);
						}
					});

					$$invalidate(2, selectionLength = Object.values(selectedCredentials).filter(checked => checked === true).length);
				}
			}
		};

		return [
			dataFromParser,
			selectedCredentials,
			selectionLength,
			handleProceed,
			changeSelection,
			input_change_handler,
			click_handler
		];
	}

	class ImportTable extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$B, create_fragment$B, safe_not_equal, { dataFromParser: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ImportTable",
				options,
				id: create_fragment$B.name
			});
		}

		get dataFromParser() {
			throw new Error("<ImportTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set dataFromParser(value) {
			throw new Error("<ImportTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/ImportLoader.svelte generated by Svelte v4.2.19 */
	const file$A = "src/lib/components/basic/ImportLoader.svelte";

	function create_fragment$A(ctx) {
		let div;
		let svg0;
		let g0;
		let path0;
		let path1;
		let t0;
		let svg1;
		let g1;
		let mask;
		let path2;
		let path3;
		let path4;
		let path5;
		let path6;
		let path7;
		let path8;
		let path9;
		let t1;
		let svg2;
		let g2;
		let path10;
		let path11;
		let path12;
		let path13;
		let t2;
		let svg3;
		let g3;
		let path14;
		let path15;
		let t3;
		let svg4;
		let path16;
		let path17;

		const block = {
			c: function create() {
				div = element("div");
				svg0 = svg_element("svg");
				g0 = svg_element("g");
				path0 = svg_element("path");
				path1 = svg_element("path");
				t0 = space();
				svg1 = svg_element("svg");
				g1 = svg_element("g");
				mask = svg_element("mask");
				path2 = svg_element("path");
				path3 = svg_element("path");
				path4 = svg_element("path");
				path5 = svg_element("path");
				path6 = svg_element("path");
				path7 = svg_element("path");
				path8 = svg_element("path");
				path9 = svg_element("path");
				t1 = space();
				svg2 = svg_element("svg");
				g2 = svg_element("g");
				path10 = svg_element("path");
				path11 = svg_element("path");
				path12 = svg_element("path");
				path13 = svg_element("path");
				t2 = space();
				svg3 = svg_element("svg");
				g3 = svg_element("g");
				path14 = svg_element("path");
				path15 = svg_element("path");
				t3 = space();
				svg4 = svg_element("svg");
				path16 = svg_element("path");
				path17 = svg_element("path");
				attr_dev(path0, "d", "M72 172C72 116.772 116.772 72 172 72C227.228 72 272 116.772 272 172C272 227.228 227.228 272 172 272C116.772 272 72 227.228 72 172ZM197.322 172C197.322 158.015 185.985 146.678 172 146.678C158.015 146.678 146.678 158.015 146.678 172C146.678 185.985 158.015 197.322 172 197.322C185.985 197.322 197.322 185.985 197.322 172Z");
				add_location(path0, file$A, 68, 3, 1266);
				attr_dev(path1, "mask", "url(#path-1-inside-1_111_3212)");
				attr_dev(path1, "stroke-miterlimit", "16");
				attr_dev(path1, "stroke-width", "2");
				attr_dev(path1, "stroke", "#89B4FA");
				attr_dev(path1, "d", "M72 172C72 116.772 116.772 72 172 72C227.228 72 272 116.772 272 172C272 227.228 227.228 272 172 272C116.772 272 72 227.228 72 172ZM197.322 172C197.322 158.015 185.985 146.678 172 146.678C158.015 146.678 146.678 158.015 146.678 172C146.678 185.985 158.015 197.322 172 197.322C185.985 197.322 197.322 185.985 197.322 172Z");
				add_location(path1, file$A, 71, 3, 1615);
				attr_dev(g0, "id", "out1");
				add_location(g0, file$A, 67, 2, 1249);
				set_style(svg0, "--i", "0");
				set_style(svg0, "--j", "0");
				attr_dev(svg0, "class", "svelte-iuc4oc");
				add_location(svg0, file$A, 66, 1, 1220);
				attr_dev(path2, "d", "M102.892 127.966C93.3733 142.905 88.9517 160.527 90.2897 178.19L94.3752 177.88C93.1041 161.1 97.3046 144.36 106.347 130.168L102.892 127.966Z");
				add_location(path2, file$A, 84, 4, 2189);
				attr_dev(path3, "d", "M93.3401 194.968C98.3049 211.971 108.646 226.908 122.814 237.541L125.273 234.264C111.814 224.163 101.99 209.973 97.2731 193.819L93.3401 194.968Z");
				add_location(path3, file$A, 87, 4, 2362);
				attr_dev(path4, "d", "M152.707 92.3592C140.33 95.3575 128.822 101.199 119.097 109.421L121.742 112.55C130.981 104.739 141.914 99.1897 153.672 96.3413L152.707 92.3592Z");
				add_location(path4, file$A, 90, 4, 2539);
				attr_dev(path5, "d", "M253.294 161.699C255.099 175.937 253.132 190.4 247.59 203.639L243.811 202.057C249.075 189.48 250.944 175.74 249.23 162.214L253.294 161.699Z");
				add_location(path5, file$A, 93, 4, 2715);
				attr_dev(path6, "d", "M172 90.0557C184.677 90.0557 197.18 92.9967 208.528 98.6474C219.875 104.298 229.757 112.505 237.396 122.621L234.126 125.09C226.869 115.479 217.481 107.683 206.701 102.315C195.921 96.9469 184.043 94.1529 172 94.1529V90.0557Z");
				add_location(path6, file$A, 96, 4, 2887);
				attr_dev(path7, "d", "M244.195 133.235C246.991 138.442 249.216 143.937 250.83 149.623L246.888 150.742C245.355 145.34 243.242 140.12 240.586 135.174L244.195 133.235Z");
				add_location(path7, file$A, 99, 4, 3143);
				attr_dev(path8, "d", "M234.238 225.304C223.932 237.338 210.358 246.126 195.159 250.604C179.961 255.082 163.79 255.058 148.606 250.534L149.775 246.607C164.201 250.905 179.563 250.928 194.001 246.674C208.44 242.42 221.335 234.071 231.126 222.639L234.238 225.304Z");
				add_location(path8, file$A, 102, 4, 3318);
				attr_dev(mask, "fill", "white");
				attr_dev(mask, "id", "path-2-inside-2_111_3212");
				add_location(mask, file$A, 83, 3, 2135);
				attr_dev(path9, "mask", "url(#path-2-inside-2_111_3212)");
				attr_dev(path9, "fill", "#89B4FA");
				attr_dev(path9, "d", "M102.892 127.966L105.579 123.75L101.362 121.063L98.6752 125.28L102.892 127.966ZM90.2897 178.19L85.304 178.567L85.6817 183.553L90.6674 183.175L90.2897 178.19ZM94.3752 177.88L94.7529 182.866L99.7386 182.488L99.3609 177.503L94.3752 177.88ZM106.347 130.168L110.564 132.855L113.251 128.638L109.034 125.951L106.347 130.168ZM93.3401 194.968L91.9387 190.168L87.1391 191.569L88.5405 196.369L93.3401 194.968ZM122.814 237.541L119.813 241.54L123.812 244.541L126.813 240.542L122.814 237.541ZM125.273 234.264L129.272 237.265L132.273 233.266L128.274 230.265L125.273 234.264ZM97.2731 193.819L102.073 192.418L100.671 187.618L95.8717 189.02L97.2731 193.819ZM152.707 92.3592L157.567 91.182L156.389 86.3226L151.53 87.4998L152.707 92.3592ZM119.097 109.421L115.869 105.603L112.05 108.831L115.278 112.649L119.097 109.421ZM121.742 112.55L117.924 115.778L121.152 119.596L124.97 116.368L121.742 112.55ZM153.672 96.3413L154.849 101.201L159.708 100.023L158.531 95.1641L153.672 96.3413ZM253.294 161.699L258.255 161.07L257.626 156.11L252.666 156.738L253.294 161.699ZM247.59 203.639L245.66 208.251L250.272 210.182L252.203 205.569L247.59 203.639ZM243.811 202.057L239.198 200.126L237.268 204.739L241.88 206.669L243.811 202.057ZM249.23 162.214L248.601 157.253L243.641 157.882L244.269 162.842L249.23 162.214ZM172 90.0557V85.0557H167V90.0557H172ZM208.528 98.6474L206.299 103.123L206.299 103.123L208.528 98.6474ZM237.396 122.621L240.409 126.611L244.399 123.598L241.386 119.608L237.396 122.621ZM234.126 125.09L230.136 128.103L233.149 132.093L237.139 129.08L234.126 125.09ZM206.701 102.315L204.473 106.791L204.473 106.791L206.701 102.315ZM172 94.1529H167V99.1529H172V94.1529ZM244.195 133.235L248.601 130.87L246.235 126.465L241.83 128.83L244.195 133.235ZM250.83 149.623L252.195 154.433L257.005 153.067L255.64 148.257L250.83 149.623ZM246.888 150.742L242.078 152.107L243.444 156.917L248.254 155.552L246.888 150.742ZM240.586 135.174L238.22 130.768L233.815 133.134L236.181 137.539L240.586 135.174ZM234.238 225.304L238.036 228.556L241.288 224.759L237.491 221.506L234.238 225.304ZM195.159 250.604L196.572 255.4L196.572 255.4L195.159 250.604ZM148.606 250.534L143.814 249.107L142.386 253.899L147.178 255.326L148.606 250.534ZM149.775 246.607L151.203 241.816L146.411 240.388L144.983 245.18L149.775 246.607ZM194.001 246.674L195.415 251.47L195.415 251.47L194.001 246.674ZM231.126 222.639L234.379 218.841L230.581 215.589L227.329 219.386L231.126 222.639ZM98.6752 125.28C88.5757 141.13 83.8844 159.826 85.304 178.567L95.2754 177.812C94.0191 161.227 98.1709 144.681 107.109 130.653L98.6752 125.28ZM90.6674 183.175L94.7529 182.866L93.9976 172.895L89.912 173.204L90.6674 183.175ZM99.3609 177.503C98.1715 161.8 102.102 146.135 110.564 132.855L102.131 127.481C92.5071 142.585 88.0368 160.4 89.3895 178.258L99.3609 177.503ZM109.034 125.951L105.579 123.75L100.205 132.183L103.661 134.385L109.034 125.951ZM88.5405 196.369C93.8083 214.41 104.78 230.259 119.813 241.54L125.815 233.542C112.512 223.558 102.802 209.532 98.1397 193.566L88.5405 196.369ZM126.813 240.542L129.272 237.265L121.274 231.263L118.815 234.54L126.813 240.542ZM128.274 230.265C115.679 220.813 106.486 207.534 102.073 192.418L92.4735 195.221C97.493 212.412 107.948 227.513 122.272 238.263L128.274 230.265ZM95.8717 189.02L91.9387 190.168L94.7415 199.767L98.6745 198.619L95.8717 189.02ZM151.53 87.4998C138.398 90.681 126.188 96.8793 115.869 105.603L122.325 113.239C131.457 105.519 142.262 100.034 153.884 97.2187L151.53 87.4998ZM115.278 112.649L117.924 115.778L125.56 109.322L122.915 106.193L115.278 112.649ZM124.97 116.368C133.616 109.059 143.846 103.866 154.849 101.201L152.495 91.4818C139.981 94.5132 128.347 100.419 118.514 108.732L124.97 116.368ZM158.531 95.1641L157.567 91.182L147.848 93.5364L148.812 97.5185L158.531 95.1641ZM248.334 162.327C250.028 175.697 248.181 189.277 242.978 201.708L252.203 205.569C258.082 191.522 260.169 176.177 258.255 161.07L248.334 162.327ZM249.521 199.027L245.741 197.445L241.88 206.669L245.66 208.251L249.521 199.027ZM248.423 203.987C254.025 190.602 256.014 175.98 254.19 161.585L244.269 162.842C245.873 175.5 244.125 188.357 239.198 200.126L248.423 203.987ZM249.858 167.174L253.923 166.659L252.666 156.738L248.601 157.253L249.858 167.174ZM172 95.0557C183.903 95.0557 195.644 97.8172 206.299 103.123L210.757 94.1717C198.717 88.1761 185.45 85.0557 172 85.0557V95.0557ZM206.299 103.123C216.954 108.429 226.233 116.135 233.406 125.634L241.386 119.608C233.281 108.874 222.796 100.167 210.757 94.1717L206.299 103.123ZM234.383 118.631L231.113 121.1L237.139 129.08L240.409 126.611L234.383 118.631ZM238.116 122.077C230.393 111.849 220.403 103.552 208.93 97.8393L204.473 106.791C214.56 111.814 223.345 119.11 230.136 128.103L238.116 122.077ZM208.93 97.8393C197.458 92.1263 184.816 89.1529 172 89.1529V99.1529C183.269 99.1529 194.385 101.767 204.473 106.791L208.93 97.8393ZM177 94.1529V90.0557H167V94.1529H177ZM239.79 135.601C242.416 140.49 244.504 145.649 246.02 150.988L255.64 148.257C253.927 142.225 251.567 136.395 248.601 130.87L239.79 135.601ZM249.464 144.813L245.523 145.932L248.254 155.552L252.195 154.433L249.464 144.813ZM251.698 149.376C250.067 143.628 247.818 138.073 244.991 132.808L236.181 137.539C238.666 142.168 240.644 147.052 242.078 152.107L251.698 149.376ZM242.951 139.579L246.561 137.64L241.83 128.83L238.22 130.768L242.951 139.579ZM230.441 222.051C220.763 233.351 208.017 241.603 193.746 245.808L196.572 255.4C212.698 250.649 227.101 241.325 238.036 228.556L230.441 222.051ZM193.746 245.808C179.475 250.012 164.291 249.99 150.033 245.742L147.178 255.326C163.289 260.125 180.447 260.151 196.572 255.4L193.746 245.808ZM153.397 251.962L154.567 248.035L144.983 245.18L143.814 249.107L153.397 251.962ZM148.348 251.399C163.7 255.973 180.049 255.997 195.415 251.47L192.588 241.877C179.077 245.858 164.702 245.837 151.203 241.816L148.348 251.399ZM195.415 251.47C210.78 246.942 224.504 238.058 234.924 225.891L227.329 219.386C218.167 230.084 206.099 237.897 192.588 241.877L195.415 251.47ZM227.874 226.436L230.986 229.101L237.491 221.506L234.379 218.841L227.874 226.436Z");
				add_location(path9, file$A, 106, 3, 3599);
				attr_dev(g1, "id", "out2");
				attr_dev(g1, "class", "svelte-iuc4oc");
				add_location(g1, file$A, 82, 2, 2118);
				set_style(svg1, "--i", "1");
				set_style(svg1, "--j", "1");
				attr_dev(svg1, "class", "svelte-iuc4oc");
				add_location(svg1, file$A, 81, 1, 2089);
				attr_dev(path10, "d", "M195.136 135.689C188.115 131.215 179.948 128.873 171.624 128.946C163.299 129.019 155.174 131.503 148.232 136.099L148.42 136.382C155.307 131.823 163.368 129.358 171.627 129.286C179.886 129.213 187.988 131.537 194.954 135.975L195.136 135.689Z");
				add_location(path10, file$A, 116, 3, 9762);
				attr_dev(path11, "d", "M195.136 208.311C188.115 212.784 179.948 215.127 171.624 215.054C163.299 214.981 155.174 212.496 148.232 207.901L148.42 207.618C155.307 212.177 163.368 214.642 171.627 214.714C179.886 214.786 187.988 212.463 194.954 208.025L195.136 208.311Z");
				add_location(path11, file$A, 119, 3, 10032);
				attr_dev(path12, "mask", "url(#path-5-inside-3_111_3212)");
				attr_dev(path12, "fill", "#89B4FA");
				attr_dev(path12, "d", "M195.136 135.689L195.474 135.904L195.689 135.566L195.351 135.352L195.136 135.689ZM171.624 128.946L171.627 129.346L171.624 128.946ZM148.232 136.099L148.011 135.765L147.678 135.986L147.899 136.32L148.232 136.099ZM148.42 136.382L148.086 136.603L148.307 136.936L148.641 136.716L148.42 136.382ZM171.627 129.286L171.63 129.686L171.627 129.286ZM194.954 135.975L194.739 136.313L195.076 136.528L195.291 136.19L194.954 135.975ZM195.136 208.311L195.351 208.648L195.689 208.433L195.474 208.096L195.136 208.311ZM171.624 215.054L171.627 214.654L171.624 215.054ZM148.232 207.901L147.899 207.68L147.678 208.014L148.011 208.234L148.232 207.901ZM148.42 207.618L148.641 207.284L148.307 207.063L148.086 207.397L148.42 207.618ZM171.627 214.714L171.63 214.314L171.627 214.714ZM194.954 208.025L195.291 207.81L195.076 207.472L194.739 207.687L194.954 208.025ZM195.351 135.352C188.265 130.836 180.022 128.473 171.62 128.546L171.627 129.346C179.874 129.274 187.966 131.594 194.921 136.026L195.351 135.352ZM171.62 128.546C163.218 128.619 155.018 131.127 148.011 135.765L148.453 136.432C155.33 131.88 163.38 129.418 171.627 129.346L171.62 128.546ZM147.899 136.32L148.086 136.603L148.753 136.161L148.566 135.878L147.899 136.32ZM148.641 136.716C155.463 132.199 163.448 129.757 171.63 129.686L171.623 128.886C163.287 128.958 155.15 131.447 148.199 136.049L148.641 136.716ZM171.63 129.686C179.812 129.614 187.839 131.916 194.739 136.313L195.169 135.638C188.138 131.158 179.959 128.813 171.623 128.886L171.63 129.686ZM195.291 136.19L195.474 135.904L194.799 135.474L194.617 135.76L195.291 136.19ZM194.921 207.974C187.966 212.406 179.874 214.726 171.627 214.654L171.62 215.454C180.022 215.527 188.265 213.163 195.351 208.648L194.921 207.974ZM171.627 214.654C163.38 214.582 155.33 212.12 148.453 207.567L148.011 208.234C155.018 212.873 163.218 215.38 171.62 215.454L171.627 214.654ZM148.566 208.122L148.753 207.838L148.086 207.397L147.899 207.68L148.566 208.122ZM148.199 207.951C155.15 212.553 163.287 215.041 171.623 215.114L171.63 214.314C163.448 214.243 155.463 211.801 148.641 207.284L148.199 207.951ZM171.623 215.114C179.959 215.187 188.138 212.842 195.169 208.362L194.739 207.687C187.839 212.084 179.812 214.386 171.63 214.314L171.623 215.114ZM194.617 208.239L194.799 208.526L195.474 208.096L195.291 207.81L194.617 208.239Z");
				add_location(path12, file$A, 122, 3, 10302);
				attr_dev(g2, "id", "inner3");
				attr_dev(g2, "class", "svelte-iuc4oc");
				add_location(g2, file$A, 115, 2, 9743);
				attr_dev(path13, "stroke", "#89B4FA");
				attr_dev(path13, "d", "M240.944 172C240.944 187.951 235.414 203.408 225.295 215.738C215.176 228.068 201.095 236.508 185.45 239.62C169.806 242.732 153.567 240.323 139.5 232.804C125.433 225.285 114.408 213.12 108.304 198.384C102.2 183.648 101.394 167.25 106.024 151.987C110.654 136.723 120.434 123.537 133.696 114.675C146.959 105.813 162.884 101.824 178.758 103.388C194.632 104.951 209.472 111.97 220.751 123.249");
				attr_dev(path13, "id", "out3");
				attr_dev(path13, "class", "svelte-iuc4oc");
				add_location(path13, file$A, 128, 2, 12691);
				set_style(svg2, "--i", "0");
				set_style(svg2, "--j", "2");
				attr_dev(svg2, "class", "svelte-iuc4oc");
				add_location(svg2, file$A, 114, 1, 9714);
				attr_dev(path14, "fill", "#89B4FA");
				attr_dev(path14, "d", "M145.949 124.51L148.554 129.259C156.575 124.859 165.672 122.804 174.806 123.331C183.94 123.858 192.741 126.944 200.203 132.236C207.665 137.529 213.488 144.815 217.004 153.261C220.521 161.707 221.59 170.972 220.09 179.997L224.108 180.665L224.102 180.699L229.537 181.607C230.521 175.715 230.594 169.708 229.753 163.795L225.628 164.381C224.987 159.867 223.775 155.429 222.005 151.179C218.097 141.795 211.628 133.699 203.337 127.818C195.045 121.937 185.266 118.508 175.118 117.923C165.302 117.357 155.525 119.474 146.83 124.037C146.535 124.192 146.241 124.349 145.949 124.51ZM224.638 164.522C224.009 160.091 222.819 155.735 221.082 151.563C217.246 142.352 210.897 134.406 202.758 128.634C194.62 122.862 185.021 119.496 175.06 118.922C165.432 118.367 155.841 120.441 147.311 124.914L148.954 127.91C156.922 123.745 165.876 121.814 174.864 122.333C184.185 122.87 193.166 126.019 200.782 131.421C208.397 136.822 214.339 144.257 217.928 152.877C221.388 161.188 222.526 170.276 221.23 179.173L224.262 179.677C224.998 174.671 225.35 169.535 224.638 164.522Z");
				attr_dev(path14, "clip-rule", "evenodd");
				attr_dev(path14, "fill-rule", "evenodd");
				add_location(path14, file$A, 137, 3, 13194);
				attr_dev(path15, "fill", "#89B4FA");
				attr_dev(path15, "d", "M139.91 220.713C134.922 217.428 130.469 213.395 126.705 208.758L130.983 205.286L130.985 205.288L134.148 202.721C141.342 211.584 151.417 217.642 162.619 219.839C173.821 222.036 185.438 220.232 195.446 214.742L198.051 219.491C197.759 219.651 197.465 219.809 197.17 219.963C186.252 225.693 173.696 227.531 161.577 225.154C154.613 223.789 148.041 221.08 142.202 217.234L139.91 220.713ZM142.752 216.399C148.483 220.174 154.934 222.833 161.769 224.173C173.658 226.504 185.977 224.704 196.689 219.087L195.046 216.09C185.035 221.323 173.531 222.998 162.427 220.82C151.323 218.643 141.303 212.747 134.01 204.122L131.182 206.5C134.451 210.376 138.515 213.607 142.752 216.399Z");
				attr_dev(path15, "clip-rule", "evenodd");
				attr_dev(path15, "fill-rule", "evenodd");
				add_location(path15, file$A, 143, 3, 14337);
				attr_dev(g3, "id", "inner1");
				attr_dev(g3, "class", "svelte-iuc4oc");
				add_location(g3, file$A, 136, 2, 13175);
				set_style(svg3, "--i", "1");
				set_style(svg3, "--j", "3");
				attr_dev(svg3, "class", "svelte-iuc4oc");
				add_location(svg3, file$A, 135, 1, 13146);
				attr_dev(path16, "fill", "#89B4FA");
				attr_dev(path16, "d", "M180.956 186.056C183.849 184.212 186.103 181.521 187.41 178.349C188.717 175.177 189.013 171.679 188.258 168.332C187.503 164.986 185.734 161.954 183.192 159.65C180.649 157.346 177.458 155.883 174.054 155.46C170.649 155.038 167.197 155.676 164.169 157.288C161.14 158.9 158.683 161.407 157.133 164.468C155.582 167.528 155.014 170.992 155.505 174.388C155.997 177.783 157.524 180.944 159.879 183.439L161.129 182.259C159.018 180.021 157.648 177.186 157.207 174.141C156.766 171.096 157.276 167.989 158.667 165.245C160.057 162.5 162.261 160.252 164.977 158.806C167.693 157.36 170.788 156.788 173.842 157.167C176.895 157.546 179.757 158.858 182.037 160.924C184.317 162.99 185.904 165.709 186.581 168.711C187.258 171.712 186.992 174.849 185.82 177.694C184.648 180.539 182.627 182.952 180.032 184.606L180.956 186.056Z");
				attr_dev(path16, "id", "center1");
				attr_dev(path16, "class", "svelte-iuc4oc");
				add_location(path16, file$A, 153, 2, 15142);
				attr_dev(path17, "fill", "#89B4FA");
				attr_dev(path17, "d", "M172 166.445C175.068 166.445 177.556 168.932 177.556 172C177.556 175.068 175.068 177.556 172 177.556C168.932 177.556 166.444 175.068 166.444 172C166.444 168.932 168.932 166.445 172 166.445ZM172 177.021C174.773 177.021 177.021 174.773 177.021 172C177.021 169.227 174.773 166.979 172 166.979C169.227 166.979 166.979 169.227 166.979 172C166.979 174.773 169.227 177.021 172 177.021Z");
				attr_dev(path17, "id", "center");
				attr_dev(path17, "class", "svelte-iuc4oc");
				add_location(path17, file$A, 158, 2, 16009);
				set_style(svg4, "--i", "2");
				set_style(svg4, "--j", "4");
				attr_dev(svg4, "class", "svelte-iuc4oc");
				add_location(svg4, file$A, 152, 1, 15113);
				attr_dev(div, "class", "svg-frame svelte-iuc4oc");
				add_location(div, file$A, 65, 0, 1195);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, svg0);
				append_dev(svg0, g0);
				append_dev(g0, path0);
				append_dev(g0, path1);
				append_dev(div, t0);
				append_dev(div, svg1);
				append_dev(svg1, g1);
				append_dev(g1, mask);
				append_dev(mask, path2);
				append_dev(mask, path3);
				append_dev(mask, path4);
				append_dev(mask, path5);
				append_dev(mask, path6);
				append_dev(mask, path7);
				append_dev(mask, path8);
				append_dev(g1, path9);
				append_dev(div, t1);
				append_dev(div, svg2);
				append_dev(svg2, g2);
				append_dev(g2, path10);
				append_dev(g2, path11);
				append_dev(g2, path12);
				append_dev(svg2, path13);
				append_dev(div, t2);
				append_dev(div, svg3);
				append_dev(svg3, g3);
				append_dev(g3, path14);
				append_dev(g3, path15);
				append_dev(div, t3);
				append_dev(div, svg4);
				append_dev(svg4, path16);
				append_dev(svg4, path17);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$A.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$A($$self, $$props) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ImportLoader', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ImportLoader> was created with unknown prop '${key}'`);
		});

		return [];
	}

	class ImportLoader extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$A, create_fragment$A, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ImportLoader",
				options,
				id: create_fragment$A.name
			});
		}
	}

	/* src/lib/components/basic/ImportMessage.svelte generated by Svelte v4.2.19 */
	const file$z = "src/lib/components/basic/ImportMessage.svelte";

	function create_fragment$z(ctx) {
		let div2;
		let div1;
		let div0;
		let span0;
		let t1;
		let span1;
		let t3;
		let span2;
		let t5;
		let span3;
		let t7;
		let span4;

		const block = {
			c: function create() {
				div2 = element("div");
				div1 = element("div");
				div0 = element("div");
				span0 = element("span");
				span0.textContent = "Cryptographic operations in progress...";
				t1 = space();
				span1 = element("span");
				span1.textContent = "Fetching public keys...";
				t3 = space();
				span2 = element("span");
				span2.textContent = "Invoking WASM module...";
				t5 = space();
				span3 = element("span");
				span3.textContent = "Encrypting Credentials...";
				t7 = space();
				span4 = element("span");
				span4.textContent = "Adding Digital Signature...";
				attr_dev(span0, "class", "word text-center svelte-1ymtngu");
				add_location(span0, file$z, 81, 3, 1045);
				attr_dev(span1, "class", "word text-center svelte-1ymtngu");
				add_location(span1, file$z, 84, 3, 1135);
				attr_dev(span2, "class", "word text-center svelte-1ymtngu");
				add_location(span2, file$z, 85, 3, 1200);
				attr_dev(span3, "class", "word text-center svelte-1ymtngu");
				add_location(span3, file$z, 86, 3, 1265);
				attr_dev(span4, "class", "word text-center svelte-1ymtngu");
				add_location(span4, file$z, 87, 3, 1332);
				attr_dev(div0, "class", "words svelte-1ymtngu");
				add_location(div0, file$z, 80, 2, 1022);
				attr_dev(div1, "class", "loader svelte-1ymtngu");
				add_location(div1, file$z, 79, 1, 999);
				attr_dev(div2, "class", "card svelte-1ymtngu");
				add_location(div2, file$z, 78, 0, 979);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div2, anchor);
				append_dev(div2, div1);
				append_dev(div1, div0);
				append_dev(div0, span0);
				append_dev(div0, t1);
				append_dev(div0, span1);
				append_dev(div0, t3);
				append_dev(div0, span2);
				append_dev(div0, t5);
				append_dev(div0, span3);
				append_dev(div0, t7);
				append_dev(div0, span4);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div2);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$z.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$z($$self, $$props) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ImportMessage', slots, []);
		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ImportMessage> was created with unknown prop '${key}'`);
		});

		return [];
	}

	class ImportMessage extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$z, create_fragment$z, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ImportMessage",
				options,
				id: create_fragment$z.name
			});
		}
	}

	/* src/lib/components/basic/SuccessView.svelte generated by Svelte v4.2.19 */
	const file$y = "src/lib/components/basic/SuccessView.svelte";

	// (99:0) {:else}
	function create_else_block$i(ctx) {
		let svg;
		let circle;
		let line0;
		let line1;
		let t0;
		let p;

		let t1_value = (/*$changePassword*/ ctx[2]
		? "Wrong Passphrase"
		: /*recovery*/ ctx[0]
			? "Wrong Passphrase!"
			: "Import InComplete!") + "";

		let t1;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				circle = svg_element("circle");
				line0 = svg_element("line");
				line1 = svg_element("line");
				t0 = space();
				p = element("p");
				t1 = text(t1_value);
				attr_dev(circle, "class", "path circle svelte-1fmcatl");
				attr_dev(circle, "fill", "none");
				attr_dev(circle, "stroke", "#D06079");
				attr_dev(circle, "stroke-width", "6");
				attr_dev(circle, "stroke-miterlimit", "10");
				attr_dev(circle, "cx", "65.1");
				attr_dev(circle, "cy", "65.1");
				attr_dev(circle, "r", "62.1");
				add_location(circle, file$y, 126, 2, 1607);
				attr_dev(line0, "class", "path line svelte-1fmcatl");
				attr_dev(line0, "fill", "none");
				attr_dev(line0, "stroke", "#D06079");
				attr_dev(line0, "stroke-width", "6");
				attr_dev(line0, "stroke-linecap", "round");
				attr_dev(line0, "stroke-miterlimit", "10");
				attr_dev(line0, "x1", "34.4");
				attr_dev(line0, "y1", "37.9");
				attr_dev(line0, "x2", "95.8");
				attr_dev(line0, "y2", "92.3");
				add_location(line0, file$y, 136, 2, 1772);
				attr_dev(line1, "class", "path line svelte-1fmcatl");
				attr_dev(line1, "fill", "none");
				attr_dev(line1, "stroke", "#D06079");
				attr_dev(line1, "stroke-width", "6");
				attr_dev(line1, "stroke-linecap", "round");
				attr_dev(line1, "stroke-miterlimit", "10");
				attr_dev(line1, "x1", "95.8");
				attr_dev(line1, "y1", "38");
				attr_dev(line1, "x2", "34.4");
				attr_dev(line1, "y2", "92.2");
				add_location(line1, file$y, 148, 2, 1971);
				attr_dev(svg, "version", "1.1");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "viewBox", "0 0 130.2 130.2");
				attr_dev(svg, "class", "svelte-1fmcatl");
				add_location(svg, file$y, 121, 1, 1516);
				attr_dev(p, "class", "error svelte-1fmcatl");
				add_location(p, file$y, 161, 1, 2175);
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, circle);
				append_dev(svg, line0);
				append_dev(svg, line1);
				insert_dev(target, t0, anchor);
				insert_dev(target, p, anchor);
				append_dev(p, t1);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*$changePassword, recovery*/ 5 && t1_value !== (t1_value = (/*$changePassword*/ ctx[2]
				? "Wrong Passphrase"
				: /*recovery*/ ctx[0]
					? "Wrong Passphrase!"
					: "Import InComplete!") + "")) set_data_dev(t1, t1_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
					detach_dev(t0);
					detach_dev(p);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$i.name,
			type: "else",
			source: "(99:0) {:else}",
			ctx
		});

		return block;
	}

	// (66:0) {#if status}
	function create_if_block$q(ctx) {
		let svg;
		let circle;
		let polyline;
		let t0;
		let p;

		let t1_value = (/*$changePassword*/ ctx[2]
		? "Passphrase Changed"
		: /*recovery*/ ctx[0]
			? "Copied to Clipboard"
			: "Import Complete!") + "";

		let t1;

		const block = {
			c: function create() {
				svg = svg_element("svg");
				circle = svg_element("circle");
				polyline = svg_element("polyline");
				t0 = space();
				p = element("p");
				t1 = text(t1_value);
				attr_dev(circle, "class", "path circle svelte-1fmcatl");
				attr_dev(circle, "fill", "none");
				attr_dev(circle, "stroke", "#52e376c2");
				attr_dev(circle, "stroke-width", "6");
				attr_dev(circle, "stroke-miterlimit", "10");
				attr_dev(circle, "cx", "65.1");
				attr_dev(circle, "cy", "65.1");
				attr_dev(circle, "r", "62.1");
				add_location(circle, file$y, 93, 2, 992);
				attr_dev(polyline, "class", "path check svelte-1fmcatl");
				attr_dev(polyline, "fill", "none");
				attr_dev(polyline, "stroke", "#52e376c2");
				attr_dev(polyline, "stroke-width", "6");
				attr_dev(polyline, "stroke-linecap", "round");
				attr_dev(polyline, "stroke-miterlimit", "10");
				attr_dev(polyline, "points", "100.2,40.2 51.5,88.8 29.8,67.5 ");
				add_location(polyline, file$y, 103, 2, 1159);
				attr_dev(svg, "version", "1.1");
				attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
				attr_dev(svg, "viewBox", "0 0 130.2 130.2");
				attr_dev(svg, "class", "svelte-1fmcatl");
				add_location(svg, file$y, 88, 1, 901);
				attr_dev(p, "class", "success svelte-1fmcatl");
				add_location(p, file$y, 113, 1, 1368);
			},
			m: function mount(target, anchor) {
				insert_dev(target, svg, anchor);
				append_dev(svg, circle);
				append_dev(svg, polyline);
				insert_dev(target, t0, anchor);
				insert_dev(target, p, anchor);
				append_dev(p, t1);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*$changePassword, recovery*/ 5 && t1_value !== (t1_value = (/*$changePassword*/ ctx[2]
				? "Passphrase Changed"
				: /*recovery*/ ctx[0]
					? "Copied to Clipboard"
					: "Import Complete!") + "")) set_data_dev(t1, t1_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(svg);
					detach_dev(t0);
					detach_dev(p);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$q.name,
			type: "if",
			source: "(66:0) {#if status}",
			ctx
		});

		return block;
	}

	function create_fragment$y(ctx) {
		let if_block_anchor;

		function select_block_type(ctx, dirty) {
			if (/*status*/ ctx[1]) return create_if_block$q;
			return create_else_block$i;
		}

		let current_block_type = select_block_type(ctx);
		let if_block = current_block_type(ctx);

		const block = {
			c: function create() {
				if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
			},
			p: function update(ctx, [dirty]) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$y.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$y($$self, $$props, $$invalidate) {
		let $changePassword;
		validate_store(changePassword, 'changePassword');
		component_subscribe($$self, changePassword, $$value => $$invalidate(2, $changePassword = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('SuccessView', slots, []);
		let { recovery = false } = $$props;
		let { status = true } = $$props;
		const writable_props = ['recovery', 'status'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SuccessView> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('recovery' in $$props) $$invalidate(0, recovery = $$props.recovery);
			if ('status' in $$props) $$invalidate(1, status = $$props.status);
		};

		$$self.$capture_state = () => ({
			changePassword,
			recovery,
			status,
			$changePassword
		});

		$$self.$inject_state = $$props => {
			if ('recovery' in $$props) $$invalidate(0, recovery = $$props.recovery);
			if ('status' in $$props) $$invalidate(1, status = $$props.status);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [recovery, status, $changePassword];
	}

	class SuccessView extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$y, create_fragment$y, safe_not_equal, { recovery: 0, status: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "SuccessView",
				options,
				id: create_fragment$y.name
			});
		}

		get recovery() {
			throw new Error("<SuccessView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set recovery(value) {
			throw new Error("<SuccessView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get status() {
			throw new Error("<SuccessView>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set status(value) {
			throw new Error("<SuccessView>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/credentials/ImportModal.svelte generated by Svelte v4.2.19 */
	const file$x = "src/lib/components/dashboard/credentials/ImportModal.svelte";

	function get_each_context$c(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[24] = list[i];
		child_ctx[26] = i;
		return child_ctx;
	}

	// (149:1) {:else}
	function create_else_block_1$9(ctx) {
		let div0;
		let span;
		let t1;
		let div1;
		let t2;
		let div2;
		let button;
		let mounted;
		let dispose;
		let each_value = ensure_array_like_dev(/*options*/ ctx[11]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
		}

		const block = {
			c: function create() {
				div0 = element("div");
				span = element("span");
				span.textContent = "Select Import Target";
				t1 = space();
				div1 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t2 = space();
				div2 = element("div");
				button = element("button");
				button.textContent = "Cancel";
				attr_dev(span, "class", "");
				add_location(span, file$x, 168, 3, 4407);
				attr_dev(div0, "class", "text-3xl my-4 flex justify-center");
				add_location(div0, file$x, 167, 2, 4356);
				attr_dev(div1, "class", "w-full h-[80%] gap-2 grid grid-cols-4 grid-rows-4 text-osvauld-chalkwhite text-xl");
				add_location(div1, file$x, 170, 2, 4461);
				attr_dev(button, "class", "border border-osvauld-iconblack rounded-lg px-3 py-1.5 hover:bg-osvauld-carolinablue hover:text-osvauld-ninjablack");
				add_location(button, file$x, 198, 3, 5402);
				attr_dev(div2, "class", "flex justify-end items-center pr-10");
				add_location(div2, file$x, 197, 2, 5349);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div0, anchor);
				append_dev(div0, span);
				insert_dev(target, t1, anchor);
				insert_dev(target, div1, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div1, null);
					}
				}

				insert_dev(target, t2, anchor);
				insert_dev(target, div2, anchor);
				append_dev(div2, button);

				if (!mounted) {
					dispose = listen_dev(button, "click", /*dispatchCancel*/ ctx[13], false, false, false, false);
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (dirty & /*handleSelectedOption, options, hoveredIndex, undefined, getImagePath*/ 72192) {
					each_value = ensure_array_like_dev(/*options*/ ctx[11]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$c(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$c(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div1, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div0);
					detach_dev(t1);
					detach_dev(div1);
					detach_dev(t2);
					detach_dev(div2);
				}

				destroy_each(each_blocks, detaching);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_1$9.name,
			type: "else",
			source: "(149:1) {:else}",
			ctx
		});

		return block;
	}

	// (121:28) 
	function create_if_block_5$3(ctx) {
		let div0;
		let span0;
		let t0;
		let t1;
		let t2;
		let input;
		let t3;
		let button0;
		let span1;
		let import_1;
		let t4;
		let p0;
		let t6;
		let p1;
		let t8;
		let div1;
		let button1;
		let current;
		let mounted;
		let dispose;
		import_1 = new Import({ props: { size: 128 }, $$inline: true });

		const block = {
			c: function create() {
				div0 = element("div");
				span0 = element("span");
				t0 = text("Import from ");
				t1 = text(/*selectedPlatform*/ ctx[0]);
				t2 = space();
				input = element("input");
				t3 = space();
				button0 = element("button");
				span1 = element("span");
				create_component(import_1.$$.fragment);
				t4 = space();
				p0 = element("p");
				p0.textContent = "Select your file here";
				t6 = space();
				p1 = element("p");
				p1.textContent = "File Types supported: CSV";
				t8 = space();
				div1 = element("div");
				button1 = element("button");
				button1.textContent = "Cancel";
				attr_dev(span0, "class", "");
				add_location(span0, file$x, 140, 3, 3545);
				attr_dev(div0, "class", "text-3xl my-4 flex justify-center");
				add_location(div0, file$x, 139, 2, 3494);
				attr_dev(input, "type", "file");
				attr_dev(input, "accept", ".csv");
				set_style(input, "display", "none");
				add_location(input, file$x, 142, 2, 3609);
				attr_dev(span1, "class", "cursor-pointer mb-10");
				add_location(span1, file$x, 154, 3, 3891);
				add_location(p0, file$x, 155, 3, 3960);
				attr_dev(p1, "class", "text-osvauld-sheffieldgrey text-lg mt-3");
				add_location(p1, file$x, 156, 3, 3992);
				attr_dev(button0, "class", "w-full h-[80%] flex flex-col justify-center items-center text-osvauld-chalkwhite text-xl");
				add_location(button0, file$x, 150, 2, 3743);
				attr_dev(button1, "class", "border border-osvauld-iconblack rounded-lg px-3 py-1.5 hover:bg-osvauld-carolinablue hover:text-osvauld-ninjablack");
				add_location(button1, file$x, 161, 3, 4149);
				attr_dev(div1, "class", "flex justify-end items-center pr-10");
				add_location(div1, file$x, 160, 2, 4096);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div0, anchor);
				append_dev(div0, span0);
				append_dev(span0, t0);
				append_dev(span0, t1);
				insert_dev(target, t2, anchor);
				insert_dev(target, input, anchor);
				/*input_binding*/ ctx[18](input);
				insert_dev(target, t3, anchor);
				insert_dev(target, button0, anchor);
				append_dev(button0, span1);
				mount_component(import_1, span1, null);
				append_dev(button0, t4);
				append_dev(button0, p0);
				append_dev(button0, t6);
				append_dev(button0, p1);
				insert_dev(target, t8, anchor);
				insert_dev(target, div1, anchor);
				append_dev(div1, button1);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(input, "change", /*handleFileSelect*/ ctx[15], false, false, false, false),
						listen_dev(button0, "click", /*triggerFileInput*/ ctx[14], false, false, false, false),
						listen_dev(button1, "click", /*dispatchCancel*/ ctx[13], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (!current || dirty & /*selectedPlatform*/ 1) set_data_dev(t1, /*selectedPlatform*/ ctx[0]);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(import_1.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(import_1.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div0);
					detach_dev(t2);
					detach_dev(input);
					detach_dev(t3);
					detach_dev(button0);
					detach_dev(t8);
					detach_dev(div1);
				}

				/*input_binding*/ ctx[18](null);
				destroy_component(import_1);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_5$3.name,
			type: "if",
			source: "(121:28) ",
			ctx
		});

		return block;
	}

	// (93:1) {#if loadingScreen}
	function create_if_block$p(ctx) {
		let div0;
		let span;
		let t0;
		let t1;
		let t2;
		let button;
		let close;
		let t3;
		let div1;
		let current_block_type_index;
		let if_block;
		let current;
		let mounted;
		let dispose;
		close = new ClosePanel({ props: { size: 32 }, $$inline: true });

		const if_block_creators = [
			create_if_block_1$j,
			create_if_block_2$d,
			create_if_block_3$8,
			create_if_block_4$4,
			create_else_block$h
		];

		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*processingSuccess*/ ctx[6]) return 0;
			if (/*processingScreen*/ ctx[5]) return 1;
			if (/*loadingSuccess*/ ctx[3]) return 2;
			if (/*loadingFail*/ ctx[4]) return 3;
			return 4;
		}

		current_block_type_index = select_block_type_1(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				div0 = element("div");
				span = element("span");
				t0 = text("Import from ");
				t1 = text(/*selectedPlatform*/ ctx[0]);
				t2 = space();
				button = element("button");
				create_component(close.$$.fragment);
				t3 = space();
				div1 = element("div");
				if_block.c();
				attr_dev(span, "class", "ml-auto");
				add_location(span, file$x, 112, 3, 2719);
				attr_dev(button, "class", "px-1.5 py-1.5 ml-auto");
				add_location(button, file$x, 113, 3, 2782);
				attr_dev(div0, "class", "text-3xl my-4 flex justify-center px-4");
				add_location(div0, file$x, 111, 2, 2663);
				attr_dev(div1, "class", "w-full h-[85%] flex flex-col justify-center items-center text-osvauld-chalkwhite text-xl");
				add_location(div1, file$x, 117, 2, 2900);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div0, anchor);
				append_dev(div0, span);
				append_dev(span, t0);
				append_dev(span, t1);
				append_dev(div0, t2);
				append_dev(div0, button);
				mount_component(close, button, null);
				insert_dev(target, t3, anchor);
				insert_dev(target, div1, anchor);
				if_blocks[current_block_type_index].m(div1, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", /*dispatchCancel*/ ctx[13], false, false, false, false);
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (!current || dirty & /*selectedPlatform*/ 1) set_data_dev(t1, /*selectedPlatform*/ ctx[0]);
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div1, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(close.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(close.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div0);
					detach_dev(t3);
					detach_dev(div1);
				}

				destroy_component(close);
				if_blocks[current_block_type_index].d();
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$p.name,
			type: "if",
			source: "(93:1) {#if loadingScreen}",
			ctx
		});

		return block;
	}

	// (172:5) {:else}
	function create_else_block_2$5(ctx) {
		let span;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = `${/*option*/ ctx[24]}`;
				attr_dev(span, "class", "text-osvauld-highlightwhite font-semibold");
				add_location(span, file$x, 190, 6, 5215);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
			},
			p: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_2$5.name,
			type: "else",
			source: "(172:5) {:else}",
			ctx
		});

		return block;
	}

	// (166:5) {#if hoveredIndex === index}
	function create_if_block_6$3(ctx) {
		let img;
		let img_src_value;

		const block = {
			c: function create() {
				img = element("img");
				if (!src_url_equal(img.src, img_src_value = /*getImagePath*/ ctx[12](/*option*/ ctx[24]))) attr_dev(img, "src", img_src_value);
				attr_dev(img, "class", "max-w-full max-h-full");
				attr_dev(img, "alt", /*option*/ ctx[24]);
				add_location(img, file$x, 184, 6, 5087);
			},
			m: function mount(target, anchor) {
				insert_dev(target, img, anchor);
			},
			p: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(img);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_6$3.name,
			type: "if",
			source: "(166:5) {#if hoveredIndex === index}",
			ctx
		});

		return block;
	}

	// (156:3) {#each options as option, index}
	function create_each_block$c(ctx) {
		let button;
		let t;
		let mounted;
		let dispose;

		function select_block_type_2(ctx, dirty) {
			if (/*hoveredIndex*/ ctx[9] === /*index*/ ctx[26]) return create_if_block_6$3;
			return create_else_block_2$5;
		}

		let current_block_type = select_block_type_2(ctx);
		let if_block = current_block_type(ctx);

		function click_handler() {
			return /*click_handler*/ ctx[19](/*option*/ ctx[24]);
		}

		function mouseenter_handler() {
			return /*mouseenter_handler*/ ctx[20](/*index*/ ctx[26]);
		}

		const block = {
			c: function create() {
				button = element("button");
				if_block.c();
				t = space();
				attr_dev(button, "class", "border border-osvauld-iconblack rounded-lg hover:bg-osvauld-carolinablue hover:text-osvauld-ninjablack transition-all duration-300 ease-in-out capitalize object-contain object-center overflow-hidden flex justify-center items-center p-2");
				add_location(button, file$x, 174, 4, 4603);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				if_block.m(button, null);
				append_dev(button, t);

				if (!mounted) {
					dispose = [
						listen_dev(button, "click", click_handler, false, false, false, false),
						listen_dev(button, "mouseenter", mouseenter_handler, false, false, false, false),
						listen_dev(button, "mouseleave", /*mouseleave_handler*/ ctx[21], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;

				if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block.d(1);
					if_block = current_block_type(ctx);

					if (if_block) {
						if_block.c();
						if_block.m(button, t);
					}
				}
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				if_block.d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$c.name,
			type: "each",
			source: "(156:3) {#each options as option, index}",
			ctx
		});

		return block;
	}

	// (117:3) {:else}
	function create_else_block$h(ctx) {
		let span;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = "Loading...";
				add_location(span, file$x, 135, 4, 3421);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$h.name,
			type: "else",
			source: "(117:3) {:else}",
			ctx
		});

		return block;
	}

	// (113:25) 
	function create_if_block_4$4(ctx) {
		let span;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = "Error parsing credentials";
				attr_dev(span, "class", "text-red-400 font-semibold text-2xl");
				add_location(span, file$x, 131, 4, 3312);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_4$4.name,
			type: "if",
			source: "(113:25) ",
			ctx
		});

		return block;
	}

	// (108:28) 
	function create_if_block_3$8(ctx) {
		let importtable;
		let current;

		importtable = new ImportTable({
				props: {
					dataFromParser: /*dataFromParser*/ ctx[8]
				},
				$$inline: true
			});

		importtable.$on("approved", /*handleSelectedCredentials*/ ctx[17]);

		const block = {
			c: function create() {
				create_component(importtable.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(importtable, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const importtable_changes = {};
				if (dirty & /*dataFromParser*/ 256) importtable_changes.dataFromParser = /*dataFromParser*/ ctx[8];
				importtable.$set(importtable_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(importtable.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(importtable.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(importtable, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$8.name,
			type: "if",
			source: "(108:28) ",
			ctx
		});

		return block;
	}

	// (105:30) 
	function create_if_block_2$d(ctx) {
		let importloader;
		let t;
		let importmessage;
		let current;
		importloader = new ImportLoader({ $$inline: true });
		importmessage = new ImportMessage({ $$inline: true });

		const block = {
			c: function create() {
				create_component(importloader.$$.fragment);
				t = space();
				create_component(importmessage.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(importloader, target, anchor);
				insert_dev(target, t, anchor);
				mount_component(importmessage, target, anchor);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(importloader.$$.fragment, local);
				transition_in(importmessage.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(importloader.$$.fragment, local);
				transition_out(importmessage.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
				}

				destroy_component(importloader, detaching);
				destroy_component(importmessage, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$d.name,
			type: "if",
			source: "(105:30) ",
			ctx
		});

		return block;
	}

	// (103:3) {#if processingSuccess}
	function create_if_block_1$j(ctx) {
		let successview;
		let current;

		successview = new SuccessView({
				props: { status: /*isImportSuccessful*/ ctx[7] },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(successview.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(successview, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const successview_changes = {};
				if (dirty & /*isImportSuccessful*/ 128) successview_changes.status = /*isImportSuccessful*/ ctx[7];
				successview.$set(successview_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(successview.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(successview.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(successview, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$j.name,
			type: "if",
			source: "(103:3) {#if processingSuccess}",
			ctx
		});

		return block;
	}

	function create_fragment$x(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let div_intro;
		let div_outro;
		let current;
		const if_block_creators = [create_if_block$p, create_if_block_5$3, create_else_block_1$9];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*loadingScreen*/ ctx[2]) return 0;
			if (/*isOptionSelected*/ ctx[1]) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				div = element("div");
				if_block.c();
				attr_dev(div, "class", "z-50 rounded-xl blur-none w-[64rem] max-w-[80vw] h-[42rem] shadow-xl translate-x-0 bg-osvauld-frameblack py-6 px-3 overflow-hidden");
				add_location(div, file$x, 105, 0, 2476);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (div_outro) div_outro.end(1);
						div_intro = create_in_transition(div, fly, {});
						div_intro.start();
					});
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				if (div_intro) div_intro.invalidate();

				if (local) {
					div_outro = create_out_transition(div, fly, {});
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if_blocks[current_block_type_index].d();
				if (detaching && div_outro) div_outro.end();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$x.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$x($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ImportModal', slots, []);
		let selectedPlatform;
		let isOptionSelected = false;
		let loadingScreen = false;
		let loadingSuccess = false;
		let loadingFail = false;
		let processingScreen = false;
		let processingSuccess = false;
		let isImportSuccessful = false;
		let dataFromParser;
		const dispatch = createEventDispatcher();

		const options = [
			"chrome",
			"firefox",
			"safari",
			"edge",
			"opera",
			"bitwarden",
			"protonpass",
			"dashlane",
			"nordpass",
			"keepass",
			"lastpass",
			"roboform",
			"1password"
		];

		const getImagePath = option => `/icons/import/${option}.png`;

		const dispatchCancel = () => {
			dispatch("close");
		};

		let hoveredIndex;
		let fileInput = null;

		function triggerFileInput() {
			if (fileInput) {
				fileInput.click();
			}
		}

		const handleFileSelect = async event => {
			const input = event.target;
			const file = input?.files?.[0];

			if (file) {
				$$invalidate(2, loadingScreen = true);
				let parserResponse = await parseCsvLogins(file, selectedPlatform);

				if (parserResponse.length === 0) {
					$$invalidate(4, loadingFail = true);

					setTimeout(
						() => {
							dispatch("close");
						},
						2000
					);
				} else {
					$$invalidate(8, dataFromParser = parserResponse);
					$$invalidate(3, loadingSuccess = true);
				}
			}
		};

		const handleKeyboardEvent = event => {
			if (event.key === "Escape") {
				dispatch("close");
			}
		};

		const handleSelectedOption = option => {
			$$invalidate(0, selectedPlatform = option.charAt(0).toUpperCase() + option.slice(1));
			$$invalidate(1, isOptionSelected = true);
		};

		const handleSelectedCredentials = async e => {
			$$invalidate(5, processingScreen = true);

			setTimeout(
				() => {
					$$invalidate(6, processingSuccess = isImportSuccessful);

					setTimeout(
						() => {
							dispatch("close");
						},
						1500
					);
				},
				4000
			);

			$$invalidate(7, isImportSuccessful = await approvedCredentialSubmit(e.detail));
		};

		onMount(async () => {
			window.addEventListener("keydown", handleKeyboardEvent);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ImportModal> was created with unknown prop '${key}'`);
		});

		function input_binding($$value) {
			binding_callbacks[$$value ? 'unshift' : 'push'](() => {
				fileInput = $$value;
				$$invalidate(10, fileInput);
			});
		}

		const click_handler = option => handleSelectedOption(option);
		const mouseenter_handler = index => $$invalidate(9, hoveredIndex = index);
		const mouseleave_handler = () => $$invalidate(9, hoveredIndex = undefined);

		$$self.$capture_state = () => ({
			fly,
			onMount,
			createEventDispatcher,
			Close: ClosePanel,
			parseCsvLogins,
			approvedCredentialSubmit,
			Import,
			ImportTable,
			ImportLoader,
			ImportMessage,
			SuccessView,
			selectedPlatform,
			isOptionSelected,
			loadingScreen,
			loadingSuccess,
			loadingFail,
			processingScreen,
			processingSuccess,
			isImportSuccessful,
			dataFromParser,
			dispatch,
			options,
			getImagePath,
			dispatchCancel,
			hoveredIndex,
			fileInput,
			triggerFileInput,
			handleFileSelect,
			handleKeyboardEvent,
			handleSelectedOption,
			handleSelectedCredentials
		});

		$$self.$inject_state = $$props => {
			if ('selectedPlatform' in $$props) $$invalidate(0, selectedPlatform = $$props.selectedPlatform);
			if ('isOptionSelected' in $$props) $$invalidate(1, isOptionSelected = $$props.isOptionSelected);
			if ('loadingScreen' in $$props) $$invalidate(2, loadingScreen = $$props.loadingScreen);
			if ('loadingSuccess' in $$props) $$invalidate(3, loadingSuccess = $$props.loadingSuccess);
			if ('loadingFail' in $$props) $$invalidate(4, loadingFail = $$props.loadingFail);
			if ('processingScreen' in $$props) $$invalidate(5, processingScreen = $$props.processingScreen);
			if ('processingSuccess' in $$props) $$invalidate(6, processingSuccess = $$props.processingSuccess);
			if ('isImportSuccessful' in $$props) $$invalidate(7, isImportSuccessful = $$props.isImportSuccessful);
			if ('dataFromParser' in $$props) $$invalidate(8, dataFromParser = $$props.dataFromParser);
			if ('hoveredIndex' in $$props) $$invalidate(9, hoveredIndex = $$props.hoveredIndex);
			if ('fileInput' in $$props) $$invalidate(10, fileInput = $$props.fileInput);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			selectedPlatform,
			isOptionSelected,
			loadingScreen,
			loadingSuccess,
			loadingFail,
			processingScreen,
			processingSuccess,
			isImportSuccessful,
			dataFromParser,
			hoveredIndex,
			fileInput,
			options,
			getImagePath,
			dispatchCancel,
			triggerFileInput,
			handleFileSelect,
			handleSelectedOption,
			handleSelectedCredentials,
			input_binding,
			click_handler,
			mouseenter_handler,
			mouseleave_handler
		];
	}

	class ImportModal extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ImportModal",
				options,
				id: create_fragment$x.name
			});
		}
	}

	/* src/lib/components/dashboard/credentials/CredentialList.svelte generated by Svelte v4.2.19 */

	const { console: console_1$1 } = globals;
	const file$w = "src/lib/components/dashboard/credentials/CredentialList.svelte";

	function get_each_context$b(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[56] = list[i];
		return child_ctx;
	}

	// (131:0) {#if $showCredentialDetailsDrawer}
	function create_if_block_13(ctx) {
		let button1;
		let button0;
		let credentialdetails;
		let current;
		let mounted;
		let dispose;

		credentialdetails = new CredentialDetails({
				props: {
					credential: /*selectedCard*/ ctx[4],
					sensitiveFields: /*sensitiveFields*/ ctx[5]
				},
				$$inline: true
			});

		credentialdetails.$on("close", /*withdrawDetailDrawer*/ ctx[24]);

		const block = {
			c: function create() {
				button1 = element("button");
				button0 = element("button");
				create_component(credentialdetails.$$.fragment);
				attr_dev(button0, "class", "p-6 rounded bg-transparent");
				add_location(button0, file$w, 167, 2, 4476);
				attr_dev(button1, "class", "fixed inset-0 flex items-center justify-center z-50 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px]");
				add_location(button1, file$w, 164, 1, 4305);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button1, anchor);
				append_dev(button1, button0);
				mount_component(credentialdetails, button0, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*click_handler*/ ctx[35]), false, false, true, false),
						listen_dev(button1, "click", /*withdrawDetailDrawer*/ ctx[24], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const credentialdetails_changes = {};
				if (dirty[0] & /*selectedCard*/ 16) credentialdetails_changes.credential = /*selectedCard*/ ctx[4];
				if (dirty[0] & /*sensitiveFields*/ 32) credentialdetails_changes.sensitiveFields = /*sensitiveFields*/ ctx[5];
				credentialdetails.$set(credentialdetails_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(credentialdetails.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(credentialdetails.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button1);
				}

				destroy_component(credentialdetails);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_13.name,
			type: "if",
			source: "(131:0) {#if $showCredentialDetailsDrawer}",
			ctx
		});

		return block;
	}

	// (235:1) {:else}
	function create_else_block$g(ctx) {
		let div;
		let placeholder;
		let current;
		placeholder = new Placeholder({ $$inline: true });

		const block = {
			c: function create() {
				div = element("div");
				create_component(placeholder.$$.fragment);
				attr_dev(div, "class", "w-full max-h-[100vh] min-h-[70vh] mt-20");
				add_location(div, file$w, 268, 2, 8426);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				mount_component(placeholder, div, null);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(placeholder.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(placeholder.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(placeholder);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$g.name,
			type: "else",
			source: "(235:1) {:else}",
			ctx
		});

		return block;
	}

	// (145:1) {#if $selectedFolder}
	function create_if_block_6$2(ctx) {
		let div2;
		let div0;
		let h1;
		let t0_value = /*$selectedFolder*/ ctx[18].name + "";
		let t0;
		let t1;
		let t2;
		let t3;
		let current_block_type_index;
		let if_block2;
		let t4;
		let div1;
		let t5;
		let button0;
		let span0;
		let t7;
		let downarrow;
		let t8;
		let button1;
		let span1;
		let t10;
		let add;
		let button1_class_value;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*$selectedFolder*/ ctx[18].accessType === "manager" && !/*privateFolder*/ ctx[12] && create_if_block_11(ctx);
		let if_block1 = /*minOneCredentialManager*/ ctx[15] && !/*privateFolder*/ ctx[12] && create_if_block_10$1(ctx);
		const if_block_creators = [create_if_block_8$1, create_if_block_9$1];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*areCardsSelected*/ ctx[6]) return 0;
			if (/*noCardsSelected*/ ctx[7]) return 1;
			return -1;
		}

		if (~(current_block_type_index = select_block_type_1(ctx))) {
			if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		let if_block3 = !/*privateFolder*/ ctx[12] && create_if_block_7$1(ctx);

		downarrow = new DownArrow({
				props: { type: 'common' },
				$$inline: true
			});

		add = new Add({
				props: {
					color: /*addCredentialHovered*/ ctx[11] ? '#0D0E13' : '#A3A4B5'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				div2 = element("div");
				div0 = element("div");
				h1 = element("h1");
				t0 = text(t0_value);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				if (if_block1) if_block1.c();
				t3 = space();
				if (if_block2) if_block2.c();
				t4 = space();
				div1 = element("div");
				if (if_block3) if_block3.c();
				t5 = space();
				button0 = element("button");
				span0 = element("span");
				span0.textContent = "Latest";
				t7 = space();
				create_component(downarrow.$$.fragment);
				t8 = space();
				button1 = element("button");
				span1 = element("span");
				span1.textContent = "Add New Credential";
				t10 = space();
				create_component(add.$$.fragment);
				attr_dev(h1, "class", "text-3xl p-4 font-normal whitespace-nowrap text-osvauld-sideListTextActive");
				add_location(h1, file$w, 180, 4, 4872);
				attr_dev(div0, "class", "max-w-[50%] min-w-[30%] flex items-center");
				add_location(div0, file$w, 179, 3, 4812);
				attr_dev(span0, "class", "mr-2 pl-2");
				add_location(span0, file$w, 251, 5, 7705);
				attr_dev(button0, "class", "border border-osvauld-iconblack text-osvauld-textPassive hidden justify-center items-center py-1.5 px-4 text-sm rounded-md ml-4");
				add_location(button0, file$w, 249, 4, 7550);
				attr_dev(span1, "class", "mr-2");
				add_location(span1, file$w, 262, 5, 8269);

				attr_dev(button1, "class", button1_class_value = "rounded-md py-1.5 px-4 mx-2 flex justify-center items-center whitespace-nowrap text-sm border text-osvauld-textActive border-osvauld-iconblack hover:text-osvauld-frameblack hover:bg-osvauld-carolinablue " + (/*$selectedFolder*/ ctx[18].accessType === 'manager'
				? 'visible'
				: 'hidden'));

				add_location(button1, file$w, 254, 4, 7798);
				attr_dev(div1, "class", "w-[40%] flex justify-end items-center");
				add_location(div1, file$w, 223, 3, 6548);
				attr_dev(div2, "class", "flex justify-between items-center px-4 py-2");
				add_location(div2, file$w, 178, 2, 4751);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div2, anchor);
				append_dev(div2, div0);
				append_dev(div0, h1);
				append_dev(h1, t0);
				append_dev(div0, t1);
				if (if_block0) if_block0.m(div0, null);
				append_dev(div0, t2);
				if (if_block1) if_block1.m(div0, null);
				append_dev(div0, t3);

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(div0, null);
				}

				append_dev(div2, t4);
				append_dev(div2, div1);
				if (if_block3) if_block3.m(div1, null);
				append_dev(div1, t5);
				append_dev(div1, button0);
				append_dev(button0, span0);
				append_dev(button0, t7);
				mount_component(downarrow, button0, null);
				append_dev(div1, t8);
				append_dev(div1, button1);
				append_dev(button1, span1);
				append_dev(button1, t10);
				mount_component(add, button1, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button1, "mouseenter", /*mouseenter_handler_2*/ ctx[40], false, false, false, false),
						listen_dev(button1, "mouseleave", /*mouseleave_handler_2*/ ctx[41], false, false, false, false),
						listen_dev(button1, "click", /*addCredentialManager*/ ctx[28], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if ((!current || dirty[0] & /*$selectedFolder*/ 262144) && t0_value !== (t0_value = /*$selectedFolder*/ ctx[18].name + "")) set_data_dev(t0, t0_value);

				if (/*$selectedFolder*/ ctx[18].accessType === "manager" && !/*privateFolder*/ ctx[12]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*$selectedFolder, privateFolder*/ 266240) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_11(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div0, t2);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*minOneCredentialManager*/ ctx[15] && !/*privateFolder*/ ctx[12]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty[0] & /*minOneCredentialManager, privateFolder*/ 36864) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_10$1(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div0, t3);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index !== previous_block_index) {
					if (if_block2) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block2 = if_blocks[current_block_type_index];

						if (!if_block2) {
							if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block2.c();
						}

						transition_in(if_block2, 1);
						if_block2.m(div0, null);
					} else {
						if_block2 = null;
					}
				}

				if (!/*privateFolder*/ ctx[12]) {
					if (if_block3) {
						if_block3.p(ctx, dirty);

						if (dirty[0] & /*privateFolder*/ 4096) {
							transition_in(if_block3, 1);
						}
					} else {
						if_block3 = create_if_block_7$1(ctx);
						if_block3.c();
						transition_in(if_block3, 1);
						if_block3.m(div1, t5);
					}
				} else if (if_block3) {
					group_outros();

					transition_out(if_block3, 1, 1, () => {
						if_block3 = null;
					});

					check_outros();
				}

				const add_changes = {};
				if (dirty[0] & /*addCredentialHovered*/ 2048) add_changes.color = /*addCredentialHovered*/ ctx[11] ? '#0D0E13' : '#A3A4B5';
				add.$set(add_changes);

				if (!current || dirty[0] & /*$selectedFolder*/ 262144 && button1_class_value !== (button1_class_value = "rounded-md py-1.5 px-4 mx-2 flex justify-center items-center whitespace-nowrap text-sm border text-osvauld-textActive border-osvauld-iconblack hover:text-osvauld-frameblack hover:bg-osvauld-carolinablue " + (/*$selectedFolder*/ ctx[18].accessType === 'manager'
				? 'visible'
				: 'hidden'))) {
					attr_dev(button1, "class", button1_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				transition_in(if_block3);
				transition_in(downarrow.$$.fragment, local);
				transition_in(add.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				transition_out(if_block3);
				transition_out(downarrow.$$.fragment, local);
				transition_out(add.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div2);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d();
				}

				if (if_block3) if_block3.d();
				destroy_component(downarrow);
				destroy_component(add);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_6$2.name,
			type: "if",
			source: "(145:1) {#if $selectedFolder}",
			ctx
		});

		return block;
	}

	// (153:4) {#if $selectedFolder.accessType === "manager" && !privateFolder}
	function create_if_block_11(ctx) {
		let button;
		let foldershare;
		let t;
		let current;
		let mounted;
		let dispose;

		foldershare = new FolderShare({
				props: {
					color: /*isShareHovered*/ ctx[9] ? '#F2F2F0' : '#85889C',
					size: 28
				},
				$$inline: true
			});

		let if_block = /*isShareHovered*/ ctx[9] && create_if_block_12(ctx);

		const block = {
			c: function create() {
				button = element("button");
				create_component(foldershare.$$.fragment);
				t = space();
				if (if_block) if_block.c();
				attr_dev(button, "class", "py-1.5 px-4 !text-lg text-osvauld-textActive flex justify-between items-center whitespace-nowrap text-sm mr-2 relative");
				add_location(button, file$w, 186, 5, 5140);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				mount_component(foldershare, button, null);
				append_dev(button, t);
				if (if_block) if_block.m(button, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "click", /*folderShareManager*/ ctx[26], false, false, false, false),
						listen_dev(button, "mouseenter", /*mouseenter_handler*/ ctx[36], false, false, false, false),
						listen_dev(button, "mouseleave", /*mouseleave_handler*/ ctx[37], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const foldershare_changes = {};
				if (dirty[0] & /*isShareHovered*/ 512) foldershare_changes.color = /*isShareHovered*/ ctx[9] ? '#F2F2F0' : '#85889C';
				foldershare.$set(foldershare_changes);

				if (/*isShareHovered*/ ctx[9]) {
					if (if_block) ; else {
						if_block = create_if_block_12(ctx);
						if_block.c();
						if_block.m(button, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(foldershare.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(foldershare.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(foldershare);
				if (if_block) if_block.d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_11.name,
			type: "if",
			source: "(153:4) {#if $selectedFolder.accessType === \\\"manager\\\" && !privateFolder}",
			ctx
		});

		return block;
	}

	// (162:6) {#if isShareHovered}
	function create_if_block_12(ctx) {
		let div;

		const block = {
			c: function create() {
				div = element("div");
				div.textContent = "Share Folder";
				attr_dev(div, "class", "tooltip svelte-cd3y3e");
				add_location(div, file$w, 195, 7, 5560);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_12.name,
			type: "if",
			source: "(162:6) {#if isShareHovered}",
			ctx
		});

		return block;
	}

	// (167:4) {#if minOneCredentialManager && !privateFolder}
	function create_if_block_10$1(ctx) {
		let button;
		let span;
		let t1;
		let share;
		let button_class_value;
		let current;
		let mounted;
		let dispose;

		share = new Share({
				props: {
					color: /*isShareCredActive*/ ctx[16] ? '#0D0E13' : '#A3A4B5',
					size: 16
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				button = element("button");
				span = element("span");
				span.textContent = "Share Credentials";
				t1 = space();
				create_component(share.$$.fragment);
				attr_dev(span, "class", "mr-1 text-sm");
				add_location(span, file$w, 205, 6, 6017);

				attr_dev(button, "class", button_class_value = "border border-osvauld-iconblack rounded-md py-1.5 px-4 !text-lg flex justify-between items-center whitespace-nowrap " + (/*isShareCredActive*/ ctx[16]
				? 'text-osvauld-frameblack bg-osvauld-carolinablue'
				: 'text-osvauld-textActive bg-osvauld-frameblack'));

				add_location(button, file$w, 200, 5, 5694);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				append_dev(button, span);
				append_dev(button, t1);
				mount_component(share, button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", /*credentialShareManager*/ ctx[27], false, false, false, false);
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const share_changes = {};
				if (dirty[0] & /*isShareCredActive*/ 65536) share_changes.color = /*isShareCredActive*/ ctx[16] ? '#0D0E13' : '#A3A4B5';
				share.$set(share_changes);

				if (!current || dirty[0] & /*isShareCredActive*/ 65536 && button_class_value !== (button_class_value = "border border-osvauld-iconblack rounded-md py-1.5 px-4 !text-lg flex justify-between items-center whitespace-nowrap " + (/*isShareCredActive*/ ctx[16]
				? 'text-osvauld-frameblack bg-osvauld-carolinablue'
				: 'text-osvauld-textActive bg-osvauld-frameblack'))) {
					attr_dev(button, "class", button_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(share.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(share.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(share);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_10$1.name,
			type: "if",
			source: "(167:4) {#if minOneCredentialManager && !privateFolder}",
			ctx
		});

		return block;
	}

	// (184:30) 
	function create_if_block_9$1(ctx) {
		let span;
		let span_intro;
		let span_outro;
		let current;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = "No cards are selected";
				attr_dev(span, "class", "text-red-400 whitespace-nowrap text-sm ml-2 inline-block");
				add_location(span, file$w, 217, 5, 6392);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (span_outro) span_outro.end(1);
						span_intro = create_in_transition(span, fly, {});
						span_intro.start();
					});
				}

				current = true;
			},
			o: function outro(local) {
				if (span_intro) span_intro.invalidate();

				if (local) {
					span_outro = create_out_transition(span, fly, {});
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				if (detaching && span_outro) span_outro.end();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_9$1.name,
			type: "if",
			source: "(184:30) ",
			ctx
		});

		return block;
	}

	// (179:4) {#if areCardsSelected}
	function create_if_block_8$1(ctx) {
		let span;
		let span_intro;
		let span_outro;
		let current;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = "Credentials are selected";
				attr_dev(span, "class", "text-red-400 whitespace-nowrap text-sm ml-2 inline-block");
				add_location(span, file$w, 212, 5, 6220);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (span_outro) span_outro.end(1);
						span_intro = create_in_transition(span, fly, {});
						span_intro.start();
					});
				}

				current = true;
			},
			o: function outro(local) {
				if (span_intro) span_intro.invalidate();

				if (local) {
					span_outro = create_out_transition(span, fly, {});
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				if (detaching && span_outro) span_outro.end();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_8$1.name,
			type: "if",
			source: "(179:4) {#if areCardsSelected}",
			ctx
		});

		return block;
	}

	// (192:4) {#if !privateFolder}
	function create_if_block_7$1(ctx) {
		let button;
		let eyescan;
		let t0;
		let span;
		let t1;
		let span_class_value;
		let button_class_value;
		let current;
		let mounted;
		let dispose;

		eyescan = new EyeScan({
				props: {
					color: /*$accessListSelected*/ ctx[19]
					? '#89B4FA'
					: /*accesslistHovered*/ ctx[10] ? '#F2F2F0' : '#85889C'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				button = element("button");
				create_component(eyescan.$$.fragment);
				t0 = space();
				span = element("span");
				t1 = text("Access List");

				attr_dev(span, "class", span_class_value = "ml-2 whitespace-nowrap " + (/*$accessListSelected*/ ctx[19]
				? 'text-osvauld-carolinablue'
				: /*accesslistHovered*/ ctx[10]
					? 'text-osvauld-sideListTextActive'
					: 'text-osvauld-fieldText') + "");

				add_location(span, file$w, 241, 6, 7288);

				attr_dev(button, "class", button_class_value = "hover:bg-osvauld-modalFieldActive " + (/*$accessListSelected*/ ctx[19]
				? 'bg-osvauld-modalFieldActive text-osvauld-carolinablue'
				: 'bg-osvauld-frameblack text-osvauld-fieldText') + " rounded-md flex justify-around items-center px-4 py-1.5 text-sm " + (/*$selectedFolder*/ ctx[18].accessType === 'none'
				? 'hidden'
				: 'visible'));

				add_location(button, file$w, 225, 5, 6630);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				mount_component(eyescan, button, null);
				append_dev(button, t0);
				append_dev(button, span);
				append_dev(span, t1);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "click", /*handleAccessListSelection*/ ctx[29], false, false, false, false),
						listen_dev(button, "mouseenter", /*mouseenter_handler_1*/ ctx[38], false, false, false, false),
						listen_dev(button, "mouseleave", /*mouseleave_handler_1*/ ctx[39], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const eyescan_changes = {};

				if (dirty[0] & /*$accessListSelected, accesslistHovered*/ 525312) eyescan_changes.color = /*$accessListSelected*/ ctx[19]
				? '#89B4FA'
				: /*accesslistHovered*/ ctx[10] ? '#F2F2F0' : '#85889C';

				eyescan.$set(eyescan_changes);

				if (!current || dirty[0] & /*$accessListSelected, accesslistHovered*/ 525312 && span_class_value !== (span_class_value = "ml-2 whitespace-nowrap " + (/*$accessListSelected*/ ctx[19]
				? 'text-osvauld-carolinablue'
				: /*accesslistHovered*/ ctx[10]
					? 'text-osvauld-sideListTextActive'
					: 'text-osvauld-fieldText') + "")) {
					attr_dev(span, "class", span_class_value);
				}

				if (!current || dirty[0] & /*$accessListSelected, $selectedFolder*/ 786432 && button_class_value !== (button_class_value = "hover:bg-osvauld-modalFieldActive " + (/*$accessListSelected*/ ctx[19]
				? 'bg-osvauld-modalFieldActive text-osvauld-carolinablue'
				: 'bg-osvauld-frameblack text-osvauld-fieldText') + " rounded-md flex justify-around items-center px-4 py-1.5 text-sm " + (/*$selectedFolder*/ ctx[18].accessType === 'none'
				? 'hidden'
				: 'visible'))) {
					attr_dev(button, "class", button_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(eyescan.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(eyescan.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(eyescan);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_7$1.name,
			type: "if",
			source: "(192:4) {#if !privateFolder}",
			ctx
		});

		return block;
	}

	// (240:1) {#if showCreateCredentialModal}
	function create_if_block_5$2(ctx) {
		let button1;
		let button0;
		let credentialeditor;
		let current;
		let mounted;
		let dispose;
		credentialeditor = new CredentialEditor({ $$inline: true });
		credentialeditor.$on("close", /*close_handler*/ ctx[42]);

		const block = {
			c: function create() {
				button1 = element("button");
				button0 = element("button");
				create_component(credentialeditor.$$.fragment);
				attr_dev(button0, "class", "p-6 rounded bg-transparent");
				add_location(button0, file$w, 276, 3, 8736);
				attr_dev(button1, "class", "fixed inset-0 flex items-center justify-center z-50 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px]");
				add_location(button1, file$w, 273, 2, 8550);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button1, anchor);
				append_dev(button1, button0);
				mount_component(credentialeditor, button0, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*click_handler_1*/ ctx[34]), false, false, true, false),
						listen_dev(button1, "click", /*click_handler_4*/ ctx[43], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(credentialeditor.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(credentialeditor.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button1);
				}

				destroy_component(credentialeditor);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_5$2.name,
			type: "if",
			source: "(240:1) {#if showCreateCredentialModal}",
			ctx
		});

		return block;
	}

	// (250:1) {#if $showFolderShareDrawer}
	function create_if_block_4$3(ctx) {
		let button1;
		let button0;
		let sharefoldermodal;
		let current;
		let mounted;
		let dispose;

		sharefoldermodal = new ShareFolderModal({
				props: { users: /*users*/ ctx[2] },
				$$inline: true
			});

		sharefoldermodal.$on("close", /*close_handler_1*/ ctx[44]);

		const block = {
			c: function create() {
				button1 = element("button");
				button0 = element("button");
				create_component(sharefoldermodal.$$.fragment);
				attr_dev(button0, "class", "p-6 rounded shadow-lg");
				add_location(button0, file$w, 286, 3, 9146);
				attr_dev(button1, "class", "fixed inset-0 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px] flex items-center justify-center z-50");
				add_location(button1, file$w, 283, 2, 8954);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button1, anchor);
				append_dev(button1, button0);
				mount_component(sharefoldermodal, button0, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*click_handler_2*/ ctx[33]), false, false, true, false),
						listen_dev(button1, "click", /*click_handler_5*/ ctx[45], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const sharefoldermodal_changes = {};
				if (dirty[0] & /*users*/ 4) sharefoldermodal_changes.users = /*users*/ ctx[2];
				sharefoldermodal.$set(sharefoldermodal_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(sharefoldermodal.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(sharefoldermodal.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button1);
				}

				destroy_component(sharefoldermodal);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_4$3.name,
			type: "if",
			source: "(250:1) {#if $showFolderShareDrawer}",
			ctx
		});

		return block;
	}

	// (261:1) {#if $showCredentialShareDrawer}
	function create_if_block_3$7(ctx) {
		let button1;
		let button0;
		let sharecredentialmodal;
		let current;
		let mounted;
		let dispose;

		sharecredentialmodal = new ShareCredentialModal({
				props: {
					users: /*users*/ ctx[2],
					credentials: /*checkedCards*/ ctx[0],
					groups: /*allGroups*/ ctx[3]
				},
				$$inline: true
			});

		sharecredentialmodal.$on("close", /*close_handler_2*/ ctx[46]);

		const block = {
			c: function create() {
				button1 = element("button");
				button0 = element("button");
				create_component(sharecredentialmodal.$$.fragment);
				attr_dev(button0, "class", "p-6 rounded shadow-lg");
				add_location(button0, file$w, 297, 3, 9569);
				attr_dev(button1, "class", "fixed inset-0 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px] flex items-center justify-center z-50");
				add_location(button1, file$w, 294, 2, 9373);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button1, anchor);
				append_dev(button1, button0);
				mount_component(sharecredentialmodal, button0, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*click_handler_3*/ ctx[32]), false, false, true, false),
						listen_dev(button1, "click", /*click_handler_6*/ ctx[47], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const sharecredentialmodal_changes = {};
				if (dirty[0] & /*users*/ 4) sharecredentialmodal_changes.users = /*users*/ ctx[2];
				if (dirty[0] & /*checkedCards*/ 1) sharecredentialmodal_changes.credentials = /*checkedCards*/ ctx[0];
				if (dirty[0] & /*allGroups*/ 8) sharecredentialmodal_changes.groups = /*allGroups*/ ctx[3];
				sharecredentialmodal.$set(sharecredentialmodal_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(sharecredentialmodal.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(sharecredentialmodal.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button1);
				}

				destroy_component(sharecredentialmodal);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$7.name,
			type: "if",
			source: "(261:1) {#if $showCredentialShareDrawer}",
			ctx
		});

		return block;
	}

	// (274:1) {#if importSelected}
	function create_if_block_2$c(ctx) {
		let div;
		let importmodal;
		let current;
		importmodal = new ImportModal({ $$inline: true });
		importmodal.$on("close", /*closeImportModal*/ ctx[30]);

		const block = {
			c: function create() {
				div = element("div");
				create_component(importmodal.$$.fragment);
				attr_dev(div, "class", "fixed inset-0 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px] flex items-center justify-center z-50");
				add_location(div, file$w, 307, 2, 9852);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				mount_component(importmodal, div, null);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(importmodal.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(importmodal.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(importmodal);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$c.name,
			type: "if",
			source: "(274:1) {#if importSelected}",
			ctx
		});

		return block;
	}

	// (280:1) {#if sortedCredentials.length !== 0}
	function create_if_block_1$i(ctx) {
		let div;
		let current;
		let each_value = ensure_array_like_dev(/*sortedCredentials*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(div, "class", "flex flex-wrap pt-3 pb-7 px-7 gap-3.5 w-full max-h-[80vh] !overflow-y-scroll scrollbar-thin box-border");
				add_location(div, file$w, 313, 2, 10088);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*privateFolder, sortedCredentials, checkedCards, handleCheck, onSelectingCard, handleActionModalCall*/ 46141443) {
					each_value = ensure_array_like_dev(/*sortedCredentials*/ ctx[1]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$b(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$b(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$i.name,
			type: "if",
			source: "(280:1) {#if sortedCredentials.length !== 0}",
			ctx
		});

		return block;
	}

	// (283:3) {#each sortedCredentials as credential}
	function create_each_block$b(ctx) {
		let credentialcard;
		let current;

		function func(...args) {
			return /*func*/ ctx[48](/*credential*/ ctx[56], ...args);
		}

		function check_handler(...args) {
			return /*check_handler*/ ctx[49](/*credential*/ ctx[56], ...args);
		}

		function select_handler(...args) {
			return /*select_handler*/ ctx[50](/*credential*/ ctx[56], ...args);
		}

		function action_handler(...args) {
			return /*action_handler*/ ctx[51](/*credential*/ ctx[56], ...args);
		}

		credentialcard = new CredentialCard({
				props: {
					privateFolder: /*privateFolder*/ ctx[12],
					credential: /*credential*/ ctx[56],
					checked: /*checkedCards*/ ctx[0].some(func)
				},
				$$inline: true
			});

		credentialcard.$on("check", check_handler);
		credentialcard.$on("select", select_handler);
		credentialcard.$on("action", action_handler);

		const block = {
			c: function create() {
				create_component(credentialcard.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(credentialcard, target, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const credentialcard_changes = {};
				if (dirty[0] & /*privateFolder*/ 4096) credentialcard_changes.privateFolder = /*privateFolder*/ ctx[12];
				if (dirty[0] & /*sortedCredentials*/ 2) credentialcard_changes.credential = /*credential*/ ctx[56];
				if (dirty[0] & /*checkedCards, sortedCredentials*/ 3) credentialcard_changes.checked = /*checkedCards*/ ctx[0].some(func);
				credentialcard.$set(credentialcard_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(credentialcard.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(credentialcard.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(credentialcard, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$b.name,
			type: "each",
			source: "(283:3) {#each sortedCredentials as credential}",
			ctx
		});

		return block;
	}

	// (296:1) {#if $selectedFolder && $selectedFolder.accessType === "manager"}
	function create_if_block$o(ctx) {
		let button;
		let import_1;
		let t0;
		let span;
		let current;
		let mounted;
		let dispose;

		import_1 = new Import({
				props: {
					color: /*importHovered*/ ctx[13] ? '#0D0E13' : '#6E7681'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				button = element("button");
				create_component(import_1.$$.fragment);
				t0 = space();
				span = element("span");
				span.textContent = "Import";
				attr_dev(span, "class", "ml-2");
				add_location(span, file$w, 336, 3, 11185);
				attr_dev(button, "class", "text-2xl absolute bottom-10 right-14 bg-osvauld-frameblack border border-osvauld-iconblack text-osvauld-sheffieldgrey hover:bg-osvauld-carolinablue hover:text-osvauld-ninjablack rounded-lg py-2 px-3.5 flex justify-center items-center");
				attr_dev(button, "type", "button");
				add_location(button, file$w, 329, 2, 10702);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				mount_component(import_1, button, null);
				append_dev(button, t0);
				append_dev(button, span);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "mouseenter", /*mouseenter_handler_3*/ ctx[52], false, false, false, false),
						listen_dev(button, "mouseleave", /*mouseleave_handler_3*/ ctx[53], false, false, false, false),
						listen_dev(button, "click", /*click_handler_7*/ ctx[54], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const import_1_changes = {};
				if (dirty[0] & /*importHovered*/ 8192) import_1_changes.color = /*importHovered*/ ctx[13] ? '#0D0E13' : '#6E7681';
				import_1.$set(import_1_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(import_1.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(import_1.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(import_1);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$o.name,
			type: "if",
			source: "(296:1) {#if $selectedFolder && $selectedFolder.accessType === \\\"manager\\\"}",
			ctx
		});

		return block;
	}

	function create_fragment$w(ctx) {
		let t0;
		let div;
		let current_block_type_index;
		let if_block1;
		let t1;
		let t2;
		let t3;
		let t4;
		let t5;
		let t6;
		let current;
		let if_block0 = /*$showCredentialDetailsDrawer*/ ctx[17] && create_if_block_13(ctx);
		const if_block_creators = [create_if_block_6$2, create_else_block$g];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*$selectedFolder*/ ctx[18]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		let if_block2 = /*showCreateCredentialModal*/ ctx[8] && create_if_block_5$2(ctx);
		let if_block3 = /*$showFolderShareDrawer*/ ctx[20] && create_if_block_4$3(ctx);
		let if_block4 = /*$showCredentialShareDrawer*/ ctx[21] && create_if_block_3$7(ctx);
		let if_block5 = /*importSelected*/ ctx[14] && create_if_block_2$c(ctx);
		let if_block6 = /*sortedCredentials*/ ctx[1].length !== 0 && create_if_block_1$i(ctx);
		let if_block7 = /*$selectedFolder*/ ctx[18] && /*$selectedFolder*/ ctx[18].accessType === "manager" && create_if_block$o(ctx);

		const block = {
			c: function create() {
				if (if_block0) if_block0.c();
				t0 = space();
				div = element("div");
				if_block1.c();
				t1 = space();
				if (if_block2) if_block2.c();
				t2 = space();
				if (if_block3) if_block3.c();
				t3 = space();
				if (if_block4) if_block4.c();
				t4 = space();
				if (if_block5) if_block5.c();
				t5 = space();
				if (if_block6) if_block6.c();
				t6 = space();
				if (if_block7) if_block7.c();
				attr_dev(div, "class", "w-full min-h-[80vh]");
				add_location(div, file$w, 176, 0, 4692);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (if_block0) if_block0.m(target, anchor);
				insert_dev(target, t0, anchor);
				insert_dev(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				append_dev(div, t1);
				if (if_block2) if_block2.m(div, null);
				append_dev(div, t2);
				if (if_block3) if_block3.m(div, null);
				append_dev(div, t3);
				if (if_block4) if_block4.m(div, null);
				append_dev(div, t4);
				if (if_block5) if_block5.m(div, null);
				append_dev(div, t5);
				if (if_block6) if_block6.m(div, null);
				append_dev(div, t6);
				if (if_block7) if_block7.m(div, null);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (/*$showCredentialDetailsDrawer*/ ctx[17]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty[0] & /*$showCredentialDetailsDrawer*/ 131072) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_13(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t0.parentNode, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div, t1);
				}

				if (/*showCreateCredentialModal*/ ctx[8]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty[0] & /*showCreateCredentialModal*/ 256) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_5$2(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(div, t2);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (/*$showFolderShareDrawer*/ ctx[20]) {
					if (if_block3) {
						if_block3.p(ctx, dirty);

						if (dirty[0] & /*$showFolderShareDrawer*/ 1048576) {
							transition_in(if_block3, 1);
						}
					} else {
						if_block3 = create_if_block_4$3(ctx);
						if_block3.c();
						transition_in(if_block3, 1);
						if_block3.m(div, t3);
					}
				} else if (if_block3) {
					group_outros();

					transition_out(if_block3, 1, 1, () => {
						if_block3 = null;
					});

					check_outros();
				}

				if (/*$showCredentialShareDrawer*/ ctx[21]) {
					if (if_block4) {
						if_block4.p(ctx, dirty);

						if (dirty[0] & /*$showCredentialShareDrawer*/ 2097152) {
							transition_in(if_block4, 1);
						}
					} else {
						if_block4 = create_if_block_3$7(ctx);
						if_block4.c();
						transition_in(if_block4, 1);
						if_block4.m(div, t4);
					}
				} else if (if_block4) {
					group_outros();

					transition_out(if_block4, 1, 1, () => {
						if_block4 = null;
					});

					check_outros();
				}

				if (/*importSelected*/ ctx[14]) {
					if (if_block5) {
						if_block5.p(ctx, dirty);

						if (dirty[0] & /*importSelected*/ 16384) {
							transition_in(if_block5, 1);
						}
					} else {
						if_block5 = create_if_block_2$c(ctx);
						if_block5.c();
						transition_in(if_block5, 1);
						if_block5.m(div, t5);
					}
				} else if (if_block5) {
					group_outros();

					transition_out(if_block5, 1, 1, () => {
						if_block5 = null;
					});

					check_outros();
				}

				if (/*sortedCredentials*/ ctx[1].length !== 0) {
					if (if_block6) {
						if_block6.p(ctx, dirty);

						if (dirty[0] & /*sortedCredentials*/ 2) {
							transition_in(if_block6, 1);
						}
					} else {
						if_block6 = create_if_block_1$i(ctx);
						if_block6.c();
						transition_in(if_block6, 1);
						if_block6.m(div, t6);
					}
				} else if (if_block6) {
					group_outros();

					transition_out(if_block6, 1, 1, () => {
						if_block6 = null;
					});

					check_outros();
				}

				if (/*$selectedFolder*/ ctx[18] && /*$selectedFolder*/ ctx[18].accessType === "manager") {
					if (if_block7) {
						if_block7.p(ctx, dirty);

						if (dirty[0] & /*$selectedFolder*/ 262144) {
							transition_in(if_block7, 1);
						}
					} else {
						if_block7 = create_if_block$o(ctx);
						if_block7.c();
						transition_in(if_block7, 1);
						if_block7.m(div, null);
					}
				} else if (if_block7) {
					group_outros();

					transition_out(if_block7, 1, 1, () => {
						if_block7 = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				transition_in(if_block3);
				transition_in(if_block4);
				transition_in(if_block5);
				transition_in(if_block6);
				transition_in(if_block7);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				transition_out(if_block3);
				transition_out(if_block4);
				transition_out(if_block5);
				transition_out(if_block6);
				transition_out(if_block7);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t0);
					detach_dev(div);
				}

				if (if_block0) if_block0.d(detaching);
				if_blocks[current_block_type_index].d();
				if (if_block2) if_block2.d();
				if (if_block3) if_block3.d();
				if (if_block4) if_block4.d();
				if (if_block5) if_block5.d();
				if (if_block6) if_block6.d();
				if (if_block7) if_block7.d();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$w.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$w($$self, $$props, $$invalidate) {
		let isShareCredActive;
		let minOneCredentialManager;
		let $credentialStore;
		let $showCredentialDetailsDrawer;
		let $selectedFolder;
		let $accessListSelected;
		let $showFolderShareDrawer;
		let $showCredentialShareDrawer;
		validate_store(credentialStore, 'credentialStore');
		component_subscribe($$self, credentialStore, $$value => $$invalidate(31, $credentialStore = $$value));
		validate_store(showCredentialDetailsDrawer, 'showCredentialDetailsDrawer');
		component_subscribe($$self, showCredentialDetailsDrawer, $$value => $$invalidate(17, $showCredentialDetailsDrawer = $$value));
		validate_store(selectedFolder, 'selectedFolder');
		component_subscribe($$self, selectedFolder, $$value => $$invalidate(18, $selectedFolder = $$value));
		validate_store(accessListSelected, 'accessListSelected');
		component_subscribe($$self, accessListSelected, $$value => $$invalidate(19, $accessListSelected = $$value));
		validate_store(showFolderShareDrawer, 'showFolderShareDrawer');
		component_subscribe($$self, showFolderShareDrawer, $$value => $$invalidate(20, $showFolderShareDrawer = $$value));
		validate_store(showCredentialShareDrawer, 'showCredentialShareDrawer');
		component_subscribe($$self, showCredentialShareDrawer, $$value => $$invalidate(21, $showCredentialShareDrawer = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('CredentialList', slots, []);
		let checkedCards = [];
		let users = [];
		let allGroups = [];
		let selectedCard;
		let sensitiveFields = [];
		let areCardsSelected = false;
		let noCardsSelected = false;
		let showCreateCredentialModal = false;
		let isShareHovered = false;
		let accesslistHovered = false;
		let addCredentialHovered = false;
		let privateFolder = false;
		let importHovered = false;
		let importSelected = false;
		let sortedCredentials = [];

		const handleCheck = (isChecked, card) => {
			if (isChecked) {
				$$invalidate(0, checkedCards = [...checkedCards, card]);
			} else {
				$$invalidate(0, checkedCards = checkedCards.filter(c => c.credentialId !== card.credentialId));
			}
		};

		const handleActionModalCall = (triggerAction, card) => {
			// When the action modal is called from a credential, it clears all other checked credentials and make that credential checked.
			$$invalidate(0, checkedCards = [card]);
		};

		const subscribe = selectedFolder.subscribe(async folder => {
			if (folder === undefined) {
				return;
			}

			if (folder === null) {
				return;
			}

			if (folder.type === "private") {
				$$invalidate(12, privateFolder = true);
			} else {
				$$invalidate(12, privateFolder = false);
			}

			selectedCredential.set(null);
			await setCredentialStore();
			let [allUsersResponse, allGroupResponse] = await Promise.all([fetchSignedUpUsers(), fetchAllUserGroups()]);
			$$invalidate(3, allGroups = allGroupResponse.data);
			$$invalidate(2, users = allUsersResponse.data);
			$$invalidate(0, checkedCards = []);
		});

		const withdrawDetailDrawer = () => {
			showCredentialDetailsDrawer.set(false);
		};

		const onSelectingCard = (sensitiveFieldsfromCard, credential) => {
			$$invalidate(5, sensitiveFields = [...sensitiveFieldsfromCard]);
			$$invalidate(4, selectedCard = credential);
			showCredentialDetailsDrawer.set(true);
		};

		const folderShareManager = async () => {
			$$invalidate(6, areCardsSelected = checkedCards.length !== 0);

			setTimeout(
				() => {
					$$invalidate(6, areCardsSelected = false);
				},
				1000
			);

			!areCardsSelected && showFolderShareDrawer.set(true);
		};

		const credentialShareManager = async () => {
			$$invalidate(7, noCardsSelected = checkedCards.length === 0);

			setTimeout(
				() => {
					$$invalidate(7, noCardsSelected = false);
				},
				1000
			);

			!noCardsSelected && showCredentialShareDrawer.set(true);
		};

		const addCredentialManager = () => {
			$$invalidate(8, showCreateCredentialModal = true);
			$$invalidate(0, checkedCards = []);
		};

		const handleAccessListSelection = e => {
			buttonRef.set(e.currentTarget);
			accessListSelected.set(true);
		};

		const closeImportModal = async () => {
			$$invalidate(14, importSelected = false);
			await setCredentialStore();
		};

		onDestroy(() => {
			subscribe();
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<CredentialList> was created with unknown prop '${key}'`);
		});

		function click_handler_3(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler_2(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		const mouseenter_handler = () => $$invalidate(9, isShareHovered = true);
		const mouseleave_handler = () => $$invalidate(9, isShareHovered = false);
		const mouseenter_handler_1 = () => $$invalidate(10, accesslistHovered = true);
		const mouseleave_handler_1 = () => $$invalidate(10, accesslistHovered = false);
		const mouseenter_handler_2 = () => $$invalidate(11, addCredentialHovered = true);
		const mouseleave_handler_2 = () => $$invalidate(11, addCredentialHovered = false);
		const close_handler = () => $$invalidate(8, showCreateCredentialModal = false);
		const click_handler_4 = () => !showCreateCredentialModal;
		const close_handler_1 = () => showFolderShareDrawer.set(false);
		const click_handler_5 = () => showFolderShareDrawer.set(false);
		const close_handler_2 = () => showCredentialShareDrawer.set(false);
		const click_handler_6 = () => showCredentialShareDrawer.set(false);
		const func = (credential, c) => c.credentialId === credential.credentialId;
		const check_handler = (credential, e) => handleCheck(e.detail, credential);
		const select_handler = (credential, e) => onSelectingCard(e.detail, credential);
		const action_handler = (credential, e) => handleActionModalCall(e.detail, credential);
		const mouseenter_handler_3 = () => $$invalidate(13, importHovered = true);
		const mouseleave_handler_3 = () => $$invalidate(13, importHovered = false);
		const click_handler_7 = () => $$invalidate(14, importSelected = true);

		$$self.$capture_state = () => ({
			fly,
			CredentialEditor,
			ShareFolderModal,
			ShareCredentialModal,
			CredentialCard,
			CredentialDetails,
			Share,
			Add,
			EyeScan,
			FolderShare,
			Import,
			fetchSignedUpUsers,
			fetchAllUserGroups,
			credentialStore,
			showFolderShareDrawer,
			showCredentialShareDrawer,
			selectedFolder,
			showCredentialDetailsDrawer,
			selectedCredential,
			onDestroy,
			DownArrow,
			Placeholder,
			accessListSelected,
			buttonRef,
			setCredentialStore,
			ImportModal,
			checkedCards,
			users,
			allGroups,
			selectedCard,
			sensitiveFields,
			areCardsSelected,
			noCardsSelected,
			showCreateCredentialModal,
			isShareHovered,
			accesslistHovered,
			addCredentialHovered,
			privateFolder,
			importHovered,
			importSelected,
			sortedCredentials,
			handleCheck,
			handleActionModalCall,
			subscribe,
			withdrawDetailDrawer,
			onSelectingCard,
			folderShareManager,
			credentialShareManager,
			addCredentialManager,
			handleAccessListSelection,
			closeImportModal,
			minOneCredentialManager,
			isShareCredActive,
			$credentialStore,
			$showCredentialDetailsDrawer,
			$selectedFolder,
			$accessListSelected,
			$showFolderShareDrawer,
			$showCredentialShareDrawer
		});

		$$self.$inject_state = $$props => {
			if ('checkedCards' in $$props) $$invalidate(0, checkedCards = $$props.checkedCards);
			if ('users' in $$props) $$invalidate(2, users = $$props.users);
			if ('allGroups' in $$props) $$invalidate(3, allGroups = $$props.allGroups);
			if ('selectedCard' in $$props) $$invalidate(4, selectedCard = $$props.selectedCard);
			if ('sensitiveFields' in $$props) $$invalidate(5, sensitiveFields = $$props.sensitiveFields);
			if ('areCardsSelected' in $$props) $$invalidate(6, areCardsSelected = $$props.areCardsSelected);
			if ('noCardsSelected' in $$props) $$invalidate(7, noCardsSelected = $$props.noCardsSelected);
			if ('showCreateCredentialModal' in $$props) $$invalidate(8, showCreateCredentialModal = $$props.showCreateCredentialModal);
			if ('isShareHovered' in $$props) $$invalidate(9, isShareHovered = $$props.isShareHovered);
			if ('accesslistHovered' in $$props) $$invalidate(10, accesslistHovered = $$props.accesslistHovered);
			if ('addCredentialHovered' in $$props) $$invalidate(11, addCredentialHovered = $$props.addCredentialHovered);
			if ('privateFolder' in $$props) $$invalidate(12, privateFolder = $$props.privateFolder);
			if ('importHovered' in $$props) $$invalidate(13, importHovered = $$props.importHovered);
			if ('importSelected' in $$props) $$invalidate(14, importSelected = $$props.importSelected);
			if ('sortedCredentials' in $$props) $$invalidate(1, sortedCredentials = $$props.sortedCredentials);
			if ('minOneCredentialManager' in $$props) $$invalidate(15, minOneCredentialManager = $$props.minOneCredentialManager);
			if ('isShareCredActive' in $$props) $$invalidate(16, isShareCredActive = $$props.isShareCredActive);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty[1] & /*$credentialStore*/ 1) {
				{
					if (Array.isArray($credentialStore)) {
						$$invalidate(1, sortedCredentials = [...$credentialStore].sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()));
					} else {
						console.warn("credentialStore is not an array:", $credentialStore);
						$$invalidate(1, sortedCredentials = []);
					}
				}
			}

			if ($$self.$$.dirty[0] & /*checkedCards*/ 1) {
				$$invalidate(16, isShareCredActive = checkedCards.length !== 0);
			}

			if ($$self.$$.dirty[0] & /*sortedCredentials*/ 2) {
				$$invalidate(15, minOneCredentialManager = sortedCredentials.some(credential => credential.accessType === "manager"));
			}
		};

		return [
			checkedCards,
			sortedCredentials,
			users,
			allGroups,
			selectedCard,
			sensitiveFields,
			areCardsSelected,
			noCardsSelected,
			showCreateCredentialModal,
			isShareHovered,
			accesslistHovered,
			addCredentialHovered,
			privateFolder,
			importHovered,
			importSelected,
			minOneCredentialManager,
			isShareCredActive,
			$showCredentialDetailsDrawer,
			$selectedFolder,
			$accessListSelected,
			$showFolderShareDrawer,
			$showCredentialShareDrawer,
			handleCheck,
			handleActionModalCall,
			withdrawDetailDrawer,
			onSelectingCard,
			folderShareManager,
			credentialShareManager,
			addCredentialManager,
			handleAccessListSelection,
			closeImportModal,
			$credentialStore,
			click_handler_3,
			click_handler_2,
			click_handler_1,
			click_handler,
			mouseenter_handler,
			mouseleave_handler,
			mouseenter_handler_1,
			mouseleave_handler_1,
			mouseenter_handler_2,
			mouseleave_handler_2,
			close_handler,
			click_handler_4,
			close_handler_1,
			click_handler_5,
			close_handler_2,
			click_handler_6,
			func,
			check_handler,
			select_handler,
			action_handler,
			mouseenter_handler_3,
			mouseleave_handler_3,
			click_handler_7
		];
	}

	class CredentialList extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$w, create_fragment$w, safe_not_equal, {}, null, [-1, -1]);

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "CredentialList",
				options,
				id: create_fragment$w.name
			});
		}
	}

	/* src/lib/components/dashboard/components/roleSelector.svelte generated by Svelte v4.2.19 */
	const file$v = "src/lib/components/dashboard/components/roleSelector.svelte";

	function create_fragment$v(ctx) {
		let div;
		let button0;
		let t1;
		let button1;
		let mounted;
		let dispose;

		const block = {
			c: function create() {
				div = element("div");
				button0 = element("button");
				button0.textContent = "Member";
				t1 = space();
				button1 = element("button");
				button1.textContent = "Admin";
				attr_dev(button0, "class", "w-full rounded-md cursor-pointer px-2 py-1 bg-osvauld-readerOrange text-osvauld-readerText m-1");
				add_location(button0, file$v, 11, 1, 353);
				attr_dev(button1, "class", "w-full rounded-md cursor-pointer px-2 py-1 bg-osvauld-managerPurple text-osvauld-managerText m-1");
				add_location(button1, file$v, 15, 1, 539);
				attr_dev(div, "class", "absolute top-0 right-2 !z-[100] w-[10rem] bg-osvauld-frameblack border-osvauld-bordergreen ml-auto flex flex-col justify-center items-center");
				add_location(div, file$v, 8, 0, 195);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, button0);
				append_dev(div, t1);
				append_dev(div, button1);

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*click_handler*/ ctx[1]), false, false, true, false),
						listen_dev(button1, "click", stop_propagation(/*click_handler_1*/ ctx[2]), false, false, true, false)
					];

					mounted = true;
				}
			},
			p: noop,
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$v.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$v($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('RoleSelector', slots, []);
		const dispatch = createEventDispatcher();

		const select = permission => {
			dispatch("select", { permission });
		};

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RoleSelector> was created with unknown prop '${key}'`);
		});

		const click_handler = () => select('member');
		const click_handler_1 = () => select('admin');
		$$self.$capture_state = () => ({ createEventDispatcher, dispatch, select });
		return [select, click_handler, click_handler_1];
	}

	class RoleSelector extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "RoleSelector",
				options,
				id: create_fragment$v.name
			});
		}
	}

	/* src/lib/components/dashboard/groups/AddUserToGroup.svelte generated by Svelte v4.2.19 */

	const { Error: Error_1$4 } = globals;
	const file$u = "src/lib/components/dashboard/groups/AddUserToGroup.svelte";

	function get_each_context$a(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[18] = list[i];
		child_ctx[20] = i;
		return child_ctx;
	}

	// (127:9) {:else}
	function create_else_block$f(ctx) {
		let span;
		let userplus;
		let span_class_value;
		let current;
		userplus = new UserPlus({ $$inline: true });

		const block = {
			c: function create() {
				span = element("span");
				create_component(userplus.$$.fragment);

				attr_dev(span, "class", span_class_value = /*hoveredIndex*/ ctx[2] === /*index*/ ctx[20]
				? 'visible'
				: 'invisible');

				add_location(span, file$u, 148, 10, 4582);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				mount_component(userplus, span, null);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (!current || dirty & /*hoveredIndex*/ 4 && span_class_value !== (span_class_value = /*hoveredIndex*/ ctx[2] === /*index*/ ctx[20]
				? 'visible'
				: 'invisible')) {
					attr_dev(span, "class", span_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(userplus.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(userplus.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				destroy_component(userplus);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$f.name,
			type: "else",
			source: "(127:9) {:else}",
			ctx
		});

		return block;
	}

	// (122:9) {#if selectedUserIndice === index}
	function create_if_block$n(ctx) {
		let switch_instance;
		let switch_instance_anchor;
		let current;

		var switch_value = /*roleSelectionPrompt*/ ctx[4]
		? RoleSelector
		: UserCheck;

		function switch_props(ctx, dirty) {
			return { $$inline: true };
		}

		if (switch_value) {
			switch_instance = construct_svelte_component_dev(switch_value, switch_props());
			switch_instance.$on("select", /*selectionMaker*/ ctx[6]);
		}

		const block = {
			c: function create() {
				if (switch_instance) create_component(switch_instance.$$.fragment);
				switch_instance_anchor = empty();
			},
			m: function mount(target, anchor) {
				if (switch_instance) mount_component(switch_instance, target, anchor);
				insert_dev(target, switch_instance_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty & /*roleSelectionPrompt*/ 16 && switch_value !== (switch_value = /*roleSelectionPrompt*/ ctx[4]
				? RoleSelector
				: UserCheck)) {
					if (switch_instance) {
						group_outros();
						const old_component = switch_instance;

						transition_out(old_component.$$.fragment, 1, 0, () => {
							destroy_component(old_component, 1);
						});

						check_outros();
					}

					if (switch_value) {
						switch_instance = construct_svelte_component_dev(switch_value, switch_props());
						switch_instance.$on("select", /*selectionMaker*/ ctx[6]);
						create_component(switch_instance.$$.fragment);
						transition_in(switch_instance.$$.fragment, 1);
						mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
					} else {
						switch_instance = null;
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				if (switch_instance) transition_in(switch_instance.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				if (switch_instance) transition_out(switch_instance.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(switch_instance_anchor);
				}

				if (switch_instance) destroy_component(switch_instance, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$n.name,
			type: "if",
			source: "(122:9) {#if selectedUserIndice === index}",
			ctx
		});

		return block;
	}

	// (110:5) {#each users as user, index}
	function create_each_block$a(ctx) {
		let li;
		let div;
		let span;
		let t0_value = /*user*/ ctx[18].name + "";
		let t0;
		let t1;
		let button;
		let current_block_type_index;
		let if_block;
		let t2;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block$n, create_else_block$f];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*selectedUserIndice*/ ctx[3] === /*index*/ ctx[20]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function click_handler() {
			return /*click_handler*/ ctx[10](/*user*/ ctx[18], /*index*/ ctx[20]);
		}

		function mouseenter_handler() {
			return /*mouseenter_handler*/ ctx[11](/*index*/ ctx[20]);
		}

		const block = {
			c: function create() {
				li = element("li");
				div = element("div");
				span = element("span");
				t0 = text(t0_value);
				t1 = space();
				button = element("button");
				if_block.c();
				t2 = space();
				attr_dev(span, "class", "text-base");
				add_location(span, file$u, 137, 8, 4208);
				attr_dev(button, "class", "p-2 relative");
				add_location(button, file$u, 138, 8, 4259);
				attr_dev(div, "class", "flex items-center justify-between px-3");
				add_location(div, file$u, 136, 7, 4147);
				attr_dev(li, "class", "list-none my-1 py-1 mr-1 border border-osvauld-bordergreen rounded-lg hover:bg-osvauld-bordergreen");
				add_location(li, file$u, 131, 6, 3907);
			},
			m: function mount(target, anchor) {
				insert_dev(target, li, anchor);
				append_dev(li, div);
				append_dev(div, span);
				append_dev(span, t0);
				append_dev(div, t1);
				append_dev(div, button);
				if_blocks[current_block_type_index].m(button, null);
				append_dev(li, t2);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "click", click_handler, false, false, false, false),
						listen_dev(li, "mouseenter", mouseenter_handler, false, false, false, false),
						listen_dev(li, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				if ((!current || dirty & /*users*/ 1) && t0_value !== (t0_value = /*user*/ ctx[18].name + "")) set_data_dev(t0, t0_value);
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(button, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(li);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$a.name,
			type: "each",
			source: "(110:5) {#each users as user, index}",
			ctx
		});

		return block;
	}

	function create_fragment$u(ctx) {
		let div8;
		let div7;
		let div0;
		let span;
		let t1;
		let button;
		let closepanel;
		let t2;
		let div1;
		let t3;
		let div6;
		let div5;
		let div2;
		let lens;
		let t4;
		let input;
		let t5;
		let div3;
		let t6;
		let div4;
		let div8_intro;
		let div8_outro;
		let current;
		let mounted;
		let dispose;
		closepanel = new ClosePanel({ $$inline: true });
		lens = new Lens({ $$inline: true });
		let each_value = ensure_array_like_dev(/*users*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div8 = element("div");
				div7 = element("div");
				div0 = element("div");
				span = element("span");
				span.textContent = "Add Users";
				t1 = space();
				button = element("button");
				create_component(closepanel.$$.fragment);
				t2 = space();
				div1 = element("div");
				t3 = space();
				div6 = element("div");
				div5 = element("div");
				div2 = element("div");
				create_component(lens.$$.fragment);
				t4 = space();
				input = element("input");
				t5 = space();
				div3 = element("div");
				t6 = space();
				div4 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(span, "class", "font-sans text-white text-28 font-normal");
				add_location(span, file$u, 103, 3, 2783);
				attr_dev(button, "class", "p-2");
				add_location(button, file$u, 104, 3, 2858);
				attr_dev(div0, "class", "flex justify-between items-center p-3");
				add_location(div0, file$u, 102, 2, 2728);
				attr_dev(div1, "class", "border border-osvauld-bordergreen mb-2 w-full");
				add_location(div1, file$u, 106, 2, 2938);
				attr_dev(input, "type", "text");
				attr_dev(input, "class", "h-[1.60rem] w-full bg-osvauld-frameblack border-0 text-osvauld-quarzowhite placeholder-osvauld-placeholderblack border-transparent text-base focus:border-transparent focus:ring-0 cursor-pointer");
				attr_dev(input, "placeholder", "Search for users");
				add_location(input, file$u, 117, 5, 3352);
				attr_dev(div2, "class", "h-[1.875rem] w-full px-2 mx-auto flex justify-start items-center border border-osvauld-bordergreen rounded-lg cursor-pointer");
				add_location(div2, file$u, 113, 4, 3184);
				attr_dev(div3, "class", "border border-osvauld-bordergreen my-1 w-full mb-1");
				add_location(div3, file$u, 125, 4, 3679);
				attr_dev(div4, "class", "overflow-y-scroll scrollbar-thin bg-osvauld-frameblack w-full min-h-[40vh] max-h-[70vh]");
				add_location(div4, file$u, 127, 4, 3755);
				attr_dev(div5, "class", "p-2 border border-osvauld-bordergreen rounded-lg");
				add_location(div5, file$u, 112, 3, 3117);
				attr_dev(div6, "class", "flex-grow max-h-[85vh]");
				attr_dev(div6, "role", "complementary");
				add_location(div6, file$u, 107, 2, 3006);
				attr_dev(div7, "class", "w-[30vw] h-screen shadow-xl translate-x-0 bg-osvauld-frameblack p-6");
				add_location(div7, file$u, 99, 1, 2640);
				attr_dev(div8, "class", "fixed top-0 right-0 z-50 blur-none flex justify-end rounded-xl");
				add_location(div8, file$u, 94, 0, 2543);
			},
			l: function claim(nodes) {
				throw new Error_1$4("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div8, anchor);
				append_dev(div8, div7);
				append_dev(div7, div0);
				append_dev(div0, span);
				append_dev(div0, t1);
				append_dev(div0, button);
				mount_component(closepanel, button, null);
				append_dev(div7, t2);
				append_dev(div7, div1);
				append_dev(div7, t3);
				append_dev(div7, div6);
				append_dev(div6, div5);
				append_dev(div5, div2);
				mount_component(lens, div2, null);
				append_dev(div2, t4);
				append_dev(div2, input);
				set_input_value(input, /*searchInput*/ ctx[1]);
				append_dev(div5, t5);
				append_dev(div5, div3);
				append_dev(div5, t6);
				append_dev(div5, div4);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div4, null);
					}
				}

				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "click", /*closeDrawer*/ ctx[7], false, false, false, false),
						listen_dev(input, "input", /*input_input_handler*/ ctx[9]),
						listen_dev(div6, "mouseleave", /*handleCurserMoveOut*/ ctx[8], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*searchInput*/ 2 && input.value !== /*searchInput*/ ctx[1]) {
					set_input_value(input, /*searchInput*/ ctx[1]);
				}

				if (dirty & /*hoveredIndex, addUsertoGroup, users, roleSelectionPrompt, selectionMaker, selectedUserIndice*/ 125) {
					each_value = ensure_array_like_dev(/*users*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$a(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$a(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div4, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closepanel.$$.fragment, local);
				transition_in(lens.$$.fragment, local);

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (div8_outro) div8_outro.end(1);
						div8_intro = create_in_transition(div8, fly, {});
						div8_intro.start();
					});
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(closepanel.$$.fragment, local);
				transition_out(lens.$$.fragment, local);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				if (div8_intro) div8_intro.invalidate();

				if (local) {
					div8_outro = create_out_transition(div8, fly, {});
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div8);
				}

				destroy_component(closepanel);
				destroy_component(lens);
				destroy_each(each_blocks, detaching);
				if (detaching && div8_outro) div8_outro.end();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$u.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$u($$self, $$props, $$invalidate) {
		let $selectedGroup;
		validate_store(selectedGroup, 'selectedGroup');
		component_subscribe($$self, selectedGroup, $$value => $$invalidate(16, $selectedGroup = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('AddUserToGroup', slots, []);
		let users = [];
		let userDataForApproval;
		let searchInput = "";
		let hoveredIndex = null;
		let selectedPermission = null;
		let selectedUserIndice = null;
		let roleSelectionPrompt = false;
		let credentialFields = [];

		onMount(async () => {
			if (!$selectedGroup) return;
			const userGroup = await fetchUsersWithoutGroupAccess($selectedGroup.groupId);
			$$invalidate(0, users = userGroup.data);
			const credentialFieldsResponse = await fetchCredentialFieldsByGroupId($selectedGroup.groupId);
			credentialFields = credentialFieldsResponse.data;
		});

		const approveSelections = async () => {
			if (!selectedPermission || $selectedGroup === null) return;

			const userData = await sendMessage("createShareCredPayload", {
				creds: credentialFields,
				users: [userDataForApproval]
			});

			const payload = {
				groupId: $selectedGroup.groupId,
				memberId: userDataForApproval.id,
				memberRole: selectedPermission,
				credentials: userData[0].credentials
			};

			const userAdditionResponse = await addUserToGroup(payload);
			$$invalidate(3, selectedUserIndice = null);

			if (userAdditionResponse.success) {
				toastStore.set({
					type: true,
					message: userAdditionResponse.message,
					show: true
				});
			}

			$$invalidate(0, users = users.filter(u => u.id !== userDataForApproval.id));
		};

		const addUsertoGroup = async (user, selectedUser) => {
			$$invalidate(4, roleSelectionPrompt = true);
			$$invalidate(3, selectedUserIndice = selectedUser);
			userDataForApproval = user;

			if ($selectedGroup === null) {
				throw new Error("Group not selected");
			}
		};

		const selectionMaker = async e => {
			selectedPermission = e.detail.permission;
			$$invalidate(4, roleSelectionPrompt = false);
			await approveSelections();
		};

		const closeDrawer = () => {
			showAddUserToGroupDrawer.set(false);
			if ($selectedGroup === null) return;

			fetchGroupUsers($selectedGroup.groupId).then(usersResponse => {
				groupUsers.set(usersResponse.data);
			});
		};

		const handleCurserMoveOut = () => {
			$$invalidate(3, selectedUserIndice = null);
		};

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AddUserToGroup> was created with unknown prop '${key}'`);
		});

		function input_input_handler() {
			searchInput = this.value;
			$$invalidate(1, searchInput);
		}

		const click_handler = (user, index) => addUsertoGroup(user, index);
		const mouseenter_handler = index => $$invalidate(2, hoveredIndex = index);
		const mouseleave_handler = () => $$invalidate(2, hoveredIndex = null);

		$$self.$capture_state = () => ({
			onMount,
			fly,
			fetchGroupUsers,
			addUserToGroup,
			fetchCredentialFieldsByGroupId,
			fetchUsersWithoutGroupAccess,
			ClosePanel,
			Lens,
			UserCheck,
			UserPlus,
			selectedGroup,
			showAddUserToGroupDrawer,
			groupUsers,
			toastStore,
			RoleSelector,
			sendMessage,
			users,
			userDataForApproval,
			searchInput,
			hoveredIndex,
			selectedPermission,
			selectedUserIndice,
			roleSelectionPrompt,
			credentialFields,
			approveSelections,
			addUsertoGroup,
			selectionMaker,
			closeDrawer,
			handleCurserMoveOut,
			$selectedGroup
		});

		$$self.$inject_state = $$props => {
			if ('users' in $$props) $$invalidate(0, users = $$props.users);
			if ('userDataForApproval' in $$props) userDataForApproval = $$props.userDataForApproval;
			if ('searchInput' in $$props) $$invalidate(1, searchInput = $$props.searchInput);
			if ('hoveredIndex' in $$props) $$invalidate(2, hoveredIndex = $$props.hoveredIndex);
			if ('selectedPermission' in $$props) selectedPermission = $$props.selectedPermission;
			if ('selectedUserIndice' in $$props) $$invalidate(3, selectedUserIndice = $$props.selectedUserIndice);
			if ('roleSelectionPrompt' in $$props) $$invalidate(4, roleSelectionPrompt = $$props.roleSelectionPrompt);
			if ('credentialFields' in $$props) credentialFields = $$props.credentialFields;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			users,
			searchInput,
			hoveredIndex,
			selectedUserIndice,
			roleSelectionPrompt,
			addUsertoGroup,
			selectionMaker,
			closeDrawer,
			handleCurserMoveOut,
			input_input_handler,
			click_handler,
			mouseenter_handler,
			mouseleave_handler
		];
	}

	class AddUserToGroup extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "AddUserToGroup",
				options,
				id: create_fragment$u.name
			});
		}
	}

	/* src/lib/components/basic/RoleToggle.svelte generated by Svelte v4.2.19 */
	const file$t = "src/lib/components/basic/RoleToggle.svelte";

	function get_each_context$9(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[4] = list[i];
		return child_ctx;
	}

	// (14:2) {#each ["user", "admin"] as item}
	function create_each_block$9(ctx) {
		let button;
		let span;
		let t1;
		let button_class_value;
		let mounted;
		let dispose;

		function click_handler() {
			return /*click_handler*/ ctx[2](/*item*/ ctx[4]);
		}

		const block = {
			c: function create() {
				button = element("button");
				span = element("span");
				span.textContent = `${/*item*/ ctx[4]}`;
				t1 = space();
				attr_dev(span, "class", "");
				add_location(span, file$t, 24, 4, 735);

				attr_dev(button, "class", button_class_value = "w-1/2 px-4 py-1 text-lg flex justify-center items-center rounded-lg focus:outline-none " + (/*selectedItem*/ ctx[0] === /*item*/ ctx[4]
				? 'bg-osvauld-bordergreen text-osvauld-plainwhite'
				: 'text-osvauld-quarzowhite') + "");

				add_location(button, file$t, 17, 3, 464);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				append_dev(button, span);
				append_dev(button, t1);

				if (!mounted) {
					dispose = listen_dev(button, "click", click_handler, false, false, false, false);
					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;

				if (dirty & /*selectedItem*/ 1 && button_class_value !== (button_class_value = "w-1/2 px-4 py-1 text-lg flex justify-center items-center rounded-lg focus:outline-none " + (/*selectedItem*/ ctx[0] === /*item*/ ctx[4]
				? 'bg-osvauld-bordergreen text-osvauld-plainwhite'
				: 'text-osvauld-quarzowhite') + "")) {
					attr_dev(button, "class", button_class_value);
				}
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$9.name,
			type: "each",
			source: "(14:2) {#each [\\\"user\\\", \\\"admin\\\"] as item}",
			ctx
		});

		return block;
	}

	function create_fragment$t(ctx) {
		let div1;
		let div0;
		let each_value = ensure_array_like_dev(["user", "admin"]);
		let each_blocks = [];

		for (let i = 0; i < 2; i += 1) {
			each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
		}

		const block = {
			c: function create() {
				div1 = element("div");
				div0 = element("div");

				for (let i = 0; i < 2; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(div0, "class", "inline-flex justify-center space-x-1 p-1 bg-osvauld-frameblack border border-osvauld-iconblack rounded-xl w-[70%]");
				add_location(div0, file$t, 13, 1, 293);
				attr_dev(div1, "class", "flex justify-center w-[100%]");
				add_location(div1, file$t, 12, 0, 249);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, div0);

				for (let i = 0; i < 2; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div0, null);
					}
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*selectedItem, select*/ 3) {
					each_value = ensure_array_like_dev(["user", "admin"]);
					let i;

					for (i = 0; i < 2; i += 1) {
						const child_ctx = get_each_context$9(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$9(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(div0, null);
						}
					}

					for (; i < 2; i += 1) {
						each_blocks[i].d(1);
					}
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$t.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$t($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('RoleToggle', slots, []);
		const dispatch = createEventDispatcher();
		let selectedItem = "user";

		const select = async choice => {
			$$invalidate(0, selectedItem = choice);
			dispatch("select", selectedItem);
		};

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RoleToggle> was created with unknown prop '${key}'`);
		});

		const click_handler = item => select(item);

		$$self.$capture_state = () => ({
			createEventDispatcher,
			dispatch,
			selectedItem,
			select
		});

		$$self.$inject_state = $$props => {
			if ('selectedItem' in $$props) $$invalidate(0, selectedItem = $$props.selectedItem);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [selectedItem, select, click_handler];
	}

	class RoleToggle extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "RoleToggle",
				options,
				id: create_fragment$t.name
			});
		}
	}

	/* src/lib/components/dashboard/groups/AddUser.svelte generated by Svelte v4.2.19 */
	const file$s = "src/lib/components/dashboard/groups/AddUser.svelte";

	// (121:3) {:else}
	function create_else_block$e(ctx) {
		let t;

		const block = {
			c: function create() {
				t = text("Create User");
			},
			m: function mount(target, anchor) {
				insert_dev(target, t, anchor);
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$e.name,
			type: "else",
			source: "(121:3) {:else}",
			ctx
		});

		return block;
	}

	// (118:31) 
	function create_if_block_2$b(ctx) {
		let tick_1;
		let t0;
		let span;
		let current;
		tick_1 = new Tick({ $$inline: true });

		const block = {
			c: function create() {
				create_component(tick_1.$$.fragment);
				t0 = space();
				span = element("span");
				span.textContent = "Copied to clipboard";
				attr_dev(span, "class", "ml-2");
				add_location(span, file$s, 124, 4, 3773);
			},
			m: function mount(target, anchor) {
				mount_component(tick_1, target, anchor);
				insert_dev(target, t0, anchor);
				insert_dev(target, span, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(tick_1.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(tick_1.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t0);
					detach_dev(span);
				}

				destroy_component(tick_1, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$b.name,
			type: "if",
			source: "(118:31) ",
			ctx
		});

		return block;
	}

	// (116:3) {#if isLoaderActive}
	function create_if_block_1$h(ctx) {
		let loader;
		let current;
		loader = new Loader({ $$inline: true });

		const block = {
			c: function create() {
				create_component(loader.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(loader, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(loader.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(loader.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(loader, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$h.name,
			type: "if",
			source: "(116:3) {#if isLoaderActive}",
			ctx
		});

		return block;
	}

	// (125:2) {#if erroMessage}
	function create_if_block$m(ctx) {
		let p;
		let t;

		const block = {
			c: function create() {
				p = element("p");
				t = text(/*erroMessage*/ ctx[4]);
				attr_dev(p, "class", "text-base text-sm");
				add_location(p, file$s, 130, 3, 3890);
			},
			m: function mount(target, anchor) {
				insert_dev(target, p, anchor);
				append_dev(p, t);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*erroMessage*/ 16) set_data_dev(t, /*erroMessage*/ ctx[4]);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(p);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$m.name,
			type: "if",
			source: "(125:2) {#if erroMessage}",
			ctx
		});

		return block;
	}

	function create_fragment$s(ctx) {
		let div5;
		let div0;
		let p;
		let t1;
		let button0;
		let closepanel;
		let t2;
		let div1;
		let t3;
		let form;
		let div2;
		let label0;
		let t5;
		let input0;
		let t6;
		let div3;
		let label1;
		let t8;
		let input1;
		let t9;
		let div4;
		let label2;
		let t11;
		let roletoggle;
		let t12;
		let button1;
		let current_block_type_index;
		let if_block0;
		let button1_class_value;
		let t13;
		let current;
		let mounted;
		let dispose;
		closepanel = new ClosePanel({ $$inline: true });
		roletoggle = new RoleToggle({ $$inline: true });
		roletoggle.$on("select", /*roleManager*/ ctx[7]);
		const if_block_creators = [create_if_block_1$h, create_if_block_2$b, create_else_block$e];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*isLoaderActive*/ ctx[3]) return 0;
			if (/*copiedToClipboard*/ ctx[2]) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		let if_block1 = /*erroMessage*/ ctx[4] && create_if_block$m(ctx);

		const block = {
			c: function create() {
				div5 = element("div");
				div0 = element("div");
				p = element("p");
				p.textContent = "Add new user";
				t1 = space();
				button0 = element("button");
				create_component(closepanel.$$.fragment);
				t2 = space();
				div1 = element("div");
				div1.innerHTML = ``;
				t3 = space();
				form = element("form");
				div2 = element("div");
				label0 = element("label");
				label0.textContent = "Username:";
				t5 = space();
				input0 = element("input");
				t6 = space();
				div3 = element("div");
				label1 = element("label");
				label1.textContent = "Full Name:";
				t8 = space();
				input1 = element("input");
				t9 = space();
				div4 = element("div");
				label2 = element("label");
				label2.textContent = "Select Role:";
				t11 = space();
				create_component(roletoggle.$$.fragment);
				t12 = space();
				button1 = element("button");
				if_block0.c();
				t13 = space();
				if (if_block1) if_block1.c();
				attr_dev(p, "class", "text-2xl font-sans font-normal text-osvauld-dusklabel");
				add_location(p, file$s, 61, 2, 1776);
				attr_dev(button0, "class", "bg-osvauld-frameblack");
				add_location(button0, file$s, 64, 2, 1867);
				attr_dev(div0, "class", "flex justify-between items-center px-4 py-6");
				add_location(div0, file$s, 60, 1, 1716);
				attr_dev(div1, "class", "border border-osvauld-iconblack w-[calc(100%+3rem)] -translate-x-6 my-10 mt-0");
				add_location(div1, file$s, 69, 1, 1986);
				attr_dev(label0, "for", "username");
				attr_dev(label0, "class", "label block mb-2 text-left text-osvauld-dusklabel text-sm font-normal cursor-pointer");
				add_location(label0, file$s, 77, 3, 2210);
				attr_dev(input0, "id", "username");
				attr_dev(input0, "type", "text");
				attr_dev(input0, "placeholder", "Enter username");
				attr_dev(input0, "class", "py-1 rounded-sm items-center text-base bg-osvauld-frameblack border-osvauld-iconblack w-[95%] h-10 mx-2 focus:border-osvauld-iconblack focus:ring-0");
				input0.required = true;
				attr_dev(input0, "autocomplete", "off");
				add_location(input0, file$s, 81, 3, 2359);
				attr_dev(div2, "class", "mb-4 w-full");
				add_location(div2, file$s, 76, 2, 2181);
				attr_dev(label1, "for", "name");
				attr_dev(label1, "class", "label block mb-2 text-left text-osvauld-dusklabel text-sm font-normal cursor-pointer");
				add_location(label1, file$s, 92, 3, 2701);
				attr_dev(input1, "id", "name");
				attr_dev(input1, "type", "text");
				attr_dev(input1, "placeholder", "Enter full name here");
				input1.required = true;
				attr_dev(input1, "class", "py-1 rounded-sm items-center text-base bg-osvauld-frameblack border-osvauld-iconblack w-[95%] h-10 mx-2 focus:border-osvauld-iconblack focus:ring-0");
				attr_dev(input1, "autocomplete", "off");
				add_location(input1, file$s, 96, 3, 2847);
				attr_dev(div3, "class", "mb-4 w-full");
				add_location(div3, file$s, 91, 2, 2672);
				attr_dev(label2, "for", "role");
				attr_dev(label2, "class", "label block mb-2 text-left text-osvauld-dusklabel text-sm font-normal cursor-pointer");
				add_location(label2, file$s, 107, 3, 3187);
				attr_dev(div4, "class", "mb-4 w-full");
				add_location(div4, file$s, 106, 2, 3158);

				attr_dev(button1, "class", button1_class_value = "w-full px-4 py-2 mt-3 flex justify-center items-center border border-osvauld-placeholderblack rounded-md " + (/*activeButton*/ ctx[5]
				? 'bg-osvauld-carolinablue text-osvauld-ninjablack'
				: 'bg-osvauld-iconblack text-osvauld-sheffieldgrey'));

				attr_dev(button1, "type", "submit");
				add_location(button1, file$s, 114, 2, 3388);
				attr_dev(form, "class", "h-1/2 flex flex-col justify-between items-center");
				add_location(form, file$s, 73, 1, 2090);
				attr_dev(div5, "class", "bg-osvauld-frameblack rounded-3xl h-[30rem] w-[23rem] p-6 pt-2");
				add_location(div5, file$s, 59, 0, 1638);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div5, anchor);
				append_dev(div5, div0);
				append_dev(div0, p);
				append_dev(div0, t1);
				append_dev(div0, button0);
				mount_component(closepanel, button0, null);
				append_dev(div5, t2);
				append_dev(div5, div1);
				append_dev(div5, t3);
				append_dev(div5, form);
				append_dev(form, div2);
				append_dev(div2, label0);
				append_dev(div2, t5);
				append_dev(div2, input0);
				set_input_value(input0, /*username*/ ctx[0]);
				append_dev(form, t6);
				append_dev(form, div3);
				append_dev(div3, label1);
				append_dev(div3, t8);
				append_dev(div3, input1);
				set_input_value(input1, /*name*/ ctx[1]);
				append_dev(form, t9);
				append_dev(form, div4);
				append_dev(div4, label2);
				append_dev(div4, t11);
				mount_component(roletoggle, div4, null);
				append_dev(form, t12);
				append_dev(form, button1);
				if_blocks[current_block_type_index].m(button1, null);
				append_dev(form, t13);
				if (if_block1) if_block1.m(form, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*handleClose*/ ctx[8]), false, false, true, false),
						listen_dev(input0, "input", /*input0_input_handler*/ ctx[10]),
						listen_dev(input1, "input", /*input1_input_handler*/ ctx[11]),
						listen_dev(button1, "click", stop_propagation(/*click_handler*/ ctx[9]), false, false, true, false),
						listen_dev(form, "submit", /*submit*/ ctx[6], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*username*/ 1 && input0.value !== /*username*/ ctx[0]) {
					set_input_value(input0, /*username*/ ctx[0]);
				}

				if (dirty & /*name*/ 2 && input1.value !== /*name*/ ctx[1]) {
					set_input_value(input1, /*name*/ ctx[1]);
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index !== previous_block_index) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					}

					transition_in(if_block0, 1);
					if_block0.m(button1, null);
				}

				if (!current || dirty & /*activeButton*/ 32 && button1_class_value !== (button1_class_value = "w-full px-4 py-2 mt-3 flex justify-center items-center border border-osvauld-placeholderblack rounded-md " + (/*activeButton*/ ctx[5]
				? 'bg-osvauld-carolinablue text-osvauld-ninjablack'
				: 'bg-osvauld-iconblack text-osvauld-sheffieldgrey'))) {
					attr_dev(button1, "class", button1_class_value);
				}

				if (/*erroMessage*/ ctx[4]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);
					} else {
						if_block1 = create_if_block$m(ctx);
						if_block1.c();
						if_block1.m(form, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closepanel.$$.fragment, local);
				transition_in(roletoggle.$$.fragment, local);
				transition_in(if_block0);
				current = true;
			},
			o: function outro(local) {
				transition_out(closepanel.$$.fragment, local);
				transition_out(roletoggle.$$.fragment, local);
				transition_out(if_block0);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div5);
				}

				destroy_component(closepanel);
				destroy_component(roletoggle);
				if_blocks[current_block_type_index].d();
				if (if_block1) if_block1.d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$s.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$s($$self, $$props, $$invalidate) {
		let activeButton;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('AddUser', slots, []);
		let username = "";
		let name = "";
		let copiedToClipboard = false;
		let isLoaderActive = false;
		let erroMessage = "";
		let assignedRole = "user";

		const submit = async event => {
			event.preventDefault();
			$$invalidate(3, isLoaderActive = true);
			const response = await checkUserNameExists(username, name);

			if (response.data.available === false) {
				$$invalidate(4, erroMessage = response.data.message);
				$$invalidate(3, isLoaderActive = false);
				return;
			}

			const { baseUrl } = await getTokenAndBaseUrl();
			const tempPassword = generatePassword(10);

			const payload = {
				username,
				name,
				type: assignedRole,
				tempPassword
			};

			await createUser(payload);
			const shareWithMember = JSON.stringify({ username, tempPassword, baseUrl });
			await writeToClipboard(shareWithMember);
			$$invalidate(2, copiedToClipboard = true);
			$$invalidate(3, isLoaderActive = false);

			setTimeout(
				() => {
					showAddUserDrawer.set(false);
					allUsersSelected.set(true);
				},
				3000
			);
		};

		const roleManager = async e => {
			e.preventDefault();
			assignedRole = e.detail;
		};

		const handleClose = () => {
			showAddUserDrawer.set(false);
		};

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AddUser> was created with unknown prop '${key}'`);
		});

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		function input0_input_handler() {
			username = this.value;
			$$invalidate(0, username);
		}

		function input1_input_handler() {
			name = this.value;
			$$invalidate(1, name);
		}

		$$self.$capture_state = () => ({
			getTokenAndBaseUrl,
			writeToClipboard,
			Loader,
			RoleToggle,
			showAddUserDrawer,
			allUsersSelected,
			createUser,
			checkUserNameExists,
			ClosePanel,
			Tick,
			generatePassword,
			username,
			name,
			copiedToClipboard,
			isLoaderActive,
			erroMessage,
			assignedRole,
			submit,
			roleManager,
			handleClose,
			activeButton
		});

		$$self.$inject_state = $$props => {
			if ('username' in $$props) $$invalidate(0, username = $$props.username);
			if ('name' in $$props) $$invalidate(1, name = $$props.name);
			if ('copiedToClipboard' in $$props) $$invalidate(2, copiedToClipboard = $$props.copiedToClipboard);
			if ('isLoaderActive' in $$props) $$invalidate(3, isLoaderActive = $$props.isLoaderActive);
			if ('erroMessage' in $$props) $$invalidate(4, erroMessage = $$props.erroMessage);
			if ('assignedRole' in $$props) assignedRole = $$props.assignedRole;
			if ('activeButton' in $$props) $$invalidate(5, activeButton = $$props.activeButton);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*username, name*/ 3) {
				$$invalidate(5, activeButton = username.length >= 3 && name.length >= 3);
			}
		};

		return [
			username,
			name,
			copiedToClipboard,
			isLoaderActive,
			erroMessage,
			activeButton,
			submit,
			roleManager,
			handleClose,
			click_handler,
			input0_input_handler,
			input1_input_handler
		];
	}

	class AddUser extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "AddUser",
				options,
				id: create_fragment$s.name
			});
		}
	}

	/* src/lib/components/dashboard/groups/AllUsersList.svelte generated by Svelte v4.2.19 */
	const file$r = "src/lib/components/dashboard/groups/AllUsersList.svelte";

	function get_each_context$8(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[10] = list[i];
		return child_ctx;
	}

	// (58:4) {#each allUsers as user}
	function create_each_block$8(ctx) {
		let tr;
		let td0;
		let t0_value = /*user*/ ctx[10].name + "";
		let t0;
		let t1;
		let td1;
		let t2_value = /*user*/ ctx[10].username + "";
		let t2;
		let t3;
		let td2;
		let span;
		let t4_value = (/*user*/ ctx[10].type || "Error") + "";
		let t4;
		let span_class_value;
		let t5;
		let td3;
		let t6_value = /*user*/ ctx[10].status + "";
		let t6;
		let t7;
		let td4;
		let button;
		let binicon;
		let t8;
		let current;
		let mounted;
		let dispose;
		binicon = new BinIcon({ $$inline: true });

		function click_handler_2() {
			return /*click_handler_2*/ ctx[9](/*user*/ ctx[10]);
		}

		const block = {
			c: function create() {
				tr = element("tr");
				td0 = element("td");
				t0 = text(t0_value);
				t1 = space();
				td1 = element("td");
				t2 = text(t2_value);
				t3 = space();
				td2 = element("td");
				span = element("span");
				t4 = text(t4_value);
				t5 = space();
				td3 = element("td");
				t6 = text(t6_value);
				t7 = space();
				td4 = element("td");
				button = element("button");
				create_component(binicon.$$.fragment);
				t8 = space();
				attr_dev(td0, "class", "py-5 px-6 text-left whitespace-nowrap w-1/5 transition-colors duration-300");
				add_location(td0, file$r, 64, 6, 2483);
				attr_dev(td1, "class", "py-5 px-6 text-left w-1/5 transition-colors duration-300");
				add_location(td1, file$r, 68, 6, 2615);

				attr_dev(span, "class", span_class_value = "inline-block w-[70%] px-4 py-1 rounded-md text-center transition-colors duration-300 " + (/*user*/ ctx[10].type === 'admin'
				? 'bg-osvauld-ownerGreen text-osvauld-ownerText'
				: 'bg-osvauld-readerOrange text-osvauld-readerText'));

				add_location(span, file$r, 74, 7, 2817);
				attr_dev(td2, "class", "py-5 px-6 text-left w-1/5 transition-colors duration-300");
				add_location(td2, file$r, 71, 6, 2726);
				attr_dev(td3, "class", "py-5 px-6 text-left w-1/5 transition-colors duration-300");
				add_location(td3, file$r, 83, 6, 3148);
				add_location(button, file$r, 89, 7, 3381);
				attr_dev(td4, "class", "flex justify-center items-center py-5 w-1/5 cursor-pointer transition-colors duration-300");
				add_location(td4, file$r, 86, 6, 3257);
				attr_dev(tr, "class", "border border-transparent hover:bg-osvauld-modalFieldActive text-osvauld-dusklabel hover:text-osvauld-sideListTextActive text-base font-light border-b border-b-osvauld-iconblack transition-colors duration-300");
				add_location(tr, file$r, 61, 5, 2243);
			},
			m: function mount(target, anchor) {
				insert_dev(target, tr, anchor);
				append_dev(tr, td0);
				append_dev(td0, t0);
				append_dev(tr, t1);
				append_dev(tr, td1);
				append_dev(td1, t2);
				append_dev(tr, t3);
				append_dev(tr, td2);
				append_dev(td2, span);
				append_dev(span, t4);
				append_dev(tr, t5);
				append_dev(tr, td3);
				append_dev(td3, t6);
				append_dev(tr, t7);
				append_dev(tr, td4);
				append_dev(td4, button);
				mount_component(binicon, button, null);
				append_dev(tr, t8);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", click_handler_2, false, false, false, false);
					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				if ((!current || dirty & /*allUsers*/ 4) && t0_value !== (t0_value = /*user*/ ctx[10].name + "")) set_data_dev(t0, t0_value);
				if ((!current || dirty & /*allUsers*/ 4) && t2_value !== (t2_value = /*user*/ ctx[10].username + "")) set_data_dev(t2, t2_value);
				if ((!current || dirty & /*allUsers*/ 4) && t4_value !== (t4_value = (/*user*/ ctx[10].type || "Error") + "")) set_data_dev(t4, t4_value);

				if (!current || dirty & /*allUsers*/ 4 && span_class_value !== (span_class_value = "inline-block w-[70%] px-4 py-1 rounded-md text-center transition-colors duration-300 " + (/*user*/ ctx[10].type === 'admin'
				? 'bg-osvauld-ownerGreen text-osvauld-ownerText'
				: 'bg-osvauld-readerOrange text-osvauld-readerText'))) {
					attr_dev(span, "class", span_class_value);
				}

				if ((!current || dirty & /*allUsers*/ 4) && t6_value !== (t6_value = /*user*/ ctx[10].status + "")) set_data_dev(t6, t6_value);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(binicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(binicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(tr);
				}

				destroy_component(binicon);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$8.name,
			type: "each",
			source: "(58:4) {#each allUsers as user}",
			ctx
		});

		return block;
	}

	// (98:1) {#if $showAddUserDrawer}
	function create_if_block$l(ctx) {
		let button1;
		let button0;
		let adduser;
		let current;
		let mounted;
		let dispose;
		adduser = new AddUser({ $$inline: true });

		const block = {
			c: function create() {
				button1 = element("button");
				button0 = element("button");
				create_component(adduser.$$.fragment);
				attr_dev(button0, "class", "p-6 rounded bg-transparent");
				add_location(button0, file$r, 105, 3, 3758);
				attr_dev(button1, "class", "fixed inset-0 flex items-center justify-center z-50 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px]");
				add_location(button1, file$r, 101, 2, 3593);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button1, anchor);
				append_dev(button1, button0);
				mount_component(adduser, button0, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*click_handler*/ ctx[5]), false, false, true, false),
						listen_dev(button1, "click", click_handler_3, false, false, false, false)
					];

					mounted = true;
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(adduser.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(adduser.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button1);
				}

				destroy_component(adduser);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$l.name,
			type: "if",
			source: "(98:1) {#if $showAddUserDrawer}",
			ctx
		});

		return block;
	}

	function create_fragment$r(ctx) {
		let div0;
		let h1;
		let t1;
		let button;
		let span;
		let t3;
		let add;
		let button_class_value;
		let t4;
		let div2;
		let table0;
		let thead;
		let tr;
		let th0;
		let t6;
		let th1;
		let t8;
		let th2;
		let t10;
		let th3;
		let t12;
		let th4;
		let t14;
		let div1;
		let table1;
		let tbody;
		let t15;
		let div3;
		let current;
		let mounted;
		let dispose;

		add = new Add({
				props: {
					color: /*addUserHovered*/ ctx[1] ? '#0D0E13' : '#A3A4B5'
				},
				$$inline: true
			});

		let each_value = ensure_array_like_dev(/*allUsers*/ ctx[2]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let if_block = /*$showAddUserDrawer*/ ctx[3] && create_if_block$l(ctx);

		const block = {
			c: function create() {
				div0 = element("div");
				h1 = element("h1");
				h1.textContent = "All Users";
				t1 = space();
				button = element("button");
				span = element("span");
				span.textContent = "Add new user";
				t3 = space();
				create_component(add.$$.fragment);
				t4 = space();
				div2 = element("div");
				table0 = element("table");
				thead = element("thead");
				tr = element("tr");
				th0 = element("th");
				th0.textContent = "Name";
				t6 = space();
				th1 = element("th");
				th1.textContent = "Username";
				t8 = space();
				th2 = element("th");
				th2.textContent = "Role";
				t10 = space();
				th3 = element("th");
				th3.textContent = "Status";
				t12 = space();
				th4 = element("th");
				th4.textContent = "Actions";
				t14 = space();
				div1 = element("div");
				table1 = element("table");
				tbody = element("tbody");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t15 = space();
				div3 = element("div");
				if (if_block) if_block.c();
				attr_dev(h1, "class", "text-4xl p-4 font-normal w-1/3 ml-3");
				add_location(h1, file$r, 28, 1, 859);
				attr_dev(span, "class", "mr-1");
				add_location(span, file$r, 38, 2, 1362);
				attr_dev(button, "class", button_class_value = "border border-osvauld-iconblack rounded-md py-1 px-4 mr-2 text-osvauld-textActive flex justify-center items-center whitespace-nowrap font-light text-base hover:text-osvauld-frameblack hover:bg-osvauld-carolinablue " + (/*accountRole*/ ctx[0] === 'user' ? 'invisible' : ''));
				add_location(button, file$r, 29, 1, 923);
				attr_dev(div0, "class", "flex items-center justify-between px-4 py-5 pb-0");
				add_location(div0, file$r, 27, 0, 795);
				attr_dev(th0, "class", "py-3 px-3 text-left whitespace-nowrap w-1/5");
				add_location(th0, file$r, 46, 4, 1609);
				attr_dev(th1, "class", "py-3 px-3 text-left whitespace-nowrap w-1/5");
				add_location(th1, file$r, 47, 4, 1679);
				attr_dev(th2, "class", "py-3 px-3 text-left whitespace-nowrap w-1/5");
				add_location(th2, file$r, 48, 4, 1753);
				attr_dev(th3, "class", "py-3 px-3 text-left whitespace-nowrap w-1/5");
				add_location(th3, file$r, 49, 4, 1823);
				attr_dev(th4, "class", "py-3 px-3 text-left whitespace-nowrap w-1/5");
				add_location(th4, file$r, 50, 4, 1895);
				attr_dev(tr, "class", "leading-normal text-lg");
				add_location(tr, file$r, 45, 3, 1569);
				add_location(thead, file$r, 44, 2, 1558);
				attr_dev(table0, "class", "min-w-max w-full table-auto");
				add_location(table0, file$r, 43, 1, 1512);
				attr_dev(tbody, "class", "text-xl text-osvauld-dusklabel font-normal text-sm");
				add_location(tbody, file$r, 59, 3, 2142);
				attr_dev(table1, "class", "min-w-max w-full table-auto");
				add_location(table1, file$r, 58, 2, 2095);
				attr_dev(div1, "class", "min-h-[25rem] max-h-[35rem] overflow-y-scroll overflow-x-hidden scrollbar-thin");
				add_location(div1, file$r, 55, 1, 1996);
				attr_dev(div2, "class", "rounded my-6 px-10");
				add_location(div2, file$r, 42, 0, 1478);
				attr_dev(div3, "class", "z-50");
				add_location(div3, file$r, 99, 0, 3546);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div0, anchor);
				append_dev(div0, h1);
				append_dev(div0, t1);
				append_dev(div0, button);
				append_dev(button, span);
				append_dev(button, t3);
				mount_component(add, button, null);
				insert_dev(target, t4, anchor);
				insert_dev(target, div2, anchor);
				append_dev(div2, table0);
				append_dev(table0, thead);
				append_dev(thead, tr);
				append_dev(tr, th0);
				append_dev(tr, t6);
				append_dev(tr, th1);
				append_dev(tr, t8);
				append_dev(tr, th2);
				append_dev(tr, t10);
				append_dev(tr, th3);
				append_dev(tr, t12);
				append_dev(tr, th4);
				append_dev(div2, t14);
				append_dev(div2, div1);
				append_dev(div1, table1);
				append_dev(table1, tbody);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(tbody, null);
					}
				}

				insert_dev(target, t15, anchor);
				insert_dev(target, div3, anchor);
				if (if_block) if_block.m(div3, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "mouseenter", /*mouseenter_handler*/ ctx[6], false, false, false, false),
						listen_dev(button, "mouseleave", /*mouseleave_handler*/ ctx[7], false, false, false, false),
						listen_dev(button, "click", /*click_handler_1*/ ctx[8], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				const add_changes = {};
				if (dirty & /*addUserHovered*/ 2) add_changes.color = /*addUserHovered*/ ctx[1] ? '#0D0E13' : '#A3A4B5';
				add.$set(add_changes);

				if (!current || dirty & /*accountRole*/ 1 && button_class_value !== (button_class_value = "border border-osvauld-iconblack rounded-md py-1 px-4 mr-2 text-osvauld-textActive flex justify-center items-center whitespace-nowrap font-light text-base hover:text-osvauld-frameblack hover:bg-osvauld-carolinablue " + (/*accountRole*/ ctx[0] === 'user' ? 'invisible' : ''))) {
					attr_dev(button, "class", button_class_value);
				}

				if (dirty & /*deleteUserHandler, allUsers*/ 20) {
					each_value = ensure_array_like_dev(/*allUsers*/ ctx[2]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$8(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$8(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(tbody, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (/*$showAddUserDrawer*/ ctx[3]) {
					if (if_block) {
						if (dirty & /*$showAddUserDrawer*/ 8) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$l(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(div3, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(add.$$.fragment, local);

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(add.$$.fragment, local);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div0);
					detach_dev(t4);
					detach_dev(div2);
					detach_dev(t15);
					detach_dev(div3);
				}

				destroy_component(add);
				destroy_each(each_blocks, detaching);
				if (if_block) if_block.d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$r.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	const click_handler_3 = () => {
		
	};

	function instance$r($$self, $$props, $$invalidate) {
		let $showAddUserDrawer;
		validate_store(showAddUserDrawer, 'showAddUserDrawer');
		component_subscribe($$self, showAddUserDrawer, $$value => $$invalidate(3, $showAddUserDrawer = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('AllUsersList', slots, []);
		let accountRole = "user";
		let addUserHovered = false;
		let allUsers = [];

		const deleteUserHandler = async id => {
			await deleteUser(id);
			const allUsersResponse = await fetchAllUsers();
			$$invalidate(2, allUsers = allUsersResponse.data);
		};

		onMount(async () => {
			const accountDetails = await getUserDetails();

			if (accountDetails.type) {
				$$invalidate(0, accountRole = accountDetails.type);
			}

			const fetchAllUsersResponse = await fetchAllUsers();
			$$invalidate(2, allUsers = fetchAllUsersResponse.data);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AllUsersList> was created with unknown prop '${key}'`);
		});

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		const mouseenter_handler = () => $$invalidate(1, addUserHovered = true);
		const mouseleave_handler = () => $$invalidate(1, addUserHovered = false);
		const click_handler_1 = () => showAddUserDrawer.set(true);
		const click_handler_2 = user => deleteUserHandler(user.id);

		$$self.$capture_state = () => ({
			Add,
			BinIcon,
			showAddUserDrawer,
			deleteUser,
			fetchAllUsers,
			AddUser,
			onMount,
			getUserDetails,
			accountRole,
			addUserHovered,
			allUsers,
			deleteUserHandler,
			$showAddUserDrawer
		});

		$$self.$inject_state = $$props => {
			if ('accountRole' in $$props) $$invalidate(0, accountRole = $$props.accountRole);
			if ('addUserHovered' in $$props) $$invalidate(1, addUserHovered = $$props.addUserHovered);
			if ('allUsers' in $$props) $$invalidate(2, allUsers = $$props.allUsers);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			accountRole,
			addUserHovered,
			allUsers,
			$showAddUserDrawer,
			deleteUserHandler,
			click_handler,
			mouseenter_handler,
			mouseleave_handler,
			click_handler_1,
			click_handler_2
		];
	}

	class AllUsersList extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "AllUsersList",
				options,
				id: create_fragment$r.name
			});
		}
	}

	/* src/lib/components/dashboard/groups/OtherGroupsList.svelte generated by Svelte v4.2.19 */

	const { Error: Error_1$3 } = globals;
	const file$q = "src/lib/components/dashboard/groups/OtherGroupsList.svelte";

	function get_each_context$7(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[11] = list[i];
		return child_ctx;
	}

	// (43:1) {#if groupAdmin}
	function create_if_block_1$g(ctx) {
		let button;
		let span;
		let t1;
		let add;
		let current;
		let mounted;
		let dispose;

		add = new Add({
				props: {
					color: /*addUserHovered*/ ctx[2] ? '#0D0E13' : '#A3A4B5'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				button = element("button");
				span = element("span");
				span.textContent = "Add new user";
				t1 = space();
				create_component(add.$$.fragment);
				attr_dev(span, "class", "mr-1");
				add_location(span, file$q, 54, 3, 1679);
				attr_dev(button, "class", "rounded-md py-1 px-4 mr-2 border border-osvauld-iconblack flex justify-center items-center whitespace-nowrap text-base font-light text-osvauld-textActive hover:text-osvauld-frameblack hover:bg-osvauld-carolinablue");
				add_location(button, file$q, 48, 2, 1279);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				append_dev(button, span);
				append_dev(button, t1);
				mount_component(add, button, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "mouseenter", /*mouseenter_handler*/ ctx[5], false, false, false, false),
						listen_dev(button, "mouseleave", /*mouseleave_handler*/ ctx[6], false, false, false, false),
						listen_dev(button, "click", /*click_handler*/ ctx[7], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const add_changes = {};
				if (dirty & /*addUserHovered*/ 4) add_changes.color = /*addUserHovered*/ ctx[2] ? '#0D0E13' : '#A3A4B5';
				add.$set(add_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(add.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(add.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(add);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$g.name,
			type: "if",
			source: "(43:1) {#if groupAdmin}",
			ctx
		});

		return block;
	}

	// (95:7) {#if groupAdmin}
	function create_if_block$k(ctx) {
		let button;
		let binicon;
		let current;
		let mounted;
		let dispose;
		binicon = new BinIcon({ $$inline: true });

		function click_handler_1() {
			return /*click_handler_1*/ ctx[8](/*user*/ ctx[11]);
		}

		const block = {
			c: function create() {
				button = element("button");
				create_component(binicon.$$.fragment);
				add_location(button, file$q, 100, 8, 3401);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				mount_component(binicon, button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", click_handler_1, false, false, false, false);
					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(binicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(binicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(binicon);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$k.name,
			type: "if",
			source: "(95:7) {#if groupAdmin}",
			ctx
		});

		return block;
	}

	// (71:4) {#each $groupUsers as user}
	function create_each_block$7(ctx) {
		let tr;
		let td0;
		let t0_value = /*user*/ ctx[11].name + "";
		let t0;
		let t1;
		let td1;
		let t2_value = /*user*/ ctx[11].username + "";
		let t2;
		let t3;
		let td2;
		let span;
		let t4_value = /*user*/ ctx[11].accessType + "";
		let t4;
		let span_class_value;
		let t5;
		let td3;
		let t6;
		let current;
		let if_block = /*groupAdmin*/ ctx[1] && create_if_block$k(ctx);

		const block = {
			c: function create() {
				tr = element("tr");
				td0 = element("td");
				t0 = text(t0_value);
				t1 = space();
				td1 = element("td");
				t2 = text(t2_value);
				t3 = space();
				td2 = element("td");
				span = element("span");
				t4 = text(t4_value);
				t5 = space();
				td3 = element("td");
				if (if_block) if_block.c();
				t6 = space();
				attr_dev(td0, "class", "py-5 px-6 text-left whitespace-nowrap w-1/4");
				add_location(td0, file$q, 80, 6, 2762);
				attr_dev(td1, "class", "py-5 px-6 text-left w-1/4");
				add_location(td1, file$q, 83, 6, 2856);

				attr_dev(span, "class", span_class_value = "inline-block w-[70%] px-4 py-1 rounded-md text-center " + (/*user*/ ctx[11].accessType === 'admin'
				? 'bg-osvauld-ownerGreen text-osvauld-ownerText'
				: 'bg-osvauld-readerOrange text-osvauld-readerText'));

				add_location(span, file$q, 87, 7, 2982);
				attr_dev(td2, "class", "py-5 px-6 text-left w-1/4");
				add_location(td2, file$q, 86, 6, 2936);
				attr_dev(td3, "class", "flex justify-center items-center py-5 w-1/4 cursor-pointer");
				add_location(td3, file$q, 96, 6, 3283);
				attr_dev(tr, "class", "border border-transparent hover:bg-osvauld-modalFieldActive text-osvauld-dusklabel hover:text-osvauld-sideListTextActive text-base font-light border-b border-b-osvauld-iconblack transition-colors duration-300");
				add_location(tr, file$q, 76, 5, 2519);
			},
			m: function mount(target, anchor) {
				insert_dev(target, tr, anchor);
				append_dev(tr, td0);
				append_dev(td0, t0);
				append_dev(tr, t1);
				append_dev(tr, td1);
				append_dev(td1, t2);
				append_dev(tr, t3);
				append_dev(tr, td2);
				append_dev(td2, span);
				append_dev(span, t4);
				append_dev(tr, t5);
				append_dev(tr, td3);
				if (if_block) if_block.m(td3, null);
				append_dev(tr, t6);
				current = true;
			},
			p: function update(ctx, dirty) {
				if ((!current || dirty & /*$groupUsers*/ 8) && t0_value !== (t0_value = /*user*/ ctx[11].name + "")) set_data_dev(t0, t0_value);
				if ((!current || dirty & /*$groupUsers*/ 8) && t2_value !== (t2_value = /*user*/ ctx[11].username + "")) set_data_dev(t2, t2_value);
				if ((!current || dirty & /*$groupUsers*/ 8) && t4_value !== (t4_value = /*user*/ ctx[11].accessType + "")) set_data_dev(t4, t4_value);

				if (!current || dirty & /*$groupUsers*/ 8 && span_class_value !== (span_class_value = "inline-block w-[70%] px-4 py-1 rounded-md text-center " + (/*user*/ ctx[11].accessType === 'admin'
				? 'bg-osvauld-ownerGreen text-osvauld-ownerText'
				: 'bg-osvauld-readerOrange text-osvauld-readerText'))) {
					attr_dev(span, "class", span_class_value);
				}

				if (/*groupAdmin*/ ctx[1]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*groupAdmin*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$k(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(td3, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(tr);
				}

				if (if_block) if_block.d();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$7.name,
			type: "each",
			source: "(71:4) {#each $groupUsers as user}",
			ctx
		});

		return block;
	}

	function create_fragment$q(ctx) {
		let div0;
		let h1;
		let t0;
		let t1;
		let t2;
		let div2;
		let table0;
		let thead;
		let tr;
		let th0;
		let t4;
		let th1;
		let t6;
		let th2;
		let t8;
		let th3;
		let t9;
		let div1;
		let table1;
		let tbody;
		let current;
		let if_block = /*groupAdmin*/ ctx[1] && create_if_block_1$g(ctx);
		let each_value = ensure_array_like_dev(/*$groupUsers*/ ctx[3]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div0 = element("div");
				h1 = element("h1");
				t0 = text(/*groupName*/ ctx[0]);
				t1 = space();
				if (if_block) if_block.c();
				t2 = space();
				div2 = element("div");
				table0 = element("table");
				thead = element("thead");
				tr = element("tr");
				th0 = element("th");
				th0.textContent = "Name";
				t4 = space();
				th1 = element("th");
				th1.textContent = "Username";
				t6 = space();
				th2 = element("th");
				th2.textContent = "Role";
				t8 = space();
				th3 = element("th");
				t9 = space();
				div1 = element("div");
				table1 = element("table");
				tbody = element("tbody");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(h1, "class", "text-4xl p-4 font-normal ml-3 w-[40rem] overflow-hidden text-ellipsis");
				add_location(h1, file$q, 42, 1, 1151);
				attr_dev(div0, "class", "flex items-center justify-between px-4 py-5 pb-0");
				add_location(div0, file$q, 41, 0, 1087);
				attr_dev(th0, "class", "py-3 px-3 text-left whitespace-nowrap w-1/4");
				add_location(th0, file$q, 65, 4, 2004);
				attr_dev(th1, "class", "py-3 px-3 text-left whitespace-nowrap w-1/4");
				add_location(th1, file$q, 66, 4, 2074);
				attr_dev(th2, "class", "py-3 px-3 text-left whitespace-nowrap w-1/4");
				add_location(th2, file$q, 67, 4, 2148);
				attr_dev(th3, "class", "py-3 px-3 text-left whitespace-nowrap w-1/4");
				add_location(th3, file$q, 68, 4, 2218);
				attr_dev(tr, "class", "leading-normal text-base font-light text-osvauld-fieldTextActive");
				add_location(tr, file$q, 62, 3, 1914);
				add_location(thead, file$q, 61, 2, 1903);
				attr_dev(table0, "class", "min-w-max w-full table-auto table-layout-fixed");
				add_location(table0, file$q, 60, 1, 1838);
				attr_dev(tbody, "class", "text-xlfont-normal text-sm");
				add_location(tbody, file$q, 74, 3, 2439);
				attr_dev(table1, "class", "min-w-max w-full table-auto table-layout-fixed");
				add_location(table1, file$q, 73, 2, 2373);
				attr_dev(div1, "class", "h-[40rem] overflow-y-auto scrollbar-thin px-2");
				add_location(div1, file$q, 72, 1, 2311);
				attr_dev(div2, "class", "rounded my-6 px-10");
				add_location(div2, file$q, 59, 0, 1804);
			},
			l: function claim(nodes) {
				throw new Error_1$3("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div0, anchor);
				append_dev(div0, h1);
				append_dev(h1, t0);
				append_dev(div0, t1);
				if (if_block) if_block.m(div0, null);
				insert_dev(target, t2, anchor);
				insert_dev(target, div2, anchor);
				append_dev(div2, table0);
				append_dev(table0, thead);
				append_dev(thead, tr);
				append_dev(tr, th0);
				append_dev(tr, t4);
				append_dev(tr, th1);
				append_dev(tr, t6);
				append_dev(tr, th2);
				append_dev(tr, t8);
				append_dev(tr, th3);
				append_dev(div2, t9);
				append_dev(div2, div1);
				append_dev(div1, table1);
				append_dev(table1, tbody);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(tbody, null);
					}
				}

				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (!current || dirty & /*groupName*/ 1) set_data_dev(t0, /*groupName*/ ctx[0]);

				if (/*groupAdmin*/ ctx[1]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*groupAdmin*/ 2) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block_1$g(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(div0, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}

				if (dirty & /*handleRemoveUserFromGroup, $groupUsers, groupAdmin*/ 26) {
					each_value = ensure_array_like_dev(/*$groupUsers*/ ctx[3]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$7(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$7(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(tbody, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div0);
					detach_dev(t2);
					detach_dev(div2);
				}

				if (if_block) if_block.d();
				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$q.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$q($$self, $$props, $$invalidate) {
		let $selectedGroup;
		let $groupUsers;
		validate_store(selectedGroup, 'selectedGroup');
		component_subscribe($$self, selectedGroup, $$value => $$invalidate(10, $selectedGroup = $$value));
		validate_store(groupUsers, 'groupUsers');
		component_subscribe($$self, groupUsers, $$value => $$invalidate(3, $groupUsers = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('OtherGroupsList', slots, []);
		let { groupName } = $$props;

		const handleRemoveUserFromGroup = async userId => {
			if ($selectedGroup === null) {
				throw new Error("Group not selected");
			}

			await removeUserFromGroup($selectedGroup.groupId, userId);
			const user = await getUserDetails();

			if (user.id === userId) {
				selectedGroup.set(null);
				await setGroupStore();
			} else {
				selectedGroup.set($selectedGroup);
			}
		};

		let groupAdmin = false;
		let addUserHovered = false;
		let unsubscribe;

		onMount(() => {
			unsubscribe = selectedGroup.subscribe(value => {
				if (value === null) return;
				$$invalidate(1, groupAdmin = value.accessType === "admin");
			});
		});

		onDestroy(() => {
			unsubscribe();
		});

		$$self.$$.on_mount.push(function () {
			if (groupName === undefined && !('groupName' in $$props || $$self.$$.bound[$$self.$$.props['groupName']])) {
				console.warn("<OtherGroupsList> was created without expected prop 'groupName'");
			}
		});

		const writable_props = ['groupName'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<OtherGroupsList> was created with unknown prop '${key}'`);
		});

		const mouseenter_handler = () => $$invalidate(2, addUserHovered = true);
		const mouseleave_handler = () => $$invalidate(2, addUserHovered = false);
		const click_handler = () => showAddUserToGroupDrawer.set(true);
		const click_handler_1 = user => handleRemoveUserFromGroup(user.id);

		$$self.$$set = $$props => {
			if ('groupName' in $$props) $$invalidate(0, groupName = $$props.groupName);
		};

		$$self.$capture_state = () => ({
			Add,
			BinIcon,
			groupUsers,
			selectedGroup,
			showAddUserToGroupDrawer,
			removeUserFromGroup,
			onMount,
			onDestroy,
			setGroupStore,
			getUserDetails,
			groupName,
			handleRemoveUserFromGroup,
			groupAdmin,
			addUserHovered,
			unsubscribe,
			$selectedGroup,
			$groupUsers
		});

		$$self.$inject_state = $$props => {
			if ('groupName' in $$props) $$invalidate(0, groupName = $$props.groupName);
			if ('groupAdmin' in $$props) $$invalidate(1, groupAdmin = $$props.groupAdmin);
			if ('addUserHovered' in $$props) $$invalidate(2, addUserHovered = $$props.addUserHovered);
			if ('unsubscribe' in $$props) unsubscribe = $$props.unsubscribe;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			groupName,
			groupAdmin,
			addUserHovered,
			$groupUsers,
			handleRemoveUserFromGroup,
			mouseenter_handler,
			mouseleave_handler,
			click_handler,
			click_handler_1
		];
	}

	class OtherGroupsList extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$q, create_fragment$q, safe_not_equal, { groupName: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "OtherGroupsList",
				options,
				id: create_fragment$q.name
			});
		}

		get groupName() {
			throw new Error_1$3("<OtherGroupsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set groupName(value) {
			throw new Error_1$3("<OtherGroupsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/groups/GroupList.svelte generated by Svelte v4.2.19 */
	const file$p = "src/lib/components/dashboard/groups/GroupList.svelte";

	// (41:1) {#if $showAddUserToGroupDrawer}
	function create_if_block_2$a(ctx) {
		let button1;
		let button0;
		let addusertogroup;
		let current;
		let mounted;
		let dispose;
		addusertogroup = new AddUserToGroup({ $$inline: true });

		const block = {
			c: function create() {
				button1 = element("button");
				button0 = element("button");
				create_component(addusertogroup.$$.fragment);
				attr_dev(button0, "class", "p-6 rounded bg-transparent");
				add_location(button0, file$p, 58, 3, 1506);
				attr_dev(button1, "class", "fixed inset-0 flex items-center justify-center z-50 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px]");
				add_location(button1, file$p, 54, 2, 1341);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button1, anchor);
				append_dev(button1, button0);
				mount_component(addusertogroup, button0, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*click_handler*/ ctx[5]), false, false, true, false),
						listen_dev(button1, "click", click_handler_1, false, false, false, false)
					];

					mounted = true;
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(addusertogroup.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(addusertogroup.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button1);
				}

				destroy_component(addusertogroup);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$a.name,
			type: "if",
			source: "(41:1) {#if $showAddUserToGroupDrawer}",
			ctx
		});

		return block;
	}

	// (59:2) {:else}
	function create_else_block$d(ctx) {
		let div;
		let placeholder;
		let current;
		placeholder = new Placeholder({ $$inline: true });

		const block = {
			c: function create() {
				div = element("div");
				create_component(placeholder.$$.fragment);
				attr_dev(div, "class", "mt-20");
				add_location(div, file$p, 72, 3, 1849);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				mount_component(placeholder, div, null);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(placeholder.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(placeholder.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(placeholder);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$d.name,
			type: "else",
			source: "(59:2) {:else}",
			ctx
		});

		return block;
	}

	// (57:27) 
	function create_if_block_1$f(ctx) {
		let othergroupslist;
		let current;

		othergroupslist = new OtherGroupsList({
				props: { groupName: /*groupName*/ ctx[0] },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(othergroupslist.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(othergroupslist, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const othergroupslist_changes = {};
				if (dirty & /*groupName*/ 1) othergroupslist_changes.groupName = /*groupName*/ ctx[0];
				othergroupslist.$set(othergroupslist_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(othergroupslist.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(othergroupslist.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(othergroupslist, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$f.name,
			type: "if",
			source: "(57:27) ",
			ctx
		});

		return block;
	}

	// (55:2) {#if adminStatus && $allUsersSelected}
	function create_if_block$j(ctx) {
		let alluserslist;
		let current;
		alluserslist = new AllUsersList({ $$inline: true });

		const block = {
			c: function create() {
				create_component(alluserslist.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(alluserslist, target, anchor);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(alluserslist.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(alluserslist.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(alluserslist, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$j.name,
			type: "if",
			source: "(55:2) {#if adminStatus && $allUsersSelected}",
			ctx
		});

		return block;
	}

	function create_fragment$p(ctx) {
		let div0;
		let t;
		let div2;
		let div1;
		let current_block_type_index;
		let if_block1;
		let current;
		let if_block0 = /*$showAddUserToGroupDrawer*/ ctx[2] && create_if_block_2$a(ctx);
		const if_block_creators = [create_if_block$j, create_if_block_1$f, create_else_block$d];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*adminStatus*/ ctx[1] && /*$allUsersSelected*/ ctx[3]) return 0;
			if (/*$selectedGroup*/ ctx[4]) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				div0 = element("div");
				if (if_block0) if_block0.c();
				t = space();
				div2 = element("div");
				div1 = element("div");
				if_block1.c();
				attr_dev(div0, "class", "z-50");
				add_location(div0, file$p, 52, 0, 1287);
				attr_dev(div1, "class", "w-full");
				add_location(div1, file$p, 66, 1, 1691);
				attr_dev(div2, "class", "min-w-screen h-[48rem] flex overflow-");
				add_location(div2, file$p, 65, 0, 1638);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div0, anchor);
				if (if_block0) if_block0.m(div0, null);
				insert_dev(target, t, anchor);
				insert_dev(target, div2, anchor);
				append_dev(div2, div1);
				if_blocks[current_block_type_index].m(div1, null);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (/*$showAddUserToGroupDrawer*/ ctx[2]) {
					if (if_block0) {
						if (dirty & /*$showAddUserToGroupDrawer*/ 4) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_2$a(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div0, null);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div1, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div0);
					detach_dev(t);
					detach_dev(div2);
				}

				if (if_block0) if_block0.d();
				if_blocks[current_block_type_index].d();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$p.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	const click_handler_1 = () => {
		
	};

	function instance$p($$self, $$props, $$invalidate) {
		let $showAddUserToGroupDrawer;
		let $allUsersSelected;
		let $selectedGroup;
		validate_store(showAddUserToGroupDrawer, 'showAddUserToGroupDrawer');
		component_subscribe($$self, showAddUserToGroupDrawer, $$value => $$invalidate(2, $showAddUserToGroupDrawer = $$value));
		validate_store(allUsersSelected, 'allUsersSelected');
		component_subscribe($$self, allUsersSelected, $$value => $$invalidate(3, $allUsersSelected = $$value));
		validate_store(selectedGroup, 'selectedGroup');
		component_subscribe($$self, selectedGroup, $$value => $$invalidate(4, $selectedGroup = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('GroupList', slots, []);
		let unsubscribe;
		let groupName = "";
		let allUsers = [];
		let adminStatus = false;

		onMount(async () => {
			const accountDetails = await getUserDetails();
			const accountRole = accountDetails.type;

			if (accountRole === "admin" || accountRole === "superadmin") {
				$$invalidate(1, adminStatus = true);
			}

			if (adminStatus) {
				fetchSignedUpUsers().then(usersResponse => {
					allUsers = usersResponse.data;
				});
			}
		});

		unsubscribe = selectedGroup.subscribe(value => {
			if (value) {
				$$invalidate(0, groupName = value.name);

				fetchGroupUsers(value.groupId).then(usersResponse => {
					groupUsers.set(usersResponse.data);
				});
			}
		});

		onDestroy(() => {
			unsubscribe();
			groupUsers.set([]);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GroupList> was created with unknown prop '${key}'`);
		});

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		$$self.$capture_state = () => ({
			onMount,
			onDestroy,
			selectedGroup,
			showAddUserToGroupDrawer,
			allUsersSelected,
			AddUserToGroup,
			groupUsers,
			fetchGroupUsers,
			fetchSignedUpUsers,
			AllUsersList,
			OtherGroupsList,
			Placeholder,
			getUserDetails,
			unsubscribe,
			groupName,
			allUsers,
			adminStatus,
			$showAddUserToGroupDrawer,
			$allUsersSelected,
			$selectedGroup
		});

		$$self.$inject_state = $$props => {
			if ('unsubscribe' in $$props) unsubscribe = $$props.unsubscribe;
			if ('groupName' in $$props) $$invalidate(0, groupName = $$props.groupName);
			if ('allUsers' in $$props) allUsers = $$props.allUsers;
			if ('adminStatus' in $$props) $$invalidate(1, adminStatus = $$props.adminStatus);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			groupName,
			adminStatus,
			$showAddUserToGroupDrawer,
			$allUsersSelected,
			$selectedGroup,
			click_handler
		];
	}

	class GroupList extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "GroupList",
				options,
				id: create_fragment$p.name
			});
		}
	}

	/* src/lib/components/dashboard/SearchModal.svelte generated by Svelte v4.2.19 */
	const file$o = "src/lib/components/dashboard/SearchModal.svelte";

	function get_each_context$6(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[13] = list[i];
		return child_ctx;
	}

	// (97:4) {#if searchResults.length !== 0}
	function create_if_block_1$e(ctx) {
		let p;
		let t0;
		let t1;
		let t2;

		const block = {
			c: function create() {
				p = element("p");
				t0 = text("Showing results for \"");
				t1 = text(/*query*/ ctx[0]);
				t2 = text("\"");
				attr_dev(p, "class", "text-osvauld-placeholderblack text-sm text-start w-1/2 pl-3");
				add_location(p, file$o, 109, 5, 3070);
			},
			m: function mount(target, anchor) {
				insert_dev(target, p, anchor);
				append_dev(p, t0);
				append_dev(p, t1);
				append_dev(p, t2);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*query*/ 1) set_data_dev(t1, /*query*/ ctx[0]);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(p);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$e.name,
			type: "if",
			source: "(97:4) {#if searchResults.length !== 0}",
			ctx
		});

		return block;
	}

	// (107:5) {#each searchResults as result}
	function create_each_block$6(ctx) {
		let button;
		let div0;
		let key;
		let t0;
		let div3;
		let div1;
		let highlight0;
		let t1;
		let span;
		let t3;
		let highlight1;
		let t4;
		let div2;
		let highlight2;
		let t5;
		let div4;
		let linkicon;
		let t6;
		let current;
		let mounted;
		let dispose;
		key = new Key({ $$inline: true });

		highlight0 = new Highlight({
				props: {
					text: /*result*/ ctx[13].name,
					query: /*query*/ ctx[0]
				},
				$$inline: true
			});

		highlight1 = new Highlight({
				props: {
					text: /*result*/ ctx[13].folderName,
					query: /*query*/ ctx[0]
				},
				$$inline: true
			});

		highlight2 = new Highlight({
				props: {
					text: /*result*/ ctx[13].domain,
					query: /*query*/ ctx[0]
				},
				$$inline: true
			});

		linkicon = new LinkIcon({ $$inline: true });

		function click_handler() {
			return /*click_handler*/ ctx[7](/*result*/ ctx[13]);
		}

		const block = {
			c: function create() {
				button = element("button");
				div0 = element("div");
				create_component(key.$$.fragment);
				t0 = space();
				div3 = element("div");
				div1 = element("div");
				create_component(highlight0.$$.fragment);
				t1 = text(" \n\t\t\t\t\t\t\t\t\t");
				span = element("span");
				span.textContent = "in folder";
				t3 = text(" \n\t\t\t\t\t\t\t\t\t");
				create_component(highlight1.$$.fragment);
				t4 = space();
				div2 = element("div");
				create_component(highlight2.$$.fragment);
				t5 = space();
				div4 = element("div");
				create_component(linkicon.$$.fragment);
				t6 = space();
				attr_dev(div0, "class", "h-full flex justify-center items-center scale-150 px-2");
				add_location(div0, file$o, 126, 7, 3672);
				add_location(span, file$o, 136, 9, 4054);
				attr_dev(div1, "class", "text-base flex font-semibold");
				add_location(div1, file$o, 134, 8, 3944);
				attr_dev(div2, "class", "text-sm font-normal");
				add_location(div2, file$o, 139, 8, 4164);
				attr_dev(div3, "class", "w-full flex flex-col justify-center items-start pl-2 max-w-full overflow-hidden text-ellipsis whitespace-nowrap");
				add_location(div3, file$o, 131, 7, 3794);
				attr_dev(div4, "class", "flex justify-center items-center");
				add_location(div4, file$o, 143, 7, 4288);
				attr_dev(button, "class", "search-result p-2 border rounded-lg border-osvauld-iconblack hover:bg-osvauld-iconblack w-full my-1 flex justify-start items-center min-h-[60px] svelte-86k1b4");
				attr_dev(button, "tabindex", "-1");
				attr_dev(button, "role", "option");
				attr_dev(button, "aria-selected", "false");
				add_location(button, file$o, 119, 6, 3366);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				append_dev(button, div0);
				mount_component(key, div0, null);
				append_dev(button, t0);
				append_dev(button, div3);
				append_dev(div3, div1);
				mount_component(highlight0, div1, null);
				append_dev(div1, t1);
				append_dev(div1, span);
				append_dev(div1, t3);
				mount_component(highlight1, div1, null);
				append_dev(div3, t4);
				append_dev(div3, div2);
				mount_component(highlight2, div2, null);
				append_dev(button, t5);
				append_dev(button, div4);
				mount_component(linkicon, div4, null);
				append_dev(button, t6);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", click_handler, false, false, false, false);
					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const highlight0_changes = {};
				if (dirty & /*searchResults*/ 2) highlight0_changes.text = /*result*/ ctx[13].name;
				if (dirty & /*query*/ 1) highlight0_changes.query = /*query*/ ctx[0];
				highlight0.$set(highlight0_changes);
				const highlight1_changes = {};
				if (dirty & /*searchResults*/ 2) highlight1_changes.text = /*result*/ ctx[13].folderName;
				if (dirty & /*query*/ 1) highlight1_changes.query = /*query*/ ctx[0];
				highlight1.$set(highlight1_changes);
				const highlight2_changes = {};
				if (dirty & /*searchResults*/ 2) highlight2_changes.text = /*result*/ ctx[13].domain;
				if (dirty & /*query*/ 1) highlight2_changes.query = /*query*/ ctx[0];
				highlight2.$set(highlight2_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(key.$$.fragment, local);
				transition_in(highlight0.$$.fragment, local);
				transition_in(highlight1.$$.fragment, local);
				transition_in(highlight2.$$.fragment, local);
				transition_in(linkicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(key.$$.fragment, local);
				transition_out(highlight0.$$.fragment, local);
				transition_out(highlight1.$$.fragment, local);
				transition_out(highlight2.$$.fragment, local);
				transition_out(linkicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(key);
				destroy_component(highlight0);
				destroy_component(highlight1);
				destroy_component(highlight2);
				destroy_component(linkicon);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$6.name,
			type: "each",
			source: "(107:5) {#each searchResults as result}",
			ctx
		});

		return block;
	}

	// (138:4) {#if searchResults.length === 0}
	function create_if_block$i(ctx) {
		let div;
		let p;

		const block = {
			c: function create() {
				div = element("div");
				p = element("p");
				p.textContent = "Try searching for keywords in credentials, folders, groups,\n\t\t\t\t\t\t\tdescriptions and more";
				attr_dev(p, "class", "text-osvauld-placeholderblack text-base text-center w-[80%]");
				add_location(p, file$o, 153, 6, 4597);
				attr_dev(div, "class", "bg-osvauld-frameblack w-full flex justify-center items-center px-4 mb-4 py-0 sm:px-6 sm:flex sm:flex-row-reverse");
				add_location(div, file$o, 150, 5, 4452);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, p);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$i.name,
			type: "if",
			source: "(138:4) {#if searchResults.length === 0}",
			ctx
		});

		return block;
	}

	function create_fragment$o(ctx) {
		let button1;
		let div5;
		let button0;
		let t0;
		let div4;
		let div0;
		let lens;
		let t1;
		let input;
		let t2;
		let div1;
		let t3;
		let div3;
		let t4;
		let div2;
		let t5;
		let current;
		let mounted;
		let dispose;
		lens = new Lens({ $$inline: true });
		let if_block0 = /*searchResults*/ ctx[1].length !== 0 && create_if_block_1$e(ctx);
		let each_value = ensure_array_like_dev(/*searchResults*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let if_block1 = /*searchResults*/ ctx[1].length === 0 && create_if_block$i(ctx);

		const block = {
			c: function create() {
				button1 = element("button");
				div5 = element("div");
				button0 = element("button");
				button0.innerHTML = ``;
				t0 = space();
				div4 = element("div");
				div0 = element("div");
				create_component(lens.$$.fragment);
				t1 = space();
				input = element("input");
				t2 = space();
				div1 = element("div");
				t3 = space();
				div3 = element("div");
				if (if_block0) if_block0.c();
				t4 = space();
				div2 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t5 = space();
				if (if_block1) if_block1.c();
				attr_dev(button0, "class", "fixed inset-0 bg-black opacity-50");
				add_location(button0, file$o, 84, 2, 2017);
				attr_dev(input, "type", "text");
				attr_dev(input, "class", "h-[2rem] w-full bg-osvauld-frameblack border-0 text-osvauld-quarzowhite placeholder-osvauld-placeholderblack border-transparent text-base focus:border-transparent focus:ring-0 cursor-pointer");
				attr_dev(input, "placeholder", "Search..");
				add_location(input, file$o, 93, 4, 2500);
				attr_dev(div0, "class", "h-[2.2rem] w-[31.25rem] px-2 flex m-auto mt-2 justify-center items-center border border-osvauld-iconblack focus-within:border-osvauld-activeBorder rounded-lg cursor-pointer");
				add_location(div0, file$o, 89, 3, 2288);
				attr_dev(div1, "class", "w-full border-t-[1px] border-osvauld-iconblack my-2");
				add_location(div1, file$o, 102, 3, 2857);
				attr_dev(div2, "class", "max-h-64 min-h-32 overflow-y-auto flex justify-start items-center flex-col mb-4 px-3");
				add_location(div2, file$o, 115, 4, 3214);
				attr_dev(div3, "class", "bg-osvauld-frameblack");
				attr_dev(div3, "role", "listbox");
				attr_dev(div3, "aria-label", "Search results");
				add_location(div3, file$o, 103, 3, 2932);
				attr_dev(div4, "class", "bg-osvauld-frameblack border border-osvauld-iconblack rounded-lg overflow-hidden shadow-xl transform transition-all sm:max-w-2xl sm:w-full !w-[40vw] ml-[10vw]");
				add_location(div4, file$o, 86, 2, 2106);
				attr_dev(div5, "class", "flex items-start justify-center min-h-screen mt-[2.6vh]");
				add_location(div5, file$o, 83, 1, 1945);
				attr_dev(button1, "class", "fixed z-10 inset-0 backdrop-filter backdrop-blur-[2px]");
				add_location(button1, file$o, 79, 0, 1840);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, button1, anchor);
				append_dev(button1, div5);
				append_dev(div5, button0);
				append_dev(div5, t0);
				append_dev(div5, div4);
				append_dev(div4, div0);
				mount_component(lens, div0, null);
				append_dev(div0, t1);
				append_dev(div0, input);
				set_input_value(input, /*query*/ ctx[0]);
				append_dev(div4, t2);
				append_dev(div4, div1);
				append_dev(div4, t3);
				append_dev(div4, div3);
				if (if_block0) if_block0.m(div3, null);
				append_dev(div3, t4);
				append_dev(div3, div2);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div2, null);
					}
				}

				append_dev(div3, t5);
				if (if_block1) if_block1.m(div3, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", /*closeModal*/ ctx[2], false, false, false, false),
						action_destroyer(autofocus$3.call(null, input)),
						listen_dev(input, "keyup", /*handleInputChange*/ ctx[3], false, false, false, false),
						listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
						listen_dev(button1, "keydown", /*handleKeyDown*/ ctx[5], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*query*/ 1 && input.value !== /*query*/ ctx[0]) {
					set_input_value(input, /*query*/ ctx[0]);
				}

				if (/*searchResults*/ ctx[1].length !== 0) {
					if (if_block0) {
						if_block0.p(ctx, dirty);
					} else {
						if_block0 = create_if_block_1$e(ctx);
						if_block0.c();
						if_block0.m(div3, t4);
					}
				} else if (if_block0) {
					if_block0.d(1);
					if_block0 = null;
				}

				if (dirty & /*handleSearchClick, searchResults, query*/ 19) {
					each_value = ensure_array_like_dev(/*searchResults*/ ctx[1]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$6(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$6(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div2, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}

				if (/*searchResults*/ ctx[1].length === 0) {
					if (if_block1) ; else {
						if_block1 = create_if_block$i(ctx);
						if_block1.c();
						if_block1.m(div3, null);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(lens.$$.fragment, local);

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(lens.$$.fragment, local);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button1);
				}

				destroy_component(lens);
				if (if_block0) if_block0.d();
				destroy_each(each_blocks, detaching);
				if (if_block1) if_block1.d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$o.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function autofocus$3(node) {
		node.focus();
	}

	function instance$o($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('SearchModal', slots, []);
		let { searchResults = [] } = $$props;
		let { query = "" } = $$props;
		const dispatch = createEventDispatcher();

		const closeModal = () => {
			dispatch("close", true);
		};

		const handleInputChange = () => {
			dispatch("change", query);
		};

		const handleSearchClick = result => {
			dispatch("select", result);
		};

		const handleKeyDown = event => {
			if (event.key === "Escape") {
				closeModal();
			} else if (event.key === "ArrowDown") {
				event.preventDefault();
				focusNextResult();
			} else if (event.key === "ArrowUp") {
				event.preventDefault();
				focusPreviousResult();
			} else if (event.key === "Enter") {
				event.preventDefault();

				if (currentFocusIndex !== -1) {
					handleSearchClick(searchResults[currentFocusIndex]);
				}
			}
		};

		let currentFocusIndex = -1;

		const focusNextResult = () => {
			if (currentFocusIndex < searchResults.length - 1) {
				currentFocusIndex++;
				focusResult(currentFocusIndex);
			}
		};

		const focusPreviousResult = () => {
			if (currentFocusIndex > 0) {
				currentFocusIndex--;
				focusResult(currentFocusIndex);
			}
		};

		const focusResult = index => {
			const resultElements = document.querySelectorAll(".search-result");

			if (resultElements[index]) {
				resultElements[index].focus();
				resultElements[index].setAttribute("aria-selected", "true");

				if (currentFocusIndex !== -1 && currentFocusIndex !== index) {
					resultElements[currentFocusIndex].setAttribute("aria-selected", "false");
				}
			}
		};

		const writable_props = ['searchResults', 'query'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SearchModal> was created with unknown prop '${key}'`);
		});

		function input_input_handler() {
			query = this.value;
			$$invalidate(0, query);
		}

		const click_handler = result => handleSearchClick(result);

		$$self.$$set = $$props => {
			if ('searchResults' in $$props) $$invalidate(1, searchResults = $$props.searchResults);
			if ('query' in $$props) $$invalidate(0, query = $$props.query);
		};

		$$self.$capture_state = () => ({
			Key,
			Lens,
			Highlight,
			LinkIcon,
			createEventDispatcher,
			searchResults,
			query,
			dispatch,
			closeModal,
			handleInputChange,
			handleSearchClick,
			handleKeyDown,
			currentFocusIndex,
			focusNextResult,
			focusPreviousResult,
			focusResult,
			autofocus: autofocus$3
		});

		$$self.$inject_state = $$props => {
			if ('searchResults' in $$props) $$invalidate(1, searchResults = $$props.searchResults);
			if ('query' in $$props) $$invalidate(0, query = $$props.query);
			if ('currentFocusIndex' in $$props) currentFocusIndex = $$props.currentFocusIndex;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			query,
			searchResults,
			closeModal,
			handleInputChange,
			handleSearchClick,
			handleKeyDown,
			input_input_handler,
			click_handler
		];
	}

	class SearchModal extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$o, create_fragment$o, safe_not_equal, { searchResults: 1, query: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "SearchModal",
				options,
				id: create_fragment$o.name
			});
		}

		get searchResults() {
			throw new Error("<SearchModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set searchResults(value) {
			throw new Error("<SearchModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get query() {
			throw new Error("<SearchModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set query(value) {
			throw new Error("<SearchModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/credentials/AddCredentialToEnv.svelte generated by Svelte v4.2.19 */

	const { Error: Error_1$2 } = globals;
	const file$n = "src/lib/components/dashboard/credentials/AddCredentialToEnv.svelte";

	function get_each_context$5(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[16] = list[i];
		return child_ctx;
	}

	// (171:4) {#each searchResults as result}
	function create_each_block$5(ctx) {
		let li;
		let label;
		let input;
		let t0;
		let span;
		let t1_value = /*result*/ ctx[16].name + "";
		let t1;
		let t2;
		let mounted;
		let dispose;

		function change_handler(...args) {
			return /*change_handler*/ ctx[11](/*result*/ ctx[16], ...args);
		}

		const block = {
			c: function create() {
				li = element("li");
				label = element("label");
				input = element("input");
				t0 = space();
				span = element("span");
				t1 = text(t1_value);
				t2 = space();
				attr_dev(input, "type", "checkbox");
				attr_dev(input, "class", "mr-2 bg-osvauld-cardshade checked:bg-osvauld-activelavender focus:text-osvauld-activelavender hover:text-osvauld-activelavender active:outline-none focus:ring-offset-0 focus:ring-0 cursor-pointer svelte-12kbqpt");
				add_location(input, file$n, 187, 7, 5438);
				attr_dev(span, "class", "text-base");
				add_location(span, file$n, 193, 7, 5774);
				attr_dev(label, "class", "flex items-center justify-start w-full text-left pl-2 cursor-pointer");
				add_location(label, file$n, 184, 6, 5332);
				attr_dev(li, "class", "py-1.5 px-1 mx-1 overflow-hidden text-osvauld-sheffieldgrey rounded-md hover:text-osvauld-textActive hover:shadow-[0_0_0_1px_#292A36] cursor-pointer w-[95%]");
				add_location(li, file$n, 181, 5, 5144);
			},
			m: function mount(target, anchor) {
				insert_dev(target, li, anchor);
				append_dev(li, label);
				append_dev(label, input);
				append_dev(label, t0);
				append_dev(label, span);
				append_dev(span, t1);
				append_dev(li, t2);

				if (!mounted) {
					dispose = listen_dev(input, "change", change_handler, false, false, false, false);
					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				if (dirty & /*searchResults*/ 4 && t1_value !== (t1_value = /*result*/ ctx[16].name + "")) set_data_dev(t1, t1_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(li);
				}

				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$5.name,
			type: "each",
			source: "(171:4) {#each searchResults as result}",
			ctx
		});

		return block;
	}

	function create_fragment$n(ctx) {
		let div5;
		let div4;
		let div0;
		let span;
		let t0;
		let button0;
		let closepanel;
		let t1;
		let div1;
		let lens;
		let t2;
		let input;
		let t3;
		let div2;
		let ul;
		let t4;
		let div3;
		let button1;
		let t6;
		let button2;
		let t7;
		let button2_class_value;
		let button2_disabled_value;
		let div5_intro;
		let div5_outro;
		let current;
		let mounted;
		let dispose;
		closepanel = new ClosePanel({ $$inline: true });
		lens = new Lens({ $$inline: true });
		let each_value = ensure_array_like_dev(/*searchResults*/ ctx[2]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
		}

		const block = {
			c: function create() {
				div5 = element("div");
				div4 = element("div");
				div0 = element("div");
				span = element("span");
				t0 = text("Add credentials\n\n\t\t\t\t");
				button0 = element("button");
				create_component(closepanel.$$.fragment);
				t1 = space();
				div1 = element("div");
				create_component(lens.$$.fragment);
				t2 = space();
				input = element("input");
				t3 = space();
				div2 = element("div");
				ul = element("ul");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				t4 = space();
				div3 = element("div");
				button1 = element("button");
				button1.textContent = "Cancel";
				t6 = space();
				button2 = element("button");
				t7 = text("Add to environment");
				attr_dev(button0, "class", "p-2");
				add_location(button0, file$n, 159, 4, 4320);
				attr_dev(span, "class", "w-full font-sans text-osvauld-quarzowhite text-xl font-normal flex justify-between items-center");
				add_location(span, file$n, 155, 3, 4180);
				attr_dev(div0, "class", "flex justify-between items-center p-3 pt-0 w-full");
				add_location(div0, file$n, 154, 2, 4113);
				attr_dev(input, "type", "text");
				attr_dev(input, "class", "h-[2rem] w-full bg-osvauld-frameblack border-0 text-osvauld-quarzowhite placeholder-osvauld-placeholderblack border-transparent text-base focus:border-transparent focus:ring-0 cursor-pointer");
				attr_dev(input, "placeholder", "Search..");
				add_location(input, file$n, 168, 3, 4636);
				attr_dev(div1, "class", "h-[2.2rem] w-full px-2 mx-auto mb-2 flex justify-start items-center border border-osvauld-iconblack focus-within:border-osvauld-activeBorder rounded-lg cursor-pointer");
				add_location(div1, file$n, 164, 2, 4434);
				add_location(ul, file$n, 179, 3, 5098);
				attr_dev(div2, "class", "overflow-y-scroll scrollbar-thin h-[20rem] pt-2 pb-4");
				add_location(div2, file$n, 178, 2, 5028);
				attr_dev(button1, "class", "text-base py-[5px] px-[15px] rounded-md hover:bg-osvauld-cancelBackground hover:text-osvauld-quarzowhite text-osvauld-fadedCancel");
				add_location(button1, file$n, 202, 3, 5968);

				attr_dev(button2, "class", button2_class_value = "ml-4 px-3 py-2 whitespace-nowrap text-sm font-medium rounded-md " + (/*saveEnabled*/ ctx[0]
				? 'bg-osvauld-carolinablue text-osvauld-frameblack border-transparent'
				: 'border border-osvauld-iconblack text-osvauld-textActive'));

				button2.disabled = button2_disabled_value = !/*saveEnabled*/ ctx[0];
				add_location(button2, file$n, 207, 3, 6184);
				attr_dev(div3, "class", "p-2 w-full flex justify-end items-center box-border mt-0");
				add_location(div3, file$n, 201, 2, 5894);
				attr_dev(div4, "class", "w-[32.25rem] min-h-[34.375rem] max-h-[37rem] rounded-2xl translate-x-0 bg-osvauld-frameblack p-7 flex flex-col");
				add_location(div4, file$n, 151, 1, 3982);
				attr_dev(div5, "class", "fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 flex justify-end rounded-2xl border border-osvauld-activeBorder");
				add_location(div5, file$n, 146, 0, 3812);
			},
			l: function claim(nodes) {
				throw new Error_1$2("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div5, anchor);
				append_dev(div5, div4);
				append_dev(div4, div0);
				append_dev(div0, span);
				append_dev(span, t0);
				append_dev(span, button0);
				mount_component(closepanel, button0, null);
				append_dev(div4, t1);
				append_dev(div4, div1);
				mount_component(lens, div1, null);
				append_dev(div1, t2);
				append_dev(div1, input);
				set_input_value(input, /*query*/ ctx[1]);
				append_dev(div4, t3);
				append_dev(div4, div2);
				append_dev(div2, ul);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(ul, null);
					}
				}

				append_dev(div4, t4);
				append_dev(div4, div3);
				append_dev(div3, button1);
				append_dev(div3, t6);
				append_dev(div3, button2);
				append_dev(button2, t7);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", /*click_handler*/ ctx[9], false, false, false, false),
						listen_dev(input, "click", /*getSearchData*/ ctx[6], false, false, false, false),
						listen_dev(input, "input", /*handleInputChange*/ ctx[7], false, false, false, false),
						listen_dev(input, "input", /*input_input_handler*/ ctx[10]),
						listen_dev(input, "keyup", /*handleKeyDown*/ ctx[4], false, false, false, false),
						listen_dev(button1, "click", /*click_handler_1*/ ctx[12], false, false, false, false),
						listen_dev(button2, "click", /*addCredentialToEnv*/ ctx[8], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*query*/ 2 && input.value !== /*query*/ ctx[1]) {
					set_input_value(input, /*query*/ ctx[1]);
				}

				if (dirty & /*searchResults, toggleFolder*/ 36) {
					each_value = ensure_array_like_dev(/*searchResults*/ ctx[2]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$5(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$5(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}

				if (!current || dirty & /*saveEnabled*/ 1 && button2_class_value !== (button2_class_value = "ml-4 px-3 py-2 whitespace-nowrap text-sm font-medium rounded-md " + (/*saveEnabled*/ ctx[0]
				? 'bg-osvauld-carolinablue text-osvauld-frameblack border-transparent'
				: 'border border-osvauld-iconblack text-osvauld-textActive'))) {
					attr_dev(button2, "class", button2_class_value);
				}

				if (!current || dirty & /*saveEnabled*/ 1 && button2_disabled_value !== (button2_disabled_value = !/*saveEnabled*/ ctx[0])) {
					prop_dev(button2, "disabled", button2_disabled_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closepanel.$$.fragment, local);
				transition_in(lens.$$.fragment, local);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (div5_outro) div5_outro.end(1);
						div5_intro = create_in_transition(div5, fly, {});
						div5_intro.start();
					});
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(closepanel.$$.fragment, local);
				transition_out(lens.$$.fragment, local);
				if (div5_intro) div5_intro.invalidate();

				if (local) {
					div5_outro = create_out_transition(div5, fly, {});
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div5);
				}

				destroy_component(closepanel);
				destroy_component(lens);
				destroy_each(each_blocks, detaching);
				if (detaching && div5_outro) div5_outro.end();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$n.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$n($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('AddCredentialToEnv', slots, []);
		let saveEnabled = false;
		let query = "";
		let selectedEnvironment;
		const dispatch = createEventDispatcher();

		const handleKeyDown = event => {
			if (event.key === "Escape") {
				dispatch("close");
			}
		};

		let searchData = [];
		let searchResults = [];
		let checkedCredentials = new Set();

		function toggleFolder(result, event) {
			if (event.target.checked) {
				checkedCredentials.add(result);
			} else {
				checkedCredentials.delete(result);
			}

			if (checkedCredentials.size === 0) {
				$$invalidate(0, saveEnabled = false);
			} else if (checkedCredentials.size > 0 && !saveEnabled) {
				$$invalidate(0, saveEnabled = true);
			}
		}

		const getSearchData = async () => {
			const searchFieldSResponse = await getSearchFields();
			searchData = searchFieldSResponse.data;
			$$invalidate(2, searchResults = searchData);
		};

		const handleInputChange = async e => {
			const query = e.type === "input" ? e.target.value : e.detail;

			if (query.length === 0) {
				await getSearchData();
			} else {
				$$invalidate(2, searchResults = searchObjects(query, searchData));
			}
		};

		const addCredentialToEnv = async () => {
			const credentialIds = Array.from(checkedCredentials).map(credential => credential.credentialId);
			const responseJson = await fetchCredentialsFieldsByIds(credentialIds);

			const encryptedCreds = await sendMessage("createShareCredPayload", {
				creds: responseJson.data,
				users: [
					{
						id: selectedEnvironment.cliUser,
						publicKey: selectedEnvironment.publicKey
					}
				]
			});

			let shareCredentialsWithEnvResponse = await shareCredentialsWithEnv({
				...encryptedCreds[0],
				envId: selectedEnvironment.id
			});

			if (shareCredentialsWithEnvResponse.success) {
				toastStore.set({
					type: shareCredentialsWithEnvResponse.success,
					message: shareCredentialsWithEnvResponse.message,
					show: true
				});
			}

			dispatch("close");
		};

		onMount(async () => {
			window.addEventListener("keydown", handleKeyDown);
			await getSearchData();
			const value = get_store_value(selectedEnv);

			if (value) {
				selectedEnvironment = value;
			} else {
				dispatch("close");
				throw new Error("No environment selected");
			}
		});

		onDestroy(() => {
			window.removeEventListener("keydown", handleKeyDown);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AddCredentialToEnv> was created with unknown prop '${key}'`);
		});

		const click_handler = () => dispatch('close');

		function input_input_handler() {
			query = this.value;
			$$invalidate(1, query);
		}

		const change_handler = (result, event) => toggleFolder(result, event);
		const click_handler_1 = () => dispatch('close');

		$$self.$capture_state = () => ({
			onMount,
			onDestroy,
			createEventDispatcher,
			getSearchFields,
			fetchCredentialsFieldsByIds,
			shareCredentialsWithEnv,
			fly,
			ClosePanel,
			searchObjects,
			sendMessage,
			Lens,
			selectedEnv,
			toastStore,
			get: get_store_value,
			saveEnabled,
			query,
			selectedEnvironment,
			dispatch,
			handleKeyDown,
			searchData,
			searchResults,
			checkedCredentials,
			toggleFolder,
			getSearchData,
			handleInputChange,
			addCredentialToEnv
		});

		$$self.$inject_state = $$props => {
			if ('saveEnabled' in $$props) $$invalidate(0, saveEnabled = $$props.saveEnabled);
			if ('query' in $$props) $$invalidate(1, query = $$props.query);
			if ('selectedEnvironment' in $$props) selectedEnvironment = $$props.selectedEnvironment;
			if ('searchData' in $$props) searchData = $$props.searchData;
			if ('searchResults' in $$props) $$invalidate(2, searchResults = $$props.searchResults);
			if ('checkedCredentials' in $$props) checkedCredentials = $$props.checkedCredentials;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			saveEnabled,
			query,
			searchResults,
			dispatch,
			handleKeyDown,
			toggleFolder,
			getSearchData,
			handleInputChange,
			addCredentialToEnv,
			click_handler,
			input_input_handler,
			change_handler,
			click_handler_1
		];
	}

	class AddCredentialToEnv extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$n, create_fragment$n, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "AddCredentialToEnv",
				options,
				id: create_fragment$n.name
			});
		}
	}

	/* src/lib/components/dashboard/credentials/AddCliUser.svelte generated by Svelte v4.2.19 */

	const { console: console_1 } = globals;
	const file$m = "src/lib/components/dashboard/credentials/AddCliUser.svelte";

	// (102:1) {#if userString.length !== 0}
	function create_if_block_3$6(ctx) {
		let div2;
		let div0;
		let warning;
		let t0;
		let div1;
		let t2;
		let label;
		let t4;
		let div3;
		let t5;
		let current;
		warning = new Warning({ $$inline: true });

		const block = {
			c: function create() {
				div2 = element("div");
				div0 = element("div");
				create_component(warning.$$.fragment);
				t0 = space();
				div1 = element("div");
				div1.textContent = "Copy user key secret (info)";
				t2 = space();
				label = element("label");
				label.textContent = "Copy the user string:";
				t4 = space();
				div3 = element("div");
				t5 = text(/*userString*/ ctx[1]);
				attr_dev(div0, "class", "justify-center items-center flex");
				add_location(div0, file$m, 115, 3, 3316);
				attr_dev(div1, "class", "text-osvauld-textActive text-left");
				add_location(div1, file$m, 118, 3, 3392);
				attr_dev(div2, "class", "w-[95%] font-normal text-base flex justify-start items-center border border-osvauld-iconblack bg-osvauld-fieldActive rounded-lg gap-3 p-2 mx-2");
				add_location(div2, file$m, 113, 2, 3152);
				attr_dev(label, "for", "name");
				attr_dev(label, "class", "font-light text-sm text-osvauld-textActive");
				add_location(label, file$m, 122, 2, 3493);
				attr_dev(div3, "class", "py-1 rounded-md items-center text-base text-osvauld-textActive bg-osvauld-frameblack border-osvauld-iconblack w-[95%] h-10 mx-2 text-ellipsis whitespace-nowrap overflow-hidden");
				add_location(div3, file$m, 125, 2, 3601);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div2, anchor);
				append_dev(div2, div0);
				mount_component(warning, div0, null);
				append_dev(div2, t0);
				append_dev(div2, div1);
				insert_dev(target, t2, anchor);
				insert_dev(target, label, anchor);
				insert_dev(target, t4, anchor);
				insert_dev(target, div3, anchor);
				append_dev(div3, t5);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (!current || dirty & /*userString*/ 2) set_data_dev(t5, /*userString*/ ctx[1]);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(warning.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(warning.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div2);
					detach_dev(t2);
					detach_dev(label);
					detach_dev(t4);
					detach_dev(div3);
				}

				destroy_component(warning);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$6.name,
			type: "if",
			source: "(102:1) {#if userString.length !== 0}",
			ctx
		});

		return block;
	}

	// (136:2) {:else}
	function create_else_block$c(ctx) {
		let button;
		let t;
		let current_block_type_index;
		let if_block1;
		let current;
		let mounted;
		let dispose;

		function select_block_type_1(ctx, dirty) {
			if (/*userStringCopied*/ ctx[2]) return create_if_block_2$9;
			return create_else_block_2$4;
		}

		let current_block_type = select_block_type_1(ctx);
		let if_block0 = current_block_type(ctx);
		const if_block_creators = [create_if_block_1$d, create_else_block_1$8];
		const if_blocks = [];

		function select_block_type_2(ctx, dirty) {
			if (/*userStringCopied*/ ctx[2]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_2(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				button = element("button");
				if_block0.c();
				t = space();
				if_block1.c();
				attr_dev(button, "class", "border border-osvauld-iconblack py-[5px] px-[15px] text-base font-normal text-osvauld-textActive rounded-md flex justify-between flex-nowrap gap-1");
				attr_dev(button, "type", "submit");
				add_location(button, file$m, 147, 3, 4595);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				if_block0.m(button, null);
				append_dev(button, t);
				if_blocks[current_block_type_index].m(button, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(button, "click", prevent_default(/*finishSetup*/ ctx[4]), false, true, false, false);
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
					if_block0.d(1);
					if_block0 = current_block_type(ctx);

					if (if_block0) {
						if_block0.c();
						if_block0.m(button, t);
					}
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_2(ctx);

				if (current_block_type_index !== previous_block_index) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					}

					transition_in(if_block1, 1);
					if_block1.m(button, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block1);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block1);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				if_block0.d();
				if_blocks[current_block_type_index].d();
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$c.name,
			type: "else",
			source: "(136:2) {:else}",
			ctx
		});

		return block;
	}

	// (128:2) {#if userString.length === 0}
	function create_if_block$h(ctx) {
		let button;
		let t;
		let button_disabled_value;
		let mounted;
		let dispose;

		const block = {
			c: function create() {
				button = element("button");
				t = text("Add CLI User");
				attr_dev(button, "class", "border border-osvauld-iconblack py-[5px] px-[15px] text-base font-normal text-osvauld-textActive rounded-md hover:border-osvauld-carolinablue hover:text-osvauld-frameblack hover:bg-osvauld-carolinablue");
				attr_dev(button, "type", "submit");
				button.disabled = button_disabled_value = /*name*/ ctx[0] === '';
				add_location(button, file$m, 139, 3, 4236);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				append_dev(button, t);

				if (!mounted) {
					dispose = listen_dev(button, "click", prevent_default(/*createCliUser*/ ctx[5]), false, true, false, false);
					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (dirty & /*name*/ 1 && button_disabled_value !== (button_disabled_value = /*name*/ ctx[0] === '')) {
					prop_dev(button, "disabled", button_disabled_value);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$h.name,
			type: "if",
			source: "(128:2) {#if userString.length === 0}",
			ctx
		});

		return block;
	}

	// (143:4) {:else}
	function create_else_block_2$4(ctx) {
		let span;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = "Copy Secret info";
				attr_dev(span, "class", "w-[7.5rem] whitespace-nowrap");
				add_location(span, file$m, 154, 5, 4936);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_2$4.name,
			type: "else",
			source: "(143:4) {:else}",
			ctx
		});

		return block;
	}

	// (141:4) {#if userStringCopied}
	function create_if_block_2$9(ctx) {
		let span;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = "Copied";
				attr_dev(span, "class", "text-osvauld-tickGreen w-[7.5rem]");
				add_location(span, file$m, 152, 5, 4857);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$9.name,
			type: "if",
			source: "(141:4) {#if userStringCopied}",
			ctx
		});

		return block;
	}

	// (150:4) {:else}
	function create_else_block_1$8(ctx) {
		let copyicon;
		let current;

		copyicon = new CopyIcon({
				props: { color: '#4D4F60' },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(copyicon.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(copyicon, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(copyicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(copyicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(copyicon, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_1$8.name,
			type: "else",
			source: "(150:4) {:else}",
			ctx
		});

		return block;
	}

	// (146:4) {#if userStringCopied}
	function create_if_block_1$d(ctx) {
		let span;
		let tick_1;
		let span_intro;
		let current;
		tick_1 = new Tick({ $$inline: true });

		const block = {
			c: function create() {
				span = element("span");
				create_component(tick_1.$$.fragment);
				add_location(span, file$m, 157, 5, 5045);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				mount_component(tick_1, span, null);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(tick_1.$$.fragment, local);

				if (local) {
					if (!span_intro) {
						add_render_callback(() => {
							span_intro = create_in_transition(span, scale, {});
							span_intro.start();
						});
					}
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(tick_1.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				destroy_component(tick_1);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$d.name,
			type: "if",
			source: "(146:4) {#if userStringCopied}",
			ctx
		});

		return block;
	}

	function create_fragment$m(ctx) {
		let form;
		let div0;
		let span;
		let t1;
		let button0;
		let closepanel;
		let t2;
		let div1;
		let t3;
		let label;
		let t5;
		let input;
		let input_disabled_value;
		let t6;
		let t7;
		let div2;
		let t8;
		let div3;
		let button1;
		let t10;
		let current_block_type_index;
		let if_block1;
		let current;
		let mounted;
		let dispose;
		closepanel = new ClosePanel({ $$inline: true });
		let if_block0 = /*userString*/ ctx[1].length !== 0 && create_if_block_3$6(ctx);
		const if_block_creators = [create_if_block$h, create_else_block$c];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*userString*/ ctx[1].length === 0) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				form = element("form");
				div0 = element("div");
				span = element("span");
				span.textContent = "Create Cli User";
				t1 = space();
				button0 = element("button");
				create_component(closepanel.$$.fragment);
				t2 = space();
				div1 = element("div");
				div1.innerHTML = ``;
				t3 = space();
				label = element("label");
				label.textContent = "Name:";
				t5 = space();
				input = element("input");
				t6 = space();
				if (if_block0) if_block0.c();
				t7 = space();
				div2 = element("div");
				div2.innerHTML = ``;
				t8 = space();
				div3 = element("div");
				button1 = element("button");
				button1.textContent = "Cancel";
				t10 = space();
				if_block1.c();
				attr_dev(span, "class", "text-[21px] font-medium text-osvauld-quarzowhite");
				add_location(span, file$m, 91, 2, 2416);
				attr_dev(button0, "class", "cursor-pointer p-2");
				add_location(button0, file$m, 93, 2, 2508);
				attr_dev(div0, "class", "flex justify-between items-center w-full");
				add_location(div0, file$m, 90, 1, 2359);
				attr_dev(div1, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div1, file$m, 97, 1, 2623);
				attr_dev(label, "for", "name");
				attr_dev(label, "class", "font-light text-sm text-osvauld-textActive");
				add_location(label, file$m, 101, 1, 2718);
				attr_dev(input, "id", "name");
				attr_dev(input, "type", "text");
				input.required = true;
				input.disabled = input_disabled_value = /*userString*/ ctx[1].length !== 0;
				attr_dev(input, "class", "py-1 rounded-md items-center text-base bg-osvauld-frameblack border-osvauld-iconblack w-[95%] h-10 mx-2 focus:border-osvauld-iconblack focus:ring-0 form-input");
				attr_dev(input, "autocomplete", "off");
				add_location(input, file$m, 103, 1, 2805);
				attr_dev(div2, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div2, file$m, 130, 1, 3827);
				attr_dev(button1, "class", "font-medium text-base py-[5px] px-[15px] rounded-md hover:bg-osvauld-cancelBackground hover:text-osvauld-quarzowhite text-osvauld-fadedCancel");
				add_location(button1, file$m, 135, 2, 3981);
				attr_dev(div3, "class", "flex justify-end items-center gap-4 w-full");
				add_location(div3, file$m, 134, 1, 3922);
				attr_dev(form, "class", "p-4 bg-osvauld-frameblack border border-osvauld-activeBorder rounded-3xl w-[32rem] h-[20rem] flex flex-col items-start justify-around");
				add_location(form, file$m, 87, 0, 2164);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, form, anchor);
				append_dev(form, div0);
				append_dev(div0, span);
				append_dev(div0, t1);
				append_dev(div0, button0);
				mount_component(closepanel, button0, null);
				append_dev(form, t2);
				append_dev(form, div1);
				append_dev(form, t3);
				append_dev(form, label);
				append_dev(form, t5);
				append_dev(form, input);
				set_input_value(input, /*name*/ ctx[0]);
				append_dev(form, t6);
				if (if_block0) if_block0.m(form, null);
				append_dev(form, t7);
				append_dev(form, div2);
				append_dev(form, t8);
				append_dev(form, div3);
				append_dev(div3, button1);
				append_dev(div3, t10);
				if_blocks[current_block_type_index].m(div3, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", prevent_default(/*handleClose*/ ctx[3]), false, true, false, false),
						action_destroyer(autofocus$2.call(null, input)),
						listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
						listen_dev(button1, "click", prevent_default(/*handleClose*/ ctx[3]), false, true, false, false),
						listen_dev(form, "submit", prevent_default(/*createCliUser*/ ctx[5]), false, true, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (!current || dirty & /*userString*/ 2 && input_disabled_value !== (input_disabled_value = /*userString*/ ctx[1].length !== 0)) {
					prop_dev(input, "disabled", input_disabled_value);
				}

				if (dirty & /*name*/ 1 && input.value !== /*name*/ ctx[0]) {
					set_input_value(input, /*name*/ ctx[0]);
				}

				if (/*userString*/ ctx[1].length !== 0) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*userString*/ 2) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_3$6(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(form, t7);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div3, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closepanel.$$.fragment, local);
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o: function outro(local) {
				transition_out(closepanel.$$.fragment, local);
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(form);
				}

				destroy_component(closepanel);
				if (if_block0) if_block0.d();
				if_blocks[current_block_type_index].d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$m.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function autofocus$2(node) {
		node.focus();
	}

	function instance$m($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('AddCliUser', slots, []);
		let name = "";
		let userString = "";
		let userStringCopied = false;
		let timer;

		const handleClose = () => {
			showAddCliDrawer.set(false);
		};

		const copyToClipboard = async () => {
			try {
				await writeToClipboard(userString);
				$$invalidate(2, userStringCopied = true);
			} catch(err) {
				console.error("Failed to copy: ", err);
				$$invalidate(2, userStringCopied = false);
			}
		};

		const finishSetup = async () => {
			await copyToClipboard();

			if (timer) {
				clearTimeout(timer);
				showAddCliDrawer.set(false);
			}

			timer = setTimeout(
				() => {
					showAddCliDrawer.set(false);
					timer = null;
				},
				1500
			);
		};

		const createCliUser = async () => {
			const keys = await sendMessage("generateCliKeys", { username: name });

			const payload = {
				name,
				deviceKey: keys.sign_public_key,
				encryptionKey: keys.enc_public_key
			};

			const creatingUser = await addCliUser(payload);
			const { baseUrl } = await getTokenAndBaseUrl();
			keys.base_url = baseUrl;
			$$invalidate(1, userString = btoa(JSON.stringify(keys)));
			return creatingUser;
		};

		const handleKeyDown = async event => {
			if (event.key === "Escape") {
				handleClose();
			}

			if (event.key === "Enter" && name.length !== 0) {
				const tryingToCreateUser = await createCliUser();

				if (tryingToCreateUser.success) {
					toastStore.set({
						show: tryingToCreateUser.success,
						message: tryingToCreateUser.message,
						type: true
					});
				}
			}
		};

		onMount(async () => {
			window.addEventListener("keydown", handleKeyDown);
		});

		onDestroy(() => {
			window.removeEventListener("keydown", handleKeyDown);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<AddCliUser> was created with unknown prop '${key}'`);
		});

		function input_input_handler() {
			name = this.value;
			$$invalidate(0, name);
		}

		$$self.$capture_state = () => ({
			onMount,
			onDestroy,
			scale,
			addCliUser,
			getTokenAndBaseUrl,
			sendMessage,
			writeToClipboard,
			Tick,
			CopyIcon,
			Warning,
			showAddCliDrawer,
			toastStore,
			ClosePanel,
			name,
			userString,
			userStringCopied,
			timer,
			autofocus: autofocus$2,
			handleClose,
			copyToClipboard,
			finishSetup,
			createCliUser,
			handleKeyDown
		});

		$$self.$inject_state = $$props => {
			if ('name' in $$props) $$invalidate(0, name = $$props.name);
			if ('userString' in $$props) $$invalidate(1, userString = $$props.userString);
			if ('userStringCopied' in $$props) $$invalidate(2, userStringCopied = $$props.userStringCopied);
			if ('timer' in $$props) timer = $$props.timer;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			name,
			userString,
			userStringCopied,
			handleClose,
			finishSetup,
			createCliUser,
			input_input_handler
		];
	}

	class AddCliUser extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "AddCliUser",
				options,
				id: create_fragment$m.name
			});
		}
	}

	/* src/lib/components/dashboard/credentials/AddEnvironment.svelte generated by Svelte v4.2.19 */
	const file$l = "src/lib/components/dashboard/credentials/AddEnvironment.svelte";

	function get_each_context$4(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[18] = list[i];
		child_ctx[20] = i;
		return child_ctx;
	}

	// (116:2) {:else}
	function create_else_block_1$7(ctx) {
		let span;
		let t0;
		let t1;
		let t2;

		const block = {
			c: function create() {
				span = element("span");
				t0 = text("CLI user \"");
				t1 = text(/*query*/ ctx[2]);
				t2 = text("\" not found!");
				attr_dev(span, "class", "text-osvauld-textActive font-normal");
				add_location(span, file$l, 128, 3, 3856);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				append_dev(span, t0);
				append_dev(span, t1);
				append_dev(span, t2);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*query*/ 4) set_data_dev(t1, /*query*/ ctx[2]);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_1$7.name,
			type: "else",
			source: "(116:2) {:else}",
			ctx
		});

		return block;
	}

	// (109:5) {:else}
	function create_else_block$b(ctx) {
		let span;
		let userplus;
		let span_class_value;
		let current;
		userplus = new UserPlus({ $$inline: true });

		const block = {
			c: function create() {
				span = element("span");
				create_component(userplus.$$.fragment);

				attr_dev(span, "class", span_class_value = /*hoveredIndex*/ ctx[4] === /*index*/ ctx[20]
				? 'visible'
				: 'invisible');

				add_location(span, file$l, 121, 6, 3706);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				mount_component(userplus, span, null);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (!current || dirty & /*hoveredIndex*/ 16 && span_class_value !== (span_class_value = /*hoveredIndex*/ ctx[4] === /*index*/ ctx[20]
				? 'visible'
				: 'invisible')) {
					attr_dev(span, "class", span_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(userplus.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(userplus.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				destroy_component(userplus);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$b.name,
			type: "else",
			source: "(109:5) {:else}",
			ctx
		});

		return block;
	}

	// (107:5) {#if selectedUserIndice === index}
	function create_if_block$g(ctx) {
		let usercheck;
		let current;
		usercheck = new UserCheck({ $$inline: true });

		const block = {
			c: function create() {
				create_component(usercheck.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(usercheck, target, anchor);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(usercheck.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(usercheck.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(usercheck, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$g.name,
			type: "if",
			source: "(107:5) {#if selectedUserIndice === index}",
			ctx
		});

		return block;
	}

	// (94:2) {#each searchResults as user, index}
	function create_each_block$4(ctx) {
		let label;
		let span;
		let t0_value = /*user*/ ctx[18].username + "";
		let t0;
		let t1;
		let button;
		let current_block_type_index;
		let if_block;
		let t2;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block$g, create_else_block$b];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*selectedUserIndice*/ ctx[5] === /*index*/ ctx[20]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function click_handler() {
			return /*click_handler*/ ctx[13](/*user*/ ctx[18], /*index*/ ctx[20]);
		}

		function mouseenter_handler() {
			return /*mouseenter_handler*/ ctx[14](/*index*/ ctx[20]);
		}

		const block = {
			c: function create() {
				label = element("label");
				span = element("span");
				t0 = text(t0_value);
				t1 = space();
				button = element("button");
				if_block.c();
				t2 = space();
				attr_dev(span, "class", "pl-1");
				add_location(span, file$l, 112, 4, 3470);
				attr_dev(button, "class", "p-1 relative");
				attr_dev(button, "type", "button");
				add_location(button, file$l, 113, 4, 3516);
				attr_dev(label, "class", "w-full px-2 py-1.5 text-left rounded-md cursor-pointer text-osvauld-textActive hover:bg-osvauld-fieldActive hover:shadow-[0_0_0_1px_#292A36] flex justify-between items-center");
				add_location(label, file$l, 106, 3, 3093);
			},
			m: function mount(target, anchor) {
				insert_dev(target, label, anchor);
				append_dev(label, span);
				append_dev(span, t0);
				append_dev(label, t1);
				append_dev(label, button);
				if_blocks[current_block_type_index].m(button, null);
				append_dev(label, t2);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "click", click_handler, false, false, false, false),
						listen_dev(label, "mouseenter", mouseenter_handler, false, false, false, false),
						listen_dev(label, "mouseleave", /*mouseleave_handler*/ ctx[15], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				if ((!current || dirty & /*searchResults*/ 8) && t0_value !== (t0_value = /*user*/ ctx[18].username + "")) set_data_dev(t0, t0_value);
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(button, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(label);
				}

				if_blocks[current_block_type_index].d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$4.name,
			type: "each",
			source: "(94:2) {#each searchResults as user, index}",
			ctx
		});

		return block;
	}

	function create_fragment$l(ctx) {
		let form;
		let div0;
		let span0;
		let t1;
		let button0;
		let closepanel;
		let t2;
		let div1;
		let t3;
		let label0;
		let t5;
		let input0;
		let t6;
		let label1;
		let t8;
		let div2;
		let span1;
		let lens;
		let t9;
		let input1;
		let t10;
		let div3;
		let t11;
		let div4;
		let t12;
		let div5;
		let button1;
		let t14;
		let button2;
		let t15;
		let button2_disabled_value;
		let current;
		let mounted;
		let dispose;
		closepanel = new ClosePanel({ $$inline: true });
		lens = new Lens({ $$inline: true });
		let each_value = ensure_array_like_dev(/*searchResults*/ ctx[3]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		let each_1_else = null;

		if (!each_value.length) {
			each_1_else = create_else_block_1$7(ctx);
		}

		const block = {
			c: function create() {
				form = element("form");
				div0 = element("div");
				span0 = element("span");
				span0.textContent = "Create Environment";
				t1 = space();
				button0 = element("button");
				create_component(closepanel.$$.fragment);
				t2 = space();
				div1 = element("div");
				t3 = space();
				label0 = element("label");
				label0.textContent = "Name";
				t5 = space();
				input0 = element("input");
				t6 = space();
				label1 = element("label");
				label1.textContent = "Add one CLI user to the environment";
				t8 = space();
				div2 = element("div");
				span1 = element("span");
				create_component(lens.$$.fragment);
				t9 = space();
				input1 = element("input");
				t10 = space();
				div3 = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				if (each_1_else) {
					each_1_else.c();
				}

				t11 = space();
				div4 = element("div");
				t12 = space();
				div5 = element("div");
				button1 = element("button");
				button1.textContent = "Cancel";
				t14 = space();
				button2 = element("button");
				t15 = text("Create Environment");
				attr_dev(span0, "class", "text-[21px] font-medium text-osvauld-quarzowhite");
				add_location(span0, file$l, 63, 2, 1549);
				attr_dev(button0, "class", "cursor-pointer p-2");
				add_location(button0, file$l, 66, 2, 1647);
				attr_dev(div0, "class", "flex justify-between items-center w-full");
				add_location(div0, file$l, 62, 1, 1492);
				attr_dev(div1, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div1, file$l, 70, 1, 1762);
				attr_dev(label0, "for", "name");
				attr_dev(label0, "class", "font-normal text-base text-osvauld-textActive");
				add_location(label0, file$l, 74, 1, 1857);
				attr_dev(input0, "id", "name");
				attr_dev(input0, "type", "text");
				input0.required = true;
				attr_dev(input0, "class", "py-1 rounded-md items-center text-base bg-osvauld-frameblack border-osvauld-iconblack w-[95%] h-8 mx-2 focus:border-osvauld-iconblack focus:ring-0 form-input");
				attr_dev(input0, "autocomplete", "off");
				add_location(input0, file$l, 77, 1, 1948);
				attr_dev(label1, "for", "name");
				attr_dev(label1, "class", "font-light text-base text-osvauld-textActive");
				add_location(label1, file$l, 86, 1, 2224);
				attr_dev(span1, "class", "w-4 h-4");
				add_location(span1, file$l, 92, 2, 2528);
				attr_dev(input1, "type", "text");
				attr_dev(input1, "class", "h-full w-full bg-osvauld-frameblack border-0 text-osvauld-quarzowhite placeholder-osvauld-placeholderblack border-transparent text-base focus:border-transparent focus:ring-0 cursor-pointer");
				attr_dev(input1, "placeholder", "Search..");
				add_location(input1, file$l, 93, 2, 2568);
				attr_dev(div2, "class", "h-8 w-[95%] px-2 mx-2 mb-2 py-1 flex justify-start items-center border border-osvauld-iconblack focus-within:border-osvauld-activeBorder rounded-lg cursor-pointer");
				add_location(div2, file$l, 89, 1, 2345);
				attr_dev(div3, "class", "min-h-[10rem] max-h-[14rem] overflow-y-scroll scrollbar-thin flex flex-col justify-start items-center w-[95%] px-1");
				add_location(div3, file$l, 102, 1, 2918);
				attr_dev(div4, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div4, file$l, 133, 1, 3971);
				attr_dev(button1, "class", "font-medium text-base py-[5px] px-[15px] rounded-md hover:bg-osvauld-cancelBackground hover:text-osvauld-quarzowhite text-osvauld-fadedCancel");
				add_location(button1, file$l, 138, 2, 4125);
				attr_dev(button2, "class", "border border-osvauld-iconblack py-[5px] px-[15px] text-base font-medium text-osvauld-textActive rounded-md hover:bg-osvauld-carolinablue hover:border-osvauld-carolinablue hover:text-osvauld-frameblack");
				attr_dev(button2, "type", "submit");
				button2.disabled = button2_disabled_value = /*name*/ ctx[0] === '' || !/*selectedUser*/ ctx[1];
				add_location(button2, file$l, 142, 2, 4350);
				attr_dev(div5, "class", "flex justify-end items-center gap-4 w-full");
				add_location(div5, file$l, 137, 1, 4066);
				attr_dev(form, "class", "p-4 bg-osvauld-frameblack border border-osvauld-activeBorder rounded-3xl w-[35rem] h-[36rem] flex flex-col items-start justify-center gap-3");
				add_location(form, file$l, 58, 0, 1282);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, form, anchor);
				append_dev(form, div0);
				append_dev(div0, span0);
				append_dev(div0, t1);
				append_dev(div0, button0);
				mount_component(closepanel, button0, null);
				append_dev(form, t2);
				append_dev(form, div1);
				append_dev(form, t3);
				append_dev(form, label0);
				append_dev(form, t5);
				append_dev(form, input0);
				set_input_value(input0, /*name*/ ctx[0]);
				append_dev(form, t6);
				append_dev(form, label1);
				append_dev(form, t8);
				append_dev(form, div2);
				append_dev(div2, span1);
				mount_component(lens, span1, null);
				append_dev(div2, t9);
				append_dev(div2, input1);
				set_input_value(input1, /*query*/ ctx[2]);
				append_dev(form, t10);
				append_dev(form, div3);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div3, null);
					}
				}

				if (each_1_else) {
					each_1_else.m(div3, null);
				}

				append_dev(form, t11);
				append_dev(form, div4);
				append_dev(form, t12);
				append_dev(form, div5);
				append_dev(div5, button1);
				append_dev(div5, t14);
				append_dev(div5, button2);
				append_dev(button2, t15);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", prevent_default(/*handleClose*/ ctx[10]), false, true, false, false),
						action_destroyer(autofocus$1.call(null, input0)),
						listen_dev(input0, "input", /*input0_input_handler*/ ctx[11]),
						listen_dev(input1, "input", /*handleInputChange*/ ctx[7], false, false, false, false),
						listen_dev(input1, "input", /*input1_input_handler*/ ctx[12]),
						listen_dev(input1, "keyup", /*handleKeyDown*/ ctx[6], false, false, false, false),
						listen_dev(button1, "click", prevent_default(/*handleClose*/ ctx[10]), false, true, false, false),
						listen_dev(form, "submit", prevent_default(/*addEnvironmentHandler*/ ctx[9]), false, true, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*name*/ 1 && input0.value !== /*name*/ ctx[0]) {
					set_input_value(input0, /*name*/ ctx[0]);
				}

				if (dirty & /*query*/ 4 && input1.value !== /*query*/ ctx[2]) {
					set_input_value(input1, /*query*/ ctx[2]);
				}

				if (dirty & /*hoveredIndex, addUsertoGroup, searchResults, selectedUserIndice, query*/ 316) {
					each_value = ensure_array_like_dev(/*searchResults*/ ctx[3]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$4(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$4(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div3, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();

					if (!each_value.length && each_1_else) {
						each_1_else.p(ctx, dirty);
					} else if (!each_value.length) {
						each_1_else = create_else_block_1$7(ctx);
						each_1_else.c();
						each_1_else.m(div3, null);
					} else if (each_1_else) {
						each_1_else.d(1);
						each_1_else = null;
					}
				}

				if (!current || dirty & /*name, selectedUser*/ 3 && button2_disabled_value !== (button2_disabled_value = /*name*/ ctx[0] === '' || !/*selectedUser*/ ctx[1])) {
					prop_dev(button2, "disabled", button2_disabled_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closepanel.$$.fragment, local);
				transition_in(lens.$$.fragment, local);

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(closepanel.$$.fragment, local);
				transition_out(lens.$$.fragment, local);
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(form);
				}

				destroy_component(closepanel);
				destroy_component(lens);
				destroy_each(each_blocks, detaching);
				if (each_1_else) each_1_else.d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$l.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function autofocus$1(node) {
		node.focus();
	}

	function instance$l($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('AddEnvironment', slots, []);
		let name;
		let selectedUser;
		let cliUsers = [];
		let query;
		let searchResults = [];
		let hoveredIndex;
		let selectedUserIndice;
		const dispatch = createEventDispatcher();

		const handleKeyDown = event => {
			if (event.key === "Escape") {
				dispatch("close");
			}
		};

		const handleInputChange = e => {
			const query = e.target.value;

			$$invalidate(3, searchResults = query.length === 0
			? cliUsers
			: cliUsers.filter(item => item.username.startsWith(query)));
		};

		const addUsertoGroup = async (user, index) => {
			$$invalidate(5, selectedUserIndice = index);
			$$invalidate(1, selectedUser = user);
		};

		const addEnvironmentHandler = async () => {
			await addEnvironment(name, selectedUser.id);
			showAddEnvDrawer.set(false);
			setEnvStore();
		};

		const handleClose = () => {
			showAddEnvDrawer.set(false);
		};

		onMount(async () => {
			const response = await fetchCliUsers();
			$$invalidate(3, searchResults = cliUsers = response.data);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AddEnvironment> was created with unknown prop '${key}'`);
		});

		function input0_input_handler() {
			name = this.value;
			$$invalidate(0, name);
		}

		function input1_input_handler() {
			query = this.value;
			$$invalidate(2, query);
		}

		const click_handler = (user, index) => addUsertoGroup(user, index);
		const mouseenter_handler = index => $$invalidate(4, hoveredIndex = index);
		const mouseleave_handler = () => $$invalidate(4, hoveredIndex = -1);

		$$self.$capture_state = () => ({
			fetchCliUsers,
			addEnvironment,
			onMount,
			createEventDispatcher,
			showAddEnvDrawer,
			ClosePanel,
			Lens,
			UserCheck,
			UserPlus,
			setEnvStore,
			name,
			selectedUser,
			cliUsers,
			query,
			searchResults,
			hoveredIndex,
			selectedUserIndice,
			dispatch,
			handleKeyDown,
			handleInputChange,
			addUsertoGroup,
			addEnvironmentHandler,
			autofocus: autofocus$1,
			handleClose
		});

		$$self.$inject_state = $$props => {
			if ('name' in $$props) $$invalidate(0, name = $$props.name);
			if ('selectedUser' in $$props) $$invalidate(1, selectedUser = $$props.selectedUser);
			if ('cliUsers' in $$props) cliUsers = $$props.cliUsers;
			if ('query' in $$props) $$invalidate(2, query = $$props.query);
			if ('searchResults' in $$props) $$invalidate(3, searchResults = $$props.searchResults);
			if ('hoveredIndex' in $$props) $$invalidate(4, hoveredIndex = $$props.hoveredIndex);
			if ('selectedUserIndice' in $$props) $$invalidate(5, selectedUserIndice = $$props.selectedUserIndice);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			name,
			selectedUser,
			query,
			searchResults,
			hoveredIndex,
			selectedUserIndice,
			handleKeyDown,
			handleInputChange,
			addUsertoGroup,
			addEnvironmentHandler,
			handleClose,
			input0_input_handler,
			input1_input_handler,
			click_handler,
			mouseenter_handler,
			mouseleave_handler
		];
	}

	class AddEnvironment extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$l, create_fragment$l, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "AddEnvironment",
				options,
				id: create_fragment$l.name
			});
		}
	}

	/* src/lib/components/dashboard/credentials/EnvironmentCredential.svelte generated by Svelte v4.2.19 */
	const file$k = "src/lib/components/dashboard/credentials/EnvironmentCredential.svelte";

	function get_each_context$3(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[18] = list[i];
		child_ctx[19] = list;
		child_ctx[20] = i;
		return child_ctx;
	}

	// (70:4) {:else}
	function create_else_block_2$3(ctx) {
		let copyicon;
		let current;

		copyicon = new CopyIcon({
				props: { color: "#4D4F60" },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(copyicon.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(copyicon, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(copyicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(copyicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(copyicon, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_2$3.name,
			type: "else",
			source: "(70:4) {:else}",
			ctx
		});

		return block;
	}

	// (66:4) {#if fieldCopied[`fieldName-${field.fieldId}`]}
	function create_if_block_2$8(ctx) {
		let span;
		let tick_1;
		let span_intro;
		let current;
		tick_1 = new Tick({ $$inline: true });

		const block = {
			c: function create() {
				span = element("span");
				create_component(tick_1.$$.fragment);
				add_location(span, file$k, 85, 5, 2473);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				mount_component(tick_1, span, null);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(tick_1.$$.fragment, local);

				if (local) {
					if (!span_intro) {
						add_render_callback(() => {
							span_intro = create_in_transition(span, scale, {});
							span_intro.start();
						});
					}
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(tick_1.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				destroy_component(tick_1);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$8.name,
			type: "if",
			source: "(66:4) {#if fieldCopied[`fieldName-${field.fieldId}`]}",
			ctx
		});

		return block;
	}

	// (90:5) {:else}
	function create_else_block_1$6(ctx) {
		let eye;
		let current;

		eye = new Eye({
				props: { color: "#4D4F60" },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(eye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(eye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(eye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(eye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(eye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_1$6.name,
			type: "else",
			source: "(90:5) {:else}",
			ctx
		});

		return block;
	}

	// (88:5) {#if visibility[field.fieldId]}
	function create_if_block_1$c(ctx) {
		let closedeye;
		let current;

		closedeye = new ClosedEye({
				props: { color: "#4D4F60" },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(closedeye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(closedeye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closedeye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(closedeye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(closedeye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$c.name,
			type: "if",
			source: "(88:5) {#if visibility[field.fieldId]}",
			ctx
		});

		return block;
	}

	// (104:5) {:else}
	function create_else_block$a(ctx) {
		let copyicon;
		let current;

		copyicon = new CopyIcon({
				props: { color: '#4D4F60' },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(copyicon.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(copyicon, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(copyicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(copyicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(copyicon, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$a.name,
			type: "else",
			source: "(104:5) {:else}",
			ctx
		});

		return block;
	}

	// (100:5) {#if fieldCopied[`fieldValue-${field.fieldId}`]}
	function create_if_block$f(ctx) {
		let span;
		let tick_1;
		let span_intro;
		let current;
		tick_1 = new Tick({ $$inline: true });

		const block = {
			c: function create() {
				span = element("span");
				create_component(tick_1.$$.fragment);
				add_location(span, file$k, 119, 6, 3554);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				mount_component(tick_1, span, null);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(tick_1.$$.fragment, local);

				if (local) {
					if (!span_intro) {
						add_render_callback(() => {
							span_intro = create_in_transition(span, scale, {});
							span_intro.start();
						});
					}
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(tick_1.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				destroy_component(tick_1);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$f.name,
			type: "if",
			source: "(100:5) {#if fieldCopied[`fieldValue-${field.fieldId}`]}",
			ctx
		});

		return block;
	}

	// (52:0) {#each credential.fields as field}
	function create_each_block$3(ctx) {
		let div3;
		let div0;
		let input0;
		let input0_id_value;
		let input0_disabled_value;
		let t0;
		let button0;
		let current_block_type_index;
		let if_block0;
		let t1;
		let div2;
		let input1;
		let input1_id_value;
		let input1_value_value;
		let t2;
		let div1;
		let button1;
		let current_block_type_index_1;
		let if_block1;
		let t3;
		let button2;
		let current_block_type_index_2;
		let if_block2;
		let t4;
		let current;
		let mounted;
		let dispose;

		function input0_input_handler() {
			/*input0_input_handler*/ ctx[8].call(input0, /*each_value*/ ctx[19], /*field_index*/ ctx[20]);
		}

		function input_handler() {
			return /*input_handler*/ ctx[9](/*field*/ ctx[18]);
		}

		const if_block_creators = [create_if_block_2$8, create_else_block_2$3];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*fieldCopied*/ ctx[3][`fieldName-${/*field*/ ctx[18].fieldId}`]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function click_handler() {
			return /*click_handler*/ ctx[10](/*field*/ ctx[18]);
		}

		const if_block_creators_1 = [create_if_block_1$c, create_else_block_1$6];
		const if_blocks_1 = [];

		function select_block_type_1(ctx, dirty) {
			if (/*visibility*/ ctx[4][/*field*/ ctx[18].fieldId]) return 0;
			return 1;
		}

		current_block_type_index_1 = select_block_type_1(ctx);
		if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

		function click_handler_1() {
			return /*click_handler_1*/ ctx[11](/*field*/ ctx[18]);
		}

		const if_block_creators_2 = [create_if_block$f, create_else_block$a];
		const if_blocks_2 = [];

		function select_block_type_2(ctx, dirty) {
			if (/*fieldCopied*/ ctx[3][`fieldValue-${/*field*/ ctx[18].fieldId}`]) return 0;
			return 1;
		}

		current_block_type_index_2 = select_block_type_2(ctx);
		if_block2 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

		function click_handler_2() {
			return /*click_handler_2*/ ctx[12](/*field*/ ctx[18]);
		}

		const block = {
			c: function create() {
				div3 = element("div");
				div0 = element("div");
				input0 = element("input");
				t0 = space();
				button0 = element("button");
				if_block0.c();
				t1 = space();
				div2 = element("div");
				input1 = element("input");
				t2 = space();
				div1 = element("div");
				button1 = element("button");
				if_block1.c();
				t3 = space();
				button2 = element("button");
				if_block2.c();
				t4 = space();
				attr_dev(input0, "class", "py-1 px-2 inline-block w-[90%] overflow-x-hidden text-ellipsis rounded-lg items-center text-base bg-osvauld-fieldActive border-0 h-10 mx-2 focus:ring-0");
				attr_dev(input0, "id", input0_id_value = /*field*/ ctx[18].fieldId);
				attr_dev(input0, "type", "text");
				input0.disabled = input0_disabled_value = /*activefieldId*/ ctx[1] !== /*field*/ ctx[18].fieldId;
				add_location(input0, file$k, 74, 3, 1927);
				add_location(button0, file$k, 81, 3, 2285);
				attr_dev(div0, "class", "w-[30%] bg-osvauld-fieldActive rounded-lg pl-0 pr-2 py-0.5 flex justify-between items-center");
				add_location(div0, file$k, 72, 2, 1814);
				attr_dev(input1, "class", "py-1 px-2 inline-block w-[90%] overflow-x-hidden text-ellipsis rounded-lg items-center text-base bg-osvauld-fieldActive border-0 h-10 mx-2 focus:ring-0");
				attr_dev(input1, "id", input1_id_value = /*field*/ ctx[18].fieldId);
				attr_dev(input1, "type", "text");
				attr_dev(input1, "autocomplete", "off");

				input1.value = input1_value_value = /*visibility*/ ctx[4][/*field*/ ctx[18].fieldId]
				? /*decryptedValues*/ ctx[2][/*field*/ ctx[18].fieldId]
				: ('*').repeat(50);

				add_location(input1, file$k, 95, 3, 2710);
				add_location(button1, file$k, 104, 4, 3111);
				add_location(button2, file$k, 112, 4, 3337);
				attr_dev(div1, "class", "w-2/5 flex gap-2 items-center justify-end");
				add_location(div1, file$k, 103, 3, 3051);
				attr_dev(div2, "class", "w-[68%] bg-osvauld-fieldActive rounded-lg pl-0 pr-2 py-0.5 flex justify-between items-center");
				add_location(div2, file$k, 93, 2, 2597);
				attr_dev(div3, "class", "flex justify-between items-center my-1");
				add_location(div3, file$k, 71, 1, 1759);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div3, anchor);
				append_dev(div3, div0);
				append_dev(div0, input0);
				set_input_value(input0, /*field*/ ctx[18].fieldName);
				append_dev(div0, t0);
				append_dev(div0, button0);
				if_blocks[current_block_type_index].m(button0, null);
				append_dev(div3, t1);
				append_dev(div3, div2);
				append_dev(div2, input1);
				append_dev(div2, t2);
				append_dev(div2, div1);
				append_dev(div1, button1);
				if_blocks_1[current_block_type_index_1].m(button1, null);
				append_dev(div1, t3);
				append_dev(div1, button2);
				if_blocks_2[current_block_type_index_2].m(button2, null);
				append_dev(div3, t4);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(input0, "input", input0_input_handler),
						listen_dev(input0, "input", input_handler, false, false, false, false),
						listen_dev(button0, "click", stop_propagation(prevent_default(click_handler)), false, true, true, false),
						listen_dev(button1, "click", stop_propagation(click_handler_1), false, false, true, false),
						listen_dev(button2, "click", stop_propagation(click_handler_2), false, false, true, false)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;

				if (!current || dirty & /*credential*/ 1 && input0_id_value !== (input0_id_value = /*field*/ ctx[18].fieldId)) {
					attr_dev(input0, "id", input0_id_value);
				}

				if (!current || dirty & /*activefieldId, credential*/ 3 && input0_disabled_value !== (input0_disabled_value = /*activefieldId*/ ctx[1] !== /*field*/ ctx[18].fieldId)) {
					prop_dev(input0, "disabled", input0_disabled_value);
				}

				if (dirty & /*credential*/ 1 && input0.value !== /*field*/ ctx[18].fieldName) {
					set_input_value(input0, /*field*/ ctx[18].fieldName);
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index !== previous_block_index) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					}

					transition_in(if_block0, 1);
					if_block0.m(button0, null);
				}

				if (!current || dirty & /*credential*/ 1 && input1_id_value !== (input1_id_value = /*field*/ ctx[18].fieldId)) {
					attr_dev(input1, "id", input1_id_value);
				}

				if (!current || dirty & /*visibility, credential, decryptedValues*/ 21 && input1_value_value !== (input1_value_value = /*visibility*/ ctx[4][/*field*/ ctx[18].fieldId]
				? /*decryptedValues*/ ctx[2][/*field*/ ctx[18].fieldId]
				: ('*').repeat(50)) && input1.value !== input1_value_value) {
					prop_dev(input1, "value", input1_value_value);
				}

				let previous_block_index_1 = current_block_type_index_1;
				current_block_type_index_1 = select_block_type_1(ctx);

				if (current_block_type_index_1 !== previous_block_index_1) {
					group_outros();

					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
						if_blocks_1[previous_block_index_1] = null;
					});

					check_outros();
					if_block1 = if_blocks_1[current_block_type_index_1];

					if (!if_block1) {
						if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
						if_block1.c();
					}

					transition_in(if_block1, 1);
					if_block1.m(button1, null);
				}

				let previous_block_index_2 = current_block_type_index_2;
				current_block_type_index_2 = select_block_type_2(ctx);

				if (current_block_type_index_2 !== previous_block_index_2) {
					group_outros();

					transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
						if_blocks_2[previous_block_index_2] = null;
					});

					check_outros();
					if_block2 = if_blocks_2[current_block_type_index_2];

					if (!if_block2) {
						if_block2 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
						if_block2.c();
					}

					transition_in(if_block2, 1);
					if_block2.m(button2, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div3);
				}

				if_blocks[current_block_type_index].d();
				if_blocks_1[current_block_type_index_1].d();
				if_blocks_2[current_block_type_index_2].d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$3.name,
			type: "each",
			source: "(52:0) {#each credential.fields as field}",
			ctx
		});

		return block;
	}

	function create_fragment$k(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like_dev(/*credential*/ ctx[0].fields);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert_dev(target, each_1_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*copyToClipboard, decryptedValues, credential, fieldCopied, toggleVisibility, visibility, activefieldId, checkValueChanged*/ 255) {
					each_value = ensure_array_like_dev(/*credential*/ ctx[0].fields);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$3(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$3(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$k.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$k($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('EnvironmentCredential', slots, []);
		const dispatch = createEventDispatcher();
		let { credential } = $$props;
		let { activefieldId } = $$props;
		let decryptedValues = {};
		let fieldCopied = {};
		let visibility = {};
		let fieldNameEdited = false;
		let initialCredential = structuredClone(credential);

		const copyToClipboard = async (value, fieldName) => {
			$$invalidate(3, fieldCopied[fieldName] = true, fieldCopied);
			await writeToClipboard(value);

			setTimeout(
				() => {
					$$invalidate(3, fieldCopied[fieldName] = false, fieldCopied);
				},
				2000
			);
		};

		const decrypt = async (fieldId, fieldValue) => {
			const decryptedValue = await sendMessage("decryptField", fieldValue);
			$$invalidate(2, decryptedValues[fieldId] = decryptedValue, decryptedValues);
		};

		const toggleVisibility = fieldId => {
			$$invalidate(4, visibility[fieldId] = !visibility[fieldId], visibility);

			setTimeout(
				() => {
					$$invalidate(4, visibility[fieldId] = false, visibility);
				},
				3000
			);
		};

		const checkValueChanged = fieldId => {
			const currentFieldData = credential.fields.find(field => field.fieldId === fieldId);
			const baseFieldData = initialCredential.fields.find(field => field.fieldId === fieldId);
			fieldNameEdited = currentFieldData?.fieldName !== baseFieldData?.fieldName;

			if (fieldNameEdited) {
				dispatch("edit", currentFieldData);
			}
		};

		const initializeDecryption = () => {
			credential.fields.forEach(field => {
				if (field.fieldId) {
					decrypt(field.fieldId, field.fieldValue);
				}
			});
		};

		onMount(() => {
			initializeDecryption();
		});

		$$self.$$.on_mount.push(function () {
			if (credential === undefined && !('credential' in $$props || $$self.$$.bound[$$self.$$.props['credential']])) {
				console.warn("<EnvironmentCredential> was created without expected prop 'credential'");
			}

			if (activefieldId === undefined && !('activefieldId' in $$props || $$self.$$.bound[$$self.$$.props['activefieldId']])) {
				console.warn("<EnvironmentCredential> was created without expected prop 'activefieldId'");
			}
		});

		const writable_props = ['credential', 'activefieldId'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EnvironmentCredential> was created with unknown prop '${key}'`);
		});

		function input0_input_handler(each_value, field_index) {
			each_value[field_index].fieldName = this.value;
			$$invalidate(0, credential);
		}

		const input_handler = field => checkValueChanged(field.fieldId);
		const click_handler = field => copyToClipboard(field.fieldName, `fieldName-${field.fieldId}`);
		const click_handler_1 = field => toggleVisibility(field.fieldId);
		const click_handler_2 = field => copyToClipboard(decryptedValues[field.fieldId], `fieldValue-${field.fieldId}`);

		$$self.$$set = $$props => {
			if ('credential' in $$props) $$invalidate(0, credential = $$props.credential);
			if ('activefieldId' in $$props) $$invalidate(1, activefieldId = $$props.activefieldId);
		};

		$$self.$capture_state = () => ({
			scale,
			onMount,
			sendMessage,
			writeToClipboard,
			Eye,
			ClosedEye,
			CopyIcon,
			Tick,
			createEventDispatcher,
			dispatch,
			credential,
			activefieldId,
			decryptedValues,
			fieldCopied,
			visibility,
			fieldNameEdited,
			initialCredential,
			copyToClipboard,
			decrypt,
			toggleVisibility,
			checkValueChanged,
			initializeDecryption
		});

		$$self.$inject_state = $$props => {
			if ('credential' in $$props) $$invalidate(0, credential = $$props.credential);
			if ('activefieldId' in $$props) $$invalidate(1, activefieldId = $$props.activefieldId);
			if ('decryptedValues' in $$props) $$invalidate(2, decryptedValues = $$props.decryptedValues);
			if ('fieldCopied' in $$props) $$invalidate(3, fieldCopied = $$props.fieldCopied);
			if ('visibility' in $$props) $$invalidate(4, visibility = $$props.visibility);
			if ('fieldNameEdited' in $$props) fieldNameEdited = $$props.fieldNameEdited;
			if ('initialCredential' in $$props) initialCredential = $$props.initialCredential;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			credential,
			activefieldId,
			decryptedValues,
			fieldCopied,
			visibility,
			copyToClipboard,
			toggleVisibility,
			checkValueChanged,
			input0_input_handler,
			input_handler,
			click_handler,
			click_handler_1,
			click_handler_2
		];
	}

	class EnvironmentCredential extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$k, create_fragment$k, safe_not_equal, { credential: 0, activefieldId: 1 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "EnvironmentCredential",
				options,
				id: create_fragment$k.name
			});
		}

		get credential() {
			throw new Error("<EnvironmentCredential>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set credential(value) {
			throw new Error("<EnvironmentCredential>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get activefieldId() {
			throw new Error("<EnvironmentCredential>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set activefieldId(value) {
			throw new Error("<EnvironmentCredential>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/credentials/Environments.svelte generated by Svelte v4.2.19 */
	const file$j = "src/lib/components/dashboard/credentials/Environments.svelte";

	function get_each_context_1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[33] = list[i];
		return child_ctx;
	}

	function get_each_context$2(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[30] = list[i];
		return child_ctx;
	}

	// (76:2) {:else}
	function create_else_block_2$2(ctx) {
		let t;

		const block = {
			c: function create() {
				t = text("Environments");
			},
			m: function mount(target, anchor) {
				insert_dev(target, t, anchor);
			},
			p: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_2$2.name,
			type: "else",
			source: "(76:2) {:else}",
			ctx
		});

		return block;
	}

	// (74:2) {#if $selectedEnv}
	function create_if_block_6$1(ctx) {
		let t_value = /*$selectedEnv*/ ctx[0].name + "";
		let t;

		const block = {
			c: function create() {
				t = text(t_value);
			},
			m: function mount(target, anchor) {
				insert_dev(target, t, anchor);
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*$selectedEnv*/ 1 && t_value !== (t_value = /*$selectedEnv*/ ctx[0].name + "")) set_data_dev(t, t_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_6$1.name,
			type: "if",
			source: "(74:2) {#if $selectedEnv}",
			ctx
		});

		return block;
	}

	// (90:1) {:else}
	function create_else_block_1$5(ctx) {
		let div;
		let button0;
		let span0;
		let t1;
		let userplus;
		let t2;
		let button1;
		let span1;
		let t4;
		let environmentadd;
		let current;
		let mounted;
		let dispose;

		userplus = new UserPlus({
				props: {
					color: /*addNewCliUserHovered*/ ctx[4] ? '#0D0E13' : '#A3A4B5'
				},
				$$inline: true
			});

		environmentadd = new EnvironmentAdd({
				props: {
					color: /*addNewUserHovered*/ ctx[3] ? '#0D0E13' : '#A3A4B5'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				div = element("div");
				button0 = element("button");
				span0 = element("span");
				span0.textContent = "Add new CLI user";
				t1 = space();
				create_component(userplus.$$.fragment);
				t2 = space();
				button1 = element("button");
				span1 = element("span");
				span1.textContent = "Add new environment";
				t4 = space();
				create_component(environmentadd.$$.fragment);
				attr_dev(span0, "class", "mr-2");
				add_location(span0, file$j, 118, 4, 3529);
				attr_dev(button0, "class", "rounded-md h-[40px] py-1.5 px-4 mx-2 flex justify-center items-center whitespace-nowrap text-sm border text-osvauld-textActive border-osvauld-iconblack hover:text-osvauld-frameblack hover:bg-osvauld-carolinablue");
				add_location(button0, file$j, 112, 3, 3143);
				attr_dev(span1, "class", "mr-2");
				add_location(span1, file$j, 128, 4, 4037);
				attr_dev(button1, "class", "rounded-md h-[40px] py-1.5 px-4 mx-2 flex justify-center items-center whitespace-nowrap text-sm border text-osvauld-textActive border-osvauld-iconblack hover:text-osvauld-frameblack hover:bg-osvauld-carolinablue");
				add_location(button1, file$j, 122, 3, 3661);
				attr_dev(div, "class", "flex items-center gap-4");
				add_location(div, file$j, 111, 2, 3102);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, button0);
				append_dev(button0, span0);
				append_dev(button0, t1);
				mount_component(userplus, button0, null);
				append_dev(div, t2);
				append_dev(div, button1);
				append_dev(button1, span1);
				append_dev(button1, t4);
				mount_component(environmentadd, button1, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "mouseenter", /*mouseenter_handler_1*/ ctx[22], false, false, false, false),
						listen_dev(button0, "mouseleave", /*mouseleave_handler_1*/ ctx[23], false, false, false, false),
						listen_dev(button0, "click", /*addCliUser*/ ctx[11], false, false, false, false),
						listen_dev(button1, "mouseenter", /*mouseenter_handler_2*/ ctx[24], false, false, false, false),
						listen_dev(button1, "mouseleave", /*mouseleave_handler_2*/ ctx[25], false, false, false, false),
						listen_dev(button1, "click", /*addEnv*/ ctx[10], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const userplus_changes = {};
				if (dirty[0] & /*addNewCliUserHovered*/ 16) userplus_changes.color = /*addNewCliUserHovered*/ ctx[4] ? '#0D0E13' : '#A3A4B5';
				userplus.$set(userplus_changes);
				const environmentadd_changes = {};
				if (dirty[0] & /*addNewUserHovered*/ 8) environmentadd_changes.color = /*addNewUserHovered*/ ctx[3] ? '#0D0E13' : '#A3A4B5';
				environmentadd.$set(environmentadd_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(userplus.$$.fragment, local);
				transition_in(environmentadd.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(userplus.$$.fragment, local);
				transition_out(environmentadd.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(userplus);
				destroy_component(environmentadd);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_1$5.name,
			type: "else",
			source: "(90:1) {:else}",
			ctx
		});

		return block;
	}

	// (80:1) {#if $selectedEnv}
	function create_if_block_5$1(ctx) {
		let button;
		let span;
		let t1;
		let add;
		let current;
		let mounted;
		let dispose;

		add = new Add({
				props: {
					color: /*addCredentialHovered*/ ctx[1] ? '#0D0E13' : '#A3A4B5'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				button = element("button");
				span = element("span");
				span.textContent = "Add Credential to environment";
				t1 = space();
				create_component(add.$$.fragment);
				attr_dev(span, "class", "mr-2");
				add_location(span, file$j, 107, 3, 2957);
				attr_dev(button, "class", "rounded-md py-1.5 px-4 mx-2 flex justify-center items-center whitespace-nowrap text-sm border text-osvauld-textActive border-osvauld-iconblack hover:text-osvauld-frameblack hover:bg-osvauld-carolinablue");
				add_location(button, file$j, 101, 2, 2563);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button, anchor);
				append_dev(button, span);
				append_dev(button, t1);
				mount_component(add, button, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "mouseenter", /*mouseenter_handler*/ ctx[19], false, false, false, false),
						listen_dev(button, "mouseleave", /*mouseleave_handler*/ ctx[20], false, false, false, false),
						listen_dev(button, "click", /*click_handler_3*/ ctx[21], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const add_changes = {};
				if (dirty[0] & /*addCredentialHovered*/ 2) add_changes.color = /*addCredentialHovered*/ ctx[1] ? '#0D0E13' : '#A3A4B5';
				add.$set(add_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(add.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(add.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button);
				}

				destroy_component(add);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_5$1.name,
			type: "if",
			source: "(80:1) {#if $selectedEnv}",
			ctx
		});

		return block;
	}

	// (157:0) {:else}
	function create_else_block$9(ctx) {
		let div2;
		let ul;
		let div0;
		let span0;
		let span1;
		let span2;
		let t3;
		let div1;
		let t4;
		let each_value_1 = ensure_array_like_dev(/*$envStore*/ ctx[7]);
		let each_blocks = [];

		for (let i = 0; i < each_value_1.length; i += 1) {
			each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
		}

		const block = {
			c: function create() {
				div2 = element("div");
				ul = element("ul");
				div0 = element("div");
				span0 = element("span");
				span0.textContent = "Environment Name";
				span1 = element("span");
				span1.textContent = "CLI user";
				span2 = element("span");
				span2.textContent = "Created At";
				t3 = space();
				div1 = element("div");
				t4 = space();

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(span0, "class", "w-[15rem] text-center");
				add_location(span0, file$j, 181, 4, 5828);
				attr_dev(span1, "class", "w-[15rem] text-center");
				add_location(span1, file$j, 181, 63, 5887);
				attr_dev(span2, "class", "w-[15rem] text-center pr-6");
				add_location(span2, file$j, 183, 5, 5948);
				attr_dev(div0, "class", "flex justify-between items-center p-4");
				add_location(div0, file$j, 180, 3, 5772);
				attr_dev(div1, "class", "border-b border-osvauld-iconblack my-1 w-full mt-auto");
				add_location(div1, file$j, 185, 3, 6020);
				attr_dev(ul, "class", "w-[90%] mx-auto text-osvauld-fieldText font-light");
				add_location(ul, file$j, 179, 2, 5706);
				attr_dev(div2, "class", "w-full");
				add_location(div2, file$j, 178, 1, 5683);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div2, anchor);
				append_dev(div2, ul);
				append_dev(ul, div0);
				append_dev(div0, span0);
				append_dev(div0, span1);
				append_dev(div0, span2);
				append_dev(ul, t3);
				append_dev(ul, div1);
				append_dev(ul, t4);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(ul, null);
					}
				}
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*$envStore*/ 128) {
					each_value_1 = ensure_array_like_dev(/*$envStore*/ ctx[7]);
					let i;

					for (i = 0; i < each_value_1.length; i += 1) {
						const child_ctx = get_each_context_1(ctx, each_value_1, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block_1(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(ul, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value_1.length;
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div2);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$9.name,
			type: "else",
			source: "(157:0) {:else}",
			ctx
		});

		return block;
	}

	// (115:0) {#if $selectedEnv}
	function create_if_block_3$5(ctx) {
		let div;
		let current;
		let each_value = ensure_array_like_dev(/*credentials*/ ctx[6]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				div = element("div");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(div, "class", "overflow-y-scroll max-h-[65rem] scrollbar-thin");
				add_location(div, file$j, 136, 1, 4216);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(div, null);
					}
				}

				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*handleSaveChange, closeEditOption, credentials, editedCredential, handleEditField*/ 45152) {
					each_value = ensure_array_like_dev(/*credentials*/ ctx[6]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$2(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block$2(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(div, null);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$5.name,
			type: "if",
			source: "(115:0) {#if $selectedEnv}",
			ctx
		});

		return block;
	}

	// (166:3) {#each $envStore as env}
	function create_each_block_1(ctx) {
		let li;
		let span0;
		let t0_value = /*env*/ ctx[33].name + "";
		let t0;
		let t1;
		let span1;
		let t2_value = /*env*/ ctx[33].cliUsername + "";
		let t2;
		let t3;
		let span2;
		let t4_value = new Date(/*env*/ ctx[33].createdat).toLocaleString().split(",")[0] + "";
		let t4;
		let t5;

		const block = {
			c: function create() {
				li = element("li");
				span0 = element("span");
				t0 = text(t0_value);
				t1 = space();
				span1 = element("span");
				t2 = text(t2_value);
				t3 = space();
				span2 = element("span");
				t4 = text(t4_value);
				t5 = space();
				attr_dev(span0, "class", "w-[15rem] text-center");
				add_location(span0, file$j, 190, 5, 6245);
				attr_dev(span1, "class", "w-[15rem] text-center");
				add_location(span1, file$j, 191, 5, 6304);
				attr_dev(span2, "class", "w-[15rem] text-center");
				add_location(span2, file$j, 192, 5, 6370);
				attr_dev(li, "class", "my-2 py-3 px-6 bg-osvauld-cardshade rounded-lg flex justify-between items-center text-base");
				add_location(li, file$j, 187, 4, 6126);
			},
			m: function mount(target, anchor) {
				insert_dev(target, li, anchor);
				append_dev(li, span0);
				append_dev(span0, t0);
				append_dev(li, t1);
				append_dev(li, span1);
				append_dev(span1, t2);
				append_dev(li, t3);
				append_dev(li, span2);
				append_dev(span2, t4);
				append_dev(li, t5);
			},
			p: function update(ctx, dirty) {
				if (dirty[0] & /*$envStore*/ 128 && t0_value !== (t0_value = /*env*/ ctx[33].name + "")) set_data_dev(t0, t0_value);
				if (dirty[0] & /*$envStore*/ 128 && t2_value !== (t2_value = /*env*/ ctx[33].cliUsername + "")) set_data_dev(t2, t2_value);
				if (dirty[0] & /*$envStore*/ 128 && t4_value !== (t4_value = new Date(/*env*/ ctx[33].createdat).toLocaleString().split(",")[0] + "")) set_data_dev(t4, t4_value);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(li);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block_1.name,
			type: "each",
			source: "(166:3) {#each $envStore as env}",
			ctx
		});

		return block;
	}

	// (141:4) {#if credential.credentialId === editedCredential?.credentialId}
	function create_if_block_4$2(ctx) {
		let div;
		let button0;
		let t1;
		let button1;
		let mounted;
		let dispose;

		const block = {
			c: function create() {
				div = element("div");
				button0 = element("button");
				button0.textContent = "Cancel";
				t1 = space();
				button1 = element("button");
				button1.textContent = "Save Changes";
				attr_dev(button0, "class", "px-3 py-1 mr-2 text-osvauld-fadedCancel border border-osvauld-iconblack rounded-md hover:text-osvauld-textActive text-sm font-medium");
				attr_dev(button0, "type", "button");
				add_location(button0, file$j, 163, 6, 5155);
				attr_dev(button1, "class", "px-3 py-1 whitespace-nowrap text-sm font-medium rounded-md border bg-osvauld-carolinablue border-osvauld-iconblack text-osvauld-frameblack");
				add_location(button1, file$j, 168, 6, 5397);
				attr_dev(div, "class", "flex justify-end items-center pr-4");
				add_location(div, file$j, 162, 5, 5100);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, button0);
				append_dev(div, t1);
				append_dev(div, button1);

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", /*closeEditOption*/ ctx[13], false, false, false, false),
						listen_dev(button1, "click", /*handleSaveChange*/ ctx[15], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_4$2.name,
			type: "if",
			source: "(141:4) {#if credential.credentialId === editedCredential?.credentialId}",
			ctx
		});

		return block;
	}

	// (117:2) {#each credentials as credential}
	function create_each_block$2(ctx) {
		let ul;
		let div0;
		let t0_value = /*credential*/ ctx[30].credentialName + "";
		let t0;
		let t1;
		let div1;
		let environmentcredential;
		let t2;
		let t3;
		let current;

		function edit_handler(...args) {
			return /*edit_handler*/ ctx[26](/*credential*/ ctx[30], ...args);
		}

		environmentcredential = new EnvironmentCredential({
				props: {
					credential: /*credential*/ ctx[30],
					activefieldId: /*credential*/ ctx[30].credentialId === /*editedCredential*/ ctx[5]?.credentialId
					? /*editedCredential*/ ctx[5]?.fieldId
					: ''
				},
				$$inline: true
			});

		environmentcredential.$on("edit", edit_handler);
		let if_block = /*credential*/ ctx[30].credentialId === /*editedCredential*/ ctx[5]?.credentialId && create_if_block_4$2(ctx);

		const block = {
			c: function create() {
				ul = element("ul");
				div0 = element("div");
				t0 = text(t0_value);
				t1 = space();
				div1 = element("div");
				create_component(environmentcredential.$$.fragment);
				t2 = space();
				if (if_block) if_block.c();
				t3 = space();
				attr_dev(div0, "class", "text-osvauld-fieldTextActive text-lg font-medium py-2 border-b border-osvauld-iconblack");
				add_location(div0, file$j, 141, 4, 4466);
				attr_dev(div1, "class", "flex flex-col pr-4 pb-2 pl-0 pt-0 mt-2");
				add_location(div1, file$j, 146, 4, 4626);
				attr_dev(ul, "class", "border border-osvauld-iconblack rounded-xl bg-osvauld-cardshade text-osvauld-fieldText mx-4 px-4 py-2 overflow-x-hidden my-6");
				add_location(ul, file$j, 138, 3, 4316);
			},
			m: function mount(target, anchor) {
				insert_dev(target, ul, anchor);
				append_dev(ul, div0);
				append_dev(div0, t0);
				append_dev(ul, t1);
				append_dev(ul, div1);
				mount_component(environmentcredential, div1, null);
				append_dev(ul, t2);
				if (if_block) if_block.m(ul, null);
				append_dev(ul, t3);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				if ((!current || dirty[0] & /*credentials*/ 64) && t0_value !== (t0_value = /*credential*/ ctx[30].credentialName + "")) set_data_dev(t0, t0_value);
				const environmentcredential_changes = {};
				if (dirty[0] & /*credentials*/ 64) environmentcredential_changes.credential = /*credential*/ ctx[30];

				if (dirty[0] & /*credentials, editedCredential*/ 96) environmentcredential_changes.activefieldId = /*credential*/ ctx[30].credentialId === /*editedCredential*/ ctx[5]?.credentialId
				? /*editedCredential*/ ctx[5]?.fieldId
				: '';

				environmentcredential.$set(environmentcredential_changes);

				if (/*credential*/ ctx[30].credentialId === /*editedCredential*/ ctx[5]?.credentialId) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_4$2(ctx);
						if_block.c();
						if_block.m(ul, t3);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(environmentcredential.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(environmentcredential.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(ul);
				}

				destroy_component(environmentcredential);
				if (if_block) if_block.d();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$2.name,
			type: "each",
			source: "(117:2) {#each credentials as credential}",
			ctx
		});

		return block;
	}

	// (181:0) {#if addcredentialToEnv}
	function create_if_block_2$7(ctx) {
		let button1;
		let button0;
		let addcredentialtoenv;
		let current;
		let mounted;
		let dispose;
		addcredentialtoenv = new AddCredentialToEnv({ $$inline: true });
		addcredentialtoenv.$on("close", /*closeAddCredToEnv*/ ctx[14]);

		const block = {
			c: function create() {
				button1 = element("button");
				button0 = element("button");
				create_component(addcredentialtoenv.$$.fragment);
				attr_dev(button0, "class", "p-6 rounded bg-transparent");
				add_location(button0, file$j, 206, 2, 6731);
				attr_dev(button1, "class", "fixed inset-0 flex items-center justify-center z-50 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px]");
				add_location(button1, file$j, 202, 1, 6553);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button1, anchor);
				append_dev(button1, button0);
				mount_component(addcredentialtoenv, button0, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*click_handler*/ ctx[18]), false, false, true, false),
						listen_dev(button1, "click", /*click_handler_4*/ ctx[27], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(addcredentialtoenv.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(addcredentialtoenv.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button1);
				}

				destroy_component(addcredentialtoenv);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$7.name,
			type: "if",
			source: "(181:0) {#if addcredentialToEnv}",
			ctx
		});

		return block;
	}

	// (191:0) {#if $showAddCliDrawer}
	function create_if_block_1$b(ctx) {
		let button1;
		let button0;
		let addcliuser;
		let current;
		let mounted;
		let dispose;
		addcliuser = new AddCliUser({ $$inline: true });

		const block = {
			c: function create() {
				button1 = element("button");
				button0 = element("button");
				create_component(addcliuser.$$.fragment);
				attr_dev(button0, "class", "p-6 rounded bg-transparent");
				add_location(button0, file$j, 216, 2, 7097);
				attr_dev(button1, "class", "fixed inset-0 flex items-center justify-center z-50 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px]");
				add_location(button1, file$j, 212, 1, 6911);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button1, anchor);
				append_dev(button1, button0);
				mount_component(addcliuser, button0, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*click_handler_1*/ ctx[17]), false, false, true, false),
						listen_dev(button1, "click", /*click_handler_5*/ ctx[28], false, false, false, false)
					];

					mounted = true;
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(addcliuser.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(addcliuser.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button1);
				}

				destroy_component(addcliuser);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$b.name,
			type: "if",
			source: "(191:0) {#if $showAddCliDrawer}",
			ctx
		});

		return block;
	}

	// (201:0) {#if $showAddEnvDrawer}
	function create_if_block$e(ctx) {
		let button1;
		let button0;
		let addenvironment;
		let current;
		let mounted;
		let dispose;
		addenvironment = new AddEnvironment({ $$inline: true });

		const block = {
			c: function create() {
				button1 = element("button");
				button0 = element("button");
				create_component(addenvironment.$$.fragment);
				attr_dev(button0, "class", "p-6 rounded bg-transparent");
				add_location(button0, file$j, 226, 2, 7424);
				attr_dev(button1, "class", "fixed inset-0 flex items-center justify-center z-50 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px]");
				add_location(button1, file$j, 222, 1, 7238);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button1, anchor);
				append_dev(button1, button0);
				mount_component(addenvironment, button0, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", stop_propagation(/*click_handler_2*/ ctx[16]), false, false, true, false),
						listen_dev(button1, "click", /*click_handler_6*/ ctx[29], false, false, false, false)
					];

					mounted = true;
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(addenvironment.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(addenvironment.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button1);
				}

				destroy_component(addenvironment);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$e.name,
			type: "if",
			source: "(201:0) {#if $showAddEnvDrawer}",
			ctx
		});

		return block;
	}

	function create_fragment$j(ctx) {
		let div;
		let h1;
		let t0;
		let current_block_type_index;
		let if_block1;
		let t1;
		let current_block_type_index_1;
		let if_block2;
		let t2;
		let t3;
		let t4;
		let if_block5_anchor;
		let current;

		function select_block_type(ctx, dirty) {
			if (/*$selectedEnv*/ ctx[0]) return create_if_block_6$1;
			return create_else_block_2$2;
		}

		let current_block_type = select_block_type(ctx);
		let if_block0 = current_block_type(ctx);
		const if_block_creators = [create_if_block_5$1, create_else_block_1$5];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*$selectedEnv*/ ctx[0]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_1(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		const if_block_creators_1 = [create_if_block_3$5, create_else_block$9];
		const if_blocks_1 = [];

		function select_block_type_2(ctx, dirty) {
			if (/*$selectedEnv*/ ctx[0]) return 0;
			return 1;
		}

		current_block_type_index_1 = select_block_type_2(ctx);
		if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
		let if_block3 = /*addcredentialToEnv*/ ctx[2] && create_if_block_2$7(ctx);
		let if_block4 = /*$showAddCliDrawer*/ ctx[8] && create_if_block_1$b(ctx);
		let if_block5 = /*$showAddEnvDrawer*/ ctx[9] && create_if_block$e(ctx);

		const block = {
			c: function create() {
				div = element("div");
				h1 = element("h1");
				if_block0.c();
				t0 = space();
				if_block1.c();
				t1 = space();
				if_block2.c();
				t2 = space();
				if (if_block3) if_block3.c();
				t3 = space();
				if (if_block4) if_block4.c();
				t4 = space();
				if (if_block5) if_block5.c();
				if_block5_anchor = empty();
				attr_dev(h1, "class", "text-3xl p-4 font-normal whitespace-nowrap text-osvauld-sideListTextActive");
				add_location(h1, file$j, 91, 1, 2364);
				attr_dev(div, "class", "flex justify-between items-center my-4 p-2");
				add_location(div, file$j, 90, 0, 2306);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, h1);
				if_block0.m(h1, null);
				append_dev(div, t0);
				if_blocks[current_block_type_index].m(div, null);
				insert_dev(target, t1, anchor);
				if_blocks_1[current_block_type_index_1].m(target, anchor);
				insert_dev(target, t2, anchor);
				if (if_block3) if_block3.m(target, anchor);
				insert_dev(target, t3, anchor);
				if (if_block4) if_block4.m(target, anchor);
				insert_dev(target, t4, anchor);
				if (if_block5) if_block5.m(target, anchor);
				insert_dev(target, if_block5_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0.d(1);
					if_block0 = current_block_type(ctx);

					if (if_block0) {
						if_block0.c();
						if_block0.m(h1, null);
					}
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}

				let previous_block_index_1 = current_block_type_index_1;
				current_block_type_index_1 = select_block_type_2(ctx);

				if (current_block_type_index_1 === previous_block_index_1) {
					if_blocks_1[current_block_type_index_1].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
						if_blocks_1[previous_block_index_1] = null;
					});

					check_outros();
					if_block2 = if_blocks_1[current_block_type_index_1];

					if (!if_block2) {
						if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
						if_block2.c();
					} else {
						if_block2.p(ctx, dirty);
					}

					transition_in(if_block2, 1);
					if_block2.m(t2.parentNode, t2);
				}

				if (/*addcredentialToEnv*/ ctx[2]) {
					if (if_block3) {
						if_block3.p(ctx, dirty);

						if (dirty[0] & /*addcredentialToEnv*/ 4) {
							transition_in(if_block3, 1);
						}
					} else {
						if_block3 = create_if_block_2$7(ctx);
						if_block3.c();
						transition_in(if_block3, 1);
						if_block3.m(t3.parentNode, t3);
					}
				} else if (if_block3) {
					group_outros();

					transition_out(if_block3, 1, 1, () => {
						if_block3 = null;
					});

					check_outros();
				}

				if (/*$showAddCliDrawer*/ ctx[8]) {
					if (if_block4) {
						if (dirty[0] & /*$showAddCliDrawer*/ 256) {
							transition_in(if_block4, 1);
						}
					} else {
						if_block4 = create_if_block_1$b(ctx);
						if_block4.c();
						transition_in(if_block4, 1);
						if_block4.m(t4.parentNode, t4);
					}
				} else if (if_block4) {
					group_outros();

					transition_out(if_block4, 1, 1, () => {
						if_block4 = null;
					});

					check_outros();
				}

				if (/*$showAddEnvDrawer*/ ctx[9]) {
					if (if_block5) {
						if (dirty[0] & /*$showAddEnvDrawer*/ 512) {
							transition_in(if_block5, 1);
						}
					} else {
						if_block5 = create_if_block$e(ctx);
						if_block5.c();
						transition_in(if_block5, 1);
						if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
					}
				} else if (if_block5) {
					group_outros();

					transition_out(if_block5, 1, 1, () => {
						if_block5 = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block1);
				transition_in(if_block2);
				transition_in(if_block3);
				transition_in(if_block4);
				transition_in(if_block5);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block1);
				transition_out(if_block2);
				transition_out(if_block3);
				transition_out(if_block4);
				transition_out(if_block5);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
					detach_dev(t1);
					detach_dev(t2);
					detach_dev(t3);
					detach_dev(t4);
					detach_dev(if_block5_anchor);
				}

				if_block0.d();
				if_blocks[current_block_type_index].d();
				if_blocks_1[current_block_type_index_1].d(detaching);
				if (if_block3) if_block3.d(detaching);
				if (if_block4) if_block4.d(detaching);
				if (if_block5) if_block5.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$j.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$j($$self, $$props, $$invalidate) {
		let $selectedEnv;
		let $envStore;
		let $showAddCliDrawer;
		let $showAddEnvDrawer;
		validate_store(selectedEnv, 'selectedEnv');
		component_subscribe($$self, selectedEnv, $$value => $$invalidate(0, $selectedEnv = $$value));
		validate_store(envStore, 'envStore');
		component_subscribe($$self, envStore, $$value => $$invalidate(7, $envStore = $$value));
		validate_store(showAddCliDrawer, 'showAddCliDrawer');
		component_subscribe($$self, showAddCliDrawer, $$value => $$invalidate(8, $showAddCliDrawer = $$value));
		validate_store(showAddEnvDrawer, 'showAddEnvDrawer');
		component_subscribe($$self, showAddEnvDrawer, $$value => $$invalidate(9, $showAddEnvDrawer = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Environments', slots, []);
		let addCredentialHovered = false;
		let addcredentialToEnv = false;
		let addNewUserHovered = false;
		let addNewCliUserHovered = false;
		let editedCredential;
		let credentials = [];

		const addEnv = () => {
			showAddEnvDrawer.set(true);
		};

		const addCliUser = () => {
			showAddCliDrawer.set(true);
		};

		const handleEditField = (credentialId, fieldId, fieldName) => {
			if ($selectedEnv === null) return;

			$$invalidate(5, editedCredential = {
				credentialId,
				environmentId: $selectedEnv.id,
				fieldId,
				fieldName
			});
		};

		const closeEditOption = async () => {
			$$invalidate(5, editedCredential = null);
			if ($selectedEnv === null) return;
			const fieldsResponse = await fetchEnvFields($selectedEnv.id);
			$$invalidate(6, credentials = fieldsResponse.data);
		};

		const closeAddCredToEnv = async () => {
			$$invalidate(2, addcredentialToEnv = false);
			if ($selectedEnv === null) return;
			const fieldsResponse = await fetchEnvFields($selectedEnv.id);
			$$invalidate(6, credentials = fieldsResponse.data);
		};

		const handleSaveChange = async () => {
			if (editedCredential === null || $selectedEnv === null) return;

			const editResponse = await editEnvCredentialField({
				fieldID: editedCredential.fieldId,
				fieldName: editedCredential.fieldName,
				environmentID: editedCredential.environmentId
			});

			$$invalidate(5, editedCredential = null);

			toastStore.set({
				type: editResponse.success,
				message: "Changed FieldName Successfully",
				show: true
			});

			const fieldsResponse = await fetchEnvFields($selectedEnv.id);
			$$invalidate(6, credentials = fieldsResponse.data);
		};

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Environments> was created with unknown prop '${key}'`);
		});

		function click_handler_2(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler_1(event) {
			bubble.call(this, $$self, event);
		}

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		const mouseenter_handler = () => $$invalidate(1, addCredentialHovered = true);
		const mouseleave_handler = () => $$invalidate(1, addCredentialHovered = false);
		const click_handler_3 = () => $$invalidate(2, addcredentialToEnv = true);
		const mouseenter_handler_1 = () => $$invalidate(4, addNewCliUserHovered = true);
		const mouseleave_handler_1 = () => $$invalidate(4, addNewCliUserHovered = false);
		const mouseenter_handler_2 = () => $$invalidate(3, addNewUserHovered = true);
		const mouseleave_handler_2 = () => $$invalidate(3, addNewUserHovered = false);
		const edit_handler = (credential, e) => handleEditField(credential.credentialId, e.detail.fieldId, e.detail.fieldName);
		const click_handler_4 = () => !addcredentialToEnv;
		const click_handler_5 = () => showAddCliDrawer.set(false);
		const click_handler_6 = () => showAddEnvDrawer.set(false);

		$$self.$capture_state = () => ({
			selectedEnv,
			showAddCliDrawer,
			envStore,
			showAddEnvDrawer,
			toastStore,
			AddCredentialToEnv,
			AddCliUser,
			Add,
			fetchEnvFields,
			editEnvCredentialField,
			EnvironmentAdd,
			UserPlus,
			AddEnvironment,
			EnvironmentCredential,
			addCredentialHovered,
			addcredentialToEnv,
			addNewUserHovered,
			addNewCliUserHovered,
			editedCredential,
			credentials,
			addEnv,
			addCliUser,
			handleEditField,
			closeEditOption,
			closeAddCredToEnv,
			handleSaveChange,
			$selectedEnv,
			$envStore,
			$showAddCliDrawer,
			$showAddEnvDrawer
		});

		$$self.$inject_state = $$props => {
			if ('addCredentialHovered' in $$props) $$invalidate(1, addCredentialHovered = $$props.addCredentialHovered);
			if ('addcredentialToEnv' in $$props) $$invalidate(2, addcredentialToEnv = $$props.addcredentialToEnv);
			if ('addNewUserHovered' in $$props) $$invalidate(3, addNewUserHovered = $$props.addNewUserHovered);
			if ('addNewCliUserHovered' in $$props) $$invalidate(4, addNewCliUserHovered = $$props.addNewCliUserHovered);
			if ('editedCredential' in $$props) $$invalidate(5, editedCredential = $$props.editedCredential);
			if ('credentials' in $$props) $$invalidate(6, credentials = $$props.credentials);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty[0] & /*$selectedEnv*/ 1) {
				if ($selectedEnv) {
					fetchEnvFields($selectedEnv.id).then(res => {
						$$invalidate(6, credentials = res.data);
					});
				}
			}
		};

		return [
			$selectedEnv,
			addCredentialHovered,
			addcredentialToEnv,
			addNewUserHovered,
			addNewCliUserHovered,
			editedCredential,
			credentials,
			$envStore,
			$showAddCliDrawer,
			$showAddEnvDrawer,
			addEnv,
			addCliUser,
			handleEditField,
			closeEditOption,
			closeAddCredToEnv,
			handleSaveChange,
			click_handler_2,
			click_handler_1,
			click_handler,
			mouseenter_handler,
			mouseleave_handler,
			click_handler_3,
			mouseenter_handler_1,
			mouseleave_handler_1,
			mouseenter_handler_2,
			mouseleave_handler_2,
			edit_handler,
			click_handler_4,
			click_handler_5,
			click_handler_6
		];
	}

	class Environments extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$j, create_fragment$j, safe_not_equal, {}, null, [-1, -1]);

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Environments",
				options,
				id: create_fragment$j.name
			});
		}
	}

	/* src/lib/components/dashboard/components/ProfileModal.svelte generated by Svelte v4.2.19 */
	const file$i = "src/lib/components/dashboard/components/ProfileModal.svelte";

	// (72:4) {:else}
	function create_else_block$8(ctx) {
		let copyicon;
		let current;

		copyicon = new CopyIcon({
				props: {
					color: /*isUsernameHovered*/ ctx[2] ? '#F2F2F0' : '#85889C'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(copyicon.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(copyicon, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const copyicon_changes = {};
				if (dirty & /*isUsernameHovered*/ 4) copyicon_changes.color = /*isUsernameHovered*/ ctx[2] ? '#F2F2F0' : '#85889C';
				copyicon.$set(copyicon_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(copyicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(copyicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(copyicon, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$8.name,
			type: "else",
			source: "(72:4) {:else}",
			ctx
		});

		return block;
	}

	// (68:4) {#if copied && isUsernameHovered}
	function create_if_block$d(ctx) {
		let span;
		let tick_1;
		let span_intro;
		let current;
		tick_1 = new Tick({ $$inline: true });

		const block = {
			c: function create() {
				span = element("span");
				create_component(tick_1.$$.fragment);
				add_location(span, file$i, 80, 5, 2110);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				mount_component(tick_1, span, null);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(tick_1.$$.fragment, local);

				if (local) {
					if (!span_intro) {
						add_render_callback(() => {
							span_intro = create_in_transition(span, scale, {});
							span_intro.start();
						});
					}
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(tick_1.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				destroy_component(tick_1);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$d.name,
			type: "if",
			source: "(68:4) {#if copied && isUsernameHovered}",
			ctx
		});

		return block;
	}

	function create_fragment$i(ctx) {
		let div7;
		let div6;
		let button0;
		let div0;
		let current_block_type_index;
		let if_block;
		let t0;
		let div1;
		let t2;
		let button1;
		let div2;
		let copyicon;
		let t3;
		let div3;
		let t5;
		let button2;
		let div4;
		let key;
		let t6;
		let div5;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block$d, create_else_block$8];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*copied*/ ctx[5] && /*isUsernameHovered*/ ctx[2]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		copyicon = new CopyIcon({
				props: {
					color: /*isRecoveryHovered*/ ctx[3] ? '#FF6A6A' : '#85889C'
				},
				$$inline: true
			});

		key = new Key({
				props: {
					color: /*isChangePasswordHovered*/ ctx[4]
					? '#FF6A6A'
					: '#85889C',
					size: 24
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				div7 = element("div");
				div6 = element("div");
				button0 = element("button");
				div0 = element("div");
				if_block.c();
				t0 = space();
				div1 = element("div");
				div1.textContent = "Copy username";
				t2 = space();
				button1 = element("button");
				div2 = element("div");
				create_component(copyicon.$$.fragment);
				t3 = space();
				div3 = element("div");
				div3.textContent = "Copy recovery data";
				t5 = space();
				button2 = element("button");
				div4 = element("div");
				create_component(key.$$.fragment);
				t6 = space();
				div5 = element("div");
				div5.textContent = "Change passphrase";
				attr_dev(div0, "class", "w-6 h-6 flex items-center justify-center");
				add_location(div0, file$i, 78, 3, 2012);
				attr_dev(div1, "class", "font-inter text-base whitespace-nowrap");
				add_location(div1, file$i, 87, 3, 2259);
				attr_dev(button0, "class", "flex items-center p-2 gap-2 w-full h-12 text-osvauld-fieldText hover:text-osvauld-sideListTextActive hover:bg-osvauld-modalFieldActive rounded-lg");
				add_location(button0, file$i, 73, 2, 1690);
				attr_dev(div2, "class", "w-6 h-6 flex items-center justify-center");
				add_location(div2, file$i, 95, 3, 2663);
				attr_dev(div3, "class", "font-inter text-base whitespace-nowrap");
				add_location(div3, file$i, 98, 3, 2800);
				attr_dev(button1, "class", "flex items-center p-2 gap-2 w-full h-12 text-osvauld-fieldText hover:text-osvauld-dangerRed hover:bg-osvauld-modalFieldActive rounded-lg");
				add_location(button1, file$i, 90, 2, 2346);
				attr_dev(div4, "class", "w-6 h-6 flex items-center justify-center");
				add_location(div4, file$i, 108, 3, 3235);
				attr_dev(div5, "class", "font-inter text-base whitespace-nowrap");
				add_location(div5, file$i, 113, 3, 3395);
				attr_dev(button2, "class", "flex items-center p-2 gap-2 w-full h-12 text-osvauld-fieldText hover:text-osvauld-dangerRed hover:bg-osvauld-modalFieldActive rounded-lg");
				add_location(button2, file$i, 103, 2, 2901);
				attr_dev(div6, "class", "flex flex-col items-start p-2 gap-2 w-full h-full");
				add_location(div6, file$i, 72, 1, 1624);
				attr_dev(div7, "class", "absolute z-50 bg-osvauld-frameblack border border-osvauld-iconblack w-[14rem] rounded-2xl");
				set_style(div7, "top", /*top*/ ctx[0] + 10 + "px");
				set_style(div7, "left", /*left*/ ctx[1] - 100 + "px");
				add_location(div7, file$i, 67, 0, 1410);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div7, anchor);
				append_dev(div7, div6);
				append_dev(div6, button0);
				append_dev(button0, div0);
				if_blocks[current_block_type_index].m(div0, null);
				append_dev(button0, t0);
				append_dev(button0, div1);
				append_dev(div6, t2);
				append_dev(div6, button1);
				append_dev(button1, div2);
				mount_component(copyicon, div2, null);
				append_dev(button1, t3);
				append_dev(button1, div3);
				append_dev(div6, t5);
				append_dev(div6, button2);
				append_dev(button2, div4);
				mount_component(key, div4, null);
				append_dev(button2, t6);
				append_dev(button2, div5);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false, false),
						listen_dev(button0, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false, false),
						listen_dev(button0, "click", prevent_default(/*copyUsername*/ ctx[7]), false, true, false, false),
						listen_dev(button1, "mouseenter", /*mouseenter_handler_1*/ ctx[13], false, false, false, false),
						listen_dev(button1, "mouseleave", /*mouseleave_handler_1*/ ctx[14], false, false, false, false),
						listen_dev(button1, "click", prevent_default(/*passwordprompter*/ ctx[8]), false, true, false, false),
						listen_dev(button2, "mouseenter", /*mouseenter_handler_2*/ ctx[15], false, false, false, false),
						listen_dev(button2, "mouseleave", /*mouseleave_handler_2*/ ctx[16], false, false, false, false),
						listen_dev(button2, "click", prevent_default(/*initatePasswordChange*/ ctx[9]), false, true, false, false),
						action_destroyer(clickOutside.call(null, div7)),
						listen_dev(div7, "clickOutside", /*handleClickOutside*/ ctx[6], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div0, null);
				}

				const copyicon_changes = {};
				if (dirty & /*isRecoveryHovered*/ 8) copyicon_changes.color = /*isRecoveryHovered*/ ctx[3] ? '#FF6A6A' : '#85889C';
				copyicon.$set(copyicon_changes);
				const key_changes = {};

				if (dirty & /*isChangePasswordHovered*/ 16) key_changes.color = /*isChangePasswordHovered*/ ctx[4]
				? '#FF6A6A'
				: '#85889C';

				key.$set(key_changes);

				if (!current || dirty & /*top*/ 1) {
					set_style(div7, "top", /*top*/ ctx[0] + 10 + "px");
				}

				if (!current || dirty & /*left*/ 2) {
					set_style(div7, "left", /*left*/ ctx[1] - 100 + "px");
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				transition_in(copyicon.$$.fragment, local);
				transition_in(key.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				transition_out(copyicon.$$.fragment, local);
				transition_out(key.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div7);
				}

				if_blocks[current_block_type_index].d();
				destroy_component(copyicon);
				destroy_component(key);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$i.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$i($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ProfileModal', slots, []);
		const dispatch = createEventDispatcher();
		let { top } = $$props;
		let { left } = $$props;
		let { username } = $$props;
		let isUsernameHovered = false;
		let isRecoveryHovered = false;
		let isChangePasswordHovered = false;
		let copied = false;

		function closeModal() {
			dispatch("close", true);
		}

		const handleKeyDown = event => {
			if (event.key === "Escape") {
				closeModal();
			}
		};

		const handleClickOutside = e => {
			e.stopPropagation();
			e.preventDefault();
			closeModal();
		};

		const delayFunction = () => {
			$$invalidate(5, copied = true);

			setTimeout(
				() => {
					$$invalidate(5, copied = false);
				},
				1500
			);
		};

		const copyUsername = async () => {
			await writeToClipboard(username);
			delayFunction();
		};

		const passwordprompter = async () => {
			promptPassword.set(true);
			closeModal();
		};

		const initatePasswordChange = () => {
			promptPassword.set(true);
			changePassword.set(true);
			closeModal();
		};

		onMount(() => {
			window.addEventListener("keydown", handleKeyDown);
		});

		onDestroy(() => {
			window.removeEventListener("keydown", handleKeyDown);
		});

		$$self.$$.on_mount.push(function () {
			if (top === undefined && !('top' in $$props || $$self.$$.bound[$$self.$$.props['top']])) {
				console.warn("<ProfileModal> was created without expected prop 'top'");
			}

			if (left === undefined && !('left' in $$props || $$self.$$.bound[$$self.$$.props['left']])) {
				console.warn("<ProfileModal> was created without expected prop 'left'");
			}

			if (username === undefined && !('username' in $$props || $$self.$$.bound[$$self.$$.props['username']])) {
				console.warn("<ProfileModal> was created without expected prop 'username'");
			}
		});

		const writable_props = ['top', 'left', 'username'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ProfileModal> was created with unknown prop '${key}'`);
		});

		const mouseenter_handler = () => $$invalidate(2, isUsernameHovered = true);
		const mouseleave_handler = () => $$invalidate(2, isUsernameHovered = false);
		const mouseenter_handler_1 = () => $$invalidate(3, isRecoveryHovered = true);
		const mouseleave_handler_1 = () => $$invalidate(3, isRecoveryHovered = false);
		const mouseenter_handler_2 = () => $$invalidate(4, isChangePasswordHovered = true);
		const mouseleave_handler_2 = () => $$invalidate(4, isChangePasswordHovered = false);

		$$self.$$set = $$props => {
			if ('top' in $$props) $$invalidate(0, top = $$props.top);
			if ('left' in $$props) $$invalidate(1, left = $$props.left);
			if ('username' in $$props) $$invalidate(10, username = $$props.username);
		};

		$$self.$capture_state = () => ({
			clickOutside,
			onMount,
			onDestroy,
			CopyIcon,
			Key,
			Tick,
			createEventDispatcher,
			scale,
			writeToClipboard,
			promptPassword,
			changePassword,
			dispatch,
			top,
			left,
			username,
			isUsernameHovered,
			isRecoveryHovered,
			isChangePasswordHovered,
			copied,
			closeModal,
			handleKeyDown,
			handleClickOutside,
			delayFunction,
			copyUsername,
			passwordprompter,
			initatePasswordChange
		});

		$$self.$inject_state = $$props => {
			if ('top' in $$props) $$invalidate(0, top = $$props.top);
			if ('left' in $$props) $$invalidate(1, left = $$props.left);
			if ('username' in $$props) $$invalidate(10, username = $$props.username);
			if ('isUsernameHovered' in $$props) $$invalidate(2, isUsernameHovered = $$props.isUsernameHovered);
			if ('isRecoveryHovered' in $$props) $$invalidate(3, isRecoveryHovered = $$props.isRecoveryHovered);
			if ('isChangePasswordHovered' in $$props) $$invalidate(4, isChangePasswordHovered = $$props.isChangePasswordHovered);
			if ('copied' in $$props) $$invalidate(5, copied = $$props.copied);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			top,
			left,
			isUsernameHovered,
			isRecoveryHovered,
			isChangePasswordHovered,
			copied,
			handleClickOutside,
			copyUsername,
			passwordprompter,
			initatePasswordChange,
			username,
			mouseenter_handler,
			mouseleave_handler,
			mouseenter_handler_1,
			mouseleave_handler_1,
			mouseenter_handler_2,
			mouseleave_handler_2
		];
	}

	class ProfileModal extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$i, create_fragment$i, safe_not_equal, { top: 0, left: 1, username: 10 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ProfileModal",
				options,
				id: create_fragment$i.name
			});
		}

		get top() {
			throw new Error("<ProfileModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set top(value) {
			throw new Error("<ProfileModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get left() {
			throw new Error("<ProfileModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set left(value) {
			throw new Error("<ProfileModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get username() {
			throw new Error("<ProfileModal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set username(value) {
			throw new Error("<ProfileModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/RightContainer.svelte generated by Svelte v4.2.19 */
	const file$h = "src/lib/components/dashboard/RightContainer.svelte";

	// (137:1) {#if isProfileClicked}
	function create_if_block_4$1(ctx) {
		let profilemodal;
		let current;

		profilemodal = new ProfileModal({
				props: {
					top: /*top*/ ctx[3],
					left: /*left*/ ctx[4],
					username: /*username*/ ctx[6]
				},
				$$inline: true
			});

		profilemodal.$on("close", /*handleProfileClose*/ ctx[15]);

		const block = {
			c: function create() {
				create_component(profilemodal.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(profilemodal, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const profilemodal_changes = {};
				if (dirty & /*top*/ 8) profilemodal_changes.top = /*top*/ ctx[3];
				if (dirty & /*left*/ 16) profilemodal_changes.left = /*left*/ ctx[4];
				if (dirty & /*username*/ 64) profilemodal_changes.username = /*username*/ ctx[6];
				profilemodal.$set(profilemodal_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(profilemodal.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(profilemodal.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(profilemodal, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_4$1.name,
			type: "if",
			source: "(137:1) {#if isProfileClicked}",
			ctx
		});

		return block;
	}

	// (141:1) {#if showModal}
	function create_if_block_3$4(ctx) {
		let searchmodal;
		let current;

		searchmodal = new SearchModal({
				props: {
					searchResults: /*searchResults*/ ctx[0],
					query: /*query*/ ctx[5]
				},
				$$inline: true
			});

		searchmodal.$on("close", /*closeModal*/ ctx[11]);
		searchmodal.$on("select", /*handleSearchClick*/ ctx[12]);
		searchmodal.$on("change", /*handleInputChange*/ ctx[10]);
		searchmodal.$on("enter", /*handleKeyDown*/ ctx[13]);

		const block = {
			c: function create() {
				create_component(searchmodal.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(searchmodal, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const searchmodal_changes = {};
				if (dirty & /*searchResults*/ 1) searchmodal_changes.searchResults = /*searchResults*/ ctx[0];
				if (dirty & /*query*/ 32) searchmodal_changes.query = /*query*/ ctx[5];
				searchmodal.$set(searchmodal_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(searchmodal.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(searchmodal.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(searchmodal, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$4.name,
			type: "if",
			source: "(141:1) {#if showModal}",
			ctx
		});

		return block;
	}

	// (156:39) 
	function create_if_block_2$6(ctx) {
		let grouplist;
		let current;
		grouplist = new GroupList({ $$inline: true });

		const block = {
			c: function create() {
				create_component(grouplist.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(grouplist, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(grouplist.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(grouplist.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(grouplist, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$6.name,
			type: "if",
			source: "(156:39) ",
			ctx
		});

		return block;
	}

	// (154:79) 
	function create_if_block_1$a(ctx) {
		let environments;
		let current;
		environments = new Environments({ $$inline: true });

		const block = {
			c: function create() {
				create_component(environments.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(environments, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(environments.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(environments.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(environments, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$a.name,
			type: "if",
			source: "(154:79) ",
			ctx
		});

		return block;
	}

	// (152:2) {#if $selectedPage === "Folders" && ($selectedSection === "SharedFolders" || $selectedSection === "PrivateFolders")}
	function create_if_block$c(ctx) {
		let credentiallist;
		let current;
		credentiallist = new CredentialList({ $$inline: true });

		const block = {
			c: function create() {
				create_component(credentiallist.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(credentiallist, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(credentiallist.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(credentiallist.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(credentiallist, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$c.name,
			type: "if",
			source: "(152:2) {#if $selectedPage === \\\"Folders\\\" && ($selectedSection === \\\"SharedFolders\\\" || $selectedSection === \\\"PrivateFolders\\\")}",
			ctx
		});

		return block;
	}

	function create_fragment$h(ctx) {
		let div4;
		let div2;
		let div0;
		let lens;
		let t0;
		let input;
		let t1;
		let button;
		let div1;
		let profile;
		let span0;
		let t2;
		let span0_class_value;
		let t3;
		let span1;
		let downarrow;
		let span1_class_value;
		let t4;
		let t5;
		let t6;
		let div3;
		let current_block_type_index;
		let if_block2;
		let current;
		let mounted;
		let dispose;
		lens = new Lens({ $$inline: true });

		profile = new Profile({
				props: {
					color: /*isProfileClicked*/ ctx[2] ? '#F2F2F0' : '#85889C'
				},
				$$inline: true
			});

		downarrow = new DownArrow({
				props: {
					type: /*isProfileClicked*/ ctx[2]
					? 'profileActive'
					: 'profile'
				},
				$$inline: true
			});

		let if_block0 = /*isProfileClicked*/ ctx[2] && create_if_block_4$1(ctx);
		let if_block1 = /*showModal*/ ctx[1] && create_if_block_3$4(ctx);
		const if_block_creators = [create_if_block$c, create_if_block_1$a, create_if_block_2$6];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*$selectedPage*/ ctx[7] === "Folders" && (/*$selectedSection*/ ctx[8] === "SharedFolders" || /*$selectedSection*/ ctx[8] === "PrivateFolders")) return 0;
			if (/*$selectedPage*/ ctx[7] === "Folders" && /*$selectedSection*/ ctx[8] === "Environments") return 1;
			if (/*$selectedPage*/ ctx[7] === "Groups") return 2;
			return -1;
		}

		if (~(current_block_type_index = select_block_type(ctx))) {
			if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		const block = {
			c: function create() {
				div4 = element("div");
				div2 = element("div");
				div0 = element("div");
				create_component(lens.$$.fragment);
				t0 = space();
				input = element("input");
				t1 = space();
				button = element("button");
				div1 = element("div");
				create_component(profile.$$.fragment);
				span0 = element("span");
				t2 = text(/*username*/ ctx[6]);
				t3 = space();
				span1 = element("span");
				create_component(downarrow.$$.fragment);
				t4 = space();
				if (if_block0) if_block0.c();
				t5 = space();
				if (if_block1) if_block1.c();
				t6 = space();
				div3 = element("div");
				if (if_block2) if_block2.c();
				attr_dev(input, "type", "text");
				attr_dev(input, "class", "h-[2rem] w-full bg-osvauld-frameblack border-0 text-osvauld-quarzowhite placeholder-osvauld-placeholderblack border-transparent text-base focus:border-transparent focus:ring-0 cursor-pointer");
				attr_dev(input, "placeholder", "Search..");
				add_location(input, file$h, 127, 3, 3489);
				attr_dev(div0, "class", "h-[2.2rem] w-[31.25rem] px-2 mx-auto flex justify-start items-center border border-osvauld-iconblack focus-within:border-osvauld-activeBorder rounded-lg cursor-pointer");
				add_location(div0, file$h, 123, 2, 3286);

				attr_dev(span0, "class", span0_class_value = "font-inter text-base overflow-hidden max-w-[6rem] text-ellipsis whitespace-nowrap " + (/*isProfileClicked*/ ctx[2]
				? 'text-osvauld-sideListTextActive'
				: 'text-osvauld-fieldText') + "");

				add_location(span0, file$h, 143, 66, 4244);
				attr_dev(div1, "class", "flex justify-center items-center");
				add_location(div1, file$h, 142, 3, 4131);
				attr_dev(span1, "class", span1_class_value = "transition-transform duration-100 ease-linear " + (/*isProfileClicked*/ ctx[2] ? 'rotate-180' : 'rotate-0'));
				add_location(span1, file$h, 149, 3, 4476);
				attr_dev(button, "class", "profile-button min-w-[8rem] max-w-[12rem] bg-osvauld-cardshade rounded-md flex justify-around text-osvauld-fieldText items-center cursor-pointer py-1");
				add_location(button, file$h, 138, 2, 3899);
				attr_dev(div2, "class", "h-[6rem] pr-4 flex justify-between items-center border-b border-osvauld-iconblack");
				add_location(div2, file$h, 120, 1, 3184);
				attr_dev(div3, "class", "h-[90vh] bg-osvauld-frameblack mr-4 overflow-hidden");
				add_location(div3, file$h, 173, 1, 5017);
				attr_dev(div4, "class", "flex flex-col h-auto");
				add_location(div4, file$h, 119, 0, 3148);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div4, anchor);
				append_dev(div4, div2);
				append_dev(div2, div0);
				mount_component(lens, div0, null);
				append_dev(div0, t0);
				append_dev(div0, input);
				set_input_value(input, /*query*/ ctx[5]);
				append_dev(div2, t1);
				append_dev(div2, button);
				append_dev(button, div1);
				mount_component(profile, div1, null);
				append_dev(div1, span0);
				append_dev(span0, t2);
				append_dev(button, t3);
				append_dev(button, span1);
				mount_component(downarrow, span1, null);
				append_dev(div4, t4);
				if (if_block0) if_block0.m(div4, null);
				append_dev(div4, t5);
				if (if_block1) if_block1.m(div4, null);
				append_dev(div4, t6);
				append_dev(div4, div3);

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(div3, null);
				}

				current = true;

				if (!mounted) {
					dispose = [
						action_destroyer(autofocus.call(null, input)),
						listen_dev(input, "click", /*getSearchData*/ ctx[9], false, false, false, false),
						listen_dev(input, "input", /*handleInputChange*/ ctx[10], false, false, false, false),
						listen_dev(input, "input", /*input_input_handler*/ ctx[16]),
						listen_dev(input, "keyup", /*handleKeyDown*/ ctx[13], false, false, false, false),
						listen_dev(button, "click", stop_propagation(/*profileSelectionManager*/ ctx[14]), false, false, true, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*query*/ 32 && input.value !== /*query*/ ctx[5]) {
					set_input_value(input, /*query*/ ctx[5]);
				}

				const profile_changes = {};
				if (dirty & /*isProfileClicked*/ 4) profile_changes.color = /*isProfileClicked*/ ctx[2] ? '#F2F2F0' : '#85889C';
				profile.$set(profile_changes);
				if (!current || dirty & /*username*/ 64) set_data_dev(t2, /*username*/ ctx[6]);

				if (!current || dirty & /*isProfileClicked*/ 4 && span0_class_value !== (span0_class_value = "font-inter text-base overflow-hidden max-w-[6rem] text-ellipsis whitespace-nowrap " + (/*isProfileClicked*/ ctx[2]
				? 'text-osvauld-sideListTextActive'
				: 'text-osvauld-fieldText') + "")) {
					attr_dev(span0, "class", span0_class_value);
				}

				const downarrow_changes = {};

				if (dirty & /*isProfileClicked*/ 4) downarrow_changes.type = /*isProfileClicked*/ ctx[2]
				? 'profileActive'
				: 'profile';

				downarrow.$set(downarrow_changes);

				if (!current || dirty & /*isProfileClicked*/ 4 && span1_class_value !== (span1_class_value = "transition-transform duration-100 ease-linear " + (/*isProfileClicked*/ ctx[2] ? 'rotate-180' : 'rotate-0'))) {
					attr_dev(span1, "class", span1_class_value);
				}

				if (/*isProfileClicked*/ ctx[2]) {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*isProfileClicked*/ 4) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_4$1(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div4, t5);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*showModal*/ ctx[1]) {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*showModal*/ 2) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_3$4(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div4, t6);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index !== previous_block_index) {
					if (if_block2) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block2 = if_blocks[current_block_type_index];

						if (!if_block2) {
							if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block2.c();
						}

						transition_in(if_block2, 1);
						if_block2.m(div3, null);
					} else {
						if_block2 = null;
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(lens.$$.fragment, local);
				transition_in(profile.$$.fragment, local);
				transition_in(downarrow.$$.fragment, local);
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				current = true;
			},
			o: function outro(local) {
				transition_out(lens.$$.fragment, local);
				transition_out(profile.$$.fragment, local);
				transition_out(downarrow.$$.fragment, local);
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div4);
				}

				destroy_component(lens);
				destroy_component(profile);
				destroy_component(downarrow);
				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d();
				}

				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$h.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function autofocus(node) {
		node.focus();
	}

	function instance$h($$self, $$props, $$invalidate) {
		let $folderStore;
		let $selectedPage;
		let $selectedSection;
		validate_store(folderStore, 'folderStore');
		component_subscribe($$self, folderStore, $$value => $$invalidate(19, $folderStore = $$value));
		validate_store(selectedPage, 'selectedPage');
		component_subscribe($$self, selectedPage, $$value => $$invalidate(7, $selectedPage = $$value));
		validate_store(selectedSection, 'selectedSection');
		component_subscribe($$self, selectedSection, $$value => $$invalidate(8, $selectedSection = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('RightContainer', slots, []);
		let searchResults = [];
		let searchData = [];
		let showModal = false;
		let isProfileClicked = false;
		let clickedOutside = false;
		let top = 0;
		let left = 0;
		let query = "";
		let username = "";

		const getSearchData = async () => {
			$$invalidate(1, showModal = true);
			const searchFieldSResponse = await getSearchFields();
			searchData = searchFieldSResponse.data;
			const urlJson = await fetchAllUserUrls();
			const urls = urlJson.data;
			const decryptedData = await sendMessage("getDecryptedUrls", urls);

			const mergedArray = searchData.map(item => {
				const replacement = decryptedData.find(decryptedItem => decryptedItem.credentialId === item.credentialId);

				if (replacement) {
					return { ...item, domain: replacement.value };
				}

				return item;
			});

			searchData = mergedArray;

			$$invalidate(0, searchResults = query.length !== 0
			? searchObjects(query, searchData)
			: []);
		};

		const handleInputChange = e => {
			const query = e.type === "input" ? e.target.value : e.detail;

			$$invalidate(0, searchResults = query.length >= 1
			? searchObjects(query, searchData)
			: []);
		};

		const closeModal = () => {
			$$invalidate(1, showModal = false);
			$$invalidate(5, query = "");
			$$invalidate(0, searchResults = []);
		};

		const handleSearchClick = e => {
			searchedCredential.set(e.detail);
			selectedPage.set("Folders");

			if (e.detail.folderType === "shared") {
				selectedSection.set("SharedFolders");
			} else if (e.detail.folderType === "private") {
				selectedSection.set("PrivateFolders");
			}

			for (const folder of $folderStore) {
				if (folder.id === e.detail.folderId) {
					selectedFolder.set(folder);
					break;
				}
			}

			closeModal();
		};

		selectedPage.subscribe(() => {
			credentialStore.set([]);
		});

		function handleKeyDown(event) {
			if (event.key === "Enter") {
				getSearchData();
			}
		}

		function profileSelectionManager(e) {
			if (!clickedOutside) {
				const rect = e.currentTarget.getBoundingClientRect();
				$$invalidate(3, top = rect.top + window.scrollY + rect.height);
				$$invalidate(4, left = rect.left + window.scrollX);
				$$invalidate(2, isProfileClicked = !isProfileClicked);
			}
		}

		const handleProfileClose = () => {
			$$invalidate(2, isProfileClicked = false);
			clickedOutside = true;

			setTimeout(
				() => {
					clickedOutside = false;
				},
				100
			);
		};

		onMount(async () => {
			const account = await getUserDetails();
			$$invalidate(6, username = account.username);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RightContainer> was created with unknown prop '${key}'`);
		});

		function input_input_handler() {
			query = this.value;
			$$invalidate(5, query);
		}

		$$self.$capture_state = () => ({
			CredentialList,
			GroupList,
			SearchModal,
			Environments,
			searchObjects,
			getSearchFields,
			fetchAllUserUrls,
			Profile,
			Lens,
			DownArrow,
			sendMessage,
			getUserDetails,
			onMount,
			selectedFolder,
			selectedPage,
			credentialStore,
			searchedCredential,
			folderStore,
			selectedSection,
			ProfileModal,
			searchResults,
			searchData,
			showModal,
			isProfileClicked,
			clickedOutside,
			top,
			left,
			query,
			username,
			getSearchData,
			handleInputChange,
			closeModal,
			handleSearchClick,
			handleKeyDown,
			profileSelectionManager,
			autofocus,
			handleProfileClose,
			$folderStore,
			$selectedPage,
			$selectedSection
		});

		$$self.$inject_state = $$props => {
			if ('searchResults' in $$props) $$invalidate(0, searchResults = $$props.searchResults);
			if ('searchData' in $$props) searchData = $$props.searchData;
			if ('showModal' in $$props) $$invalidate(1, showModal = $$props.showModal);
			if ('isProfileClicked' in $$props) $$invalidate(2, isProfileClicked = $$props.isProfileClicked);
			if ('clickedOutside' in $$props) clickedOutside = $$props.clickedOutside;
			if ('top' in $$props) $$invalidate(3, top = $$props.top);
			if ('left' in $$props) $$invalidate(4, left = $$props.left);
			if ('query' in $$props) $$invalidate(5, query = $$props.query);
			if ('username' in $$props) $$invalidate(6, username = $$props.username);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			searchResults,
			showModal,
			isProfileClicked,
			top,
			left,
			query,
			username,
			$selectedPage,
			$selectedSection,
			getSearchData,
			handleInputChange,
			closeModal,
			handleSearchClick,
			handleKeyDown,
			profileSelectionManager,
			handleProfileClose,
			input_input_handler
		];
	}

	class RightContainer extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "RightContainer",
				options,
				id: create_fragment$h.name
			});
		}
	}

	/* src/lib/components/dashboard/components/MoreActions.svelte generated by Svelte v4.2.19 */

	const { Error: Error_1$1 } = globals;
	const file$g = "src/lib/components/dashboard/components/MoreActions.svelte";

	// (72:0) {#if $showMoreOptions && $buttonRef && $modalManager}
	function create_if_block$b(ctx) {
		let div3;
		let div2;
		let t0;
		let t1;
		let button;
		let div0;
		let binicon;
		let t2;
		let div1;
		let t3;
		let t4_value = (/*moreOptionType*/ ctx[1] === "Folder" ? "folder" : "") + "";
		let t4;
		let div3_class_value;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*$selectedSection*/ ctx[9] !== "PrivateFolders" && create_if_block_2$5(ctx);
		let if_block1 = /*moreOptionType*/ ctx[1] === "Folder" && create_if_block_1$9(ctx);

		binicon = new BinIcon({
				props: {
					color: /*isBinHovered*/ ctx[4] ? '#F2F2F0' : '#85889C'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				div3 = element("div");
				div2 = element("div");
				if (if_block0) if_block0.c();
				t0 = space();
				if (if_block1) if_block1.c();
				t1 = space();
				button = element("button");
				div0 = element("div");
				create_component(binicon.$$.fragment);
				t2 = space();
				div1 = element("div");
				t3 = text("Delete ");
				t4 = text(t4_value);
				attr_dev(div0, "class", "w-6 h-6 flex items-center justify-center");
				add_location(div0, file$g, 144, 4, 4311);
				attr_dev(div1, "class", "font-inter text-base whitespace-nowrap");
				add_location(div1, file$g, 147, 4, 4445);
				attr_dev(button, "class", "flex justify-start gap-2 items-center w-full p-2 text-osvauld-fieldText hover:text-osvauld-sideListTextActive hover:bg-osvauld-modalFieldActive rounded-lg cursor-pointer");
				add_location(button, file$g, 138, 3, 3964);
				attr_dev(div2, "class", "flex flex-col items-start p-2 gap-2 w-full h-full");
				add_location(div2, file$g, 103, 2, 2509);

				attr_dev(div3, "class", div3_class_value = "absolute z-50 bg-osvauld-frameblack border border-osvauld-iconblack " + (/*moreOptionType*/ ctx[1] === 'Folder'
				? 'w-[166px]'
				: 'w-[130px]') + " rounded-2xl");

				set_style(div3, "top", /*$buttonCoords*/ ctx[8].top + "px");
				set_style(div3, "left", /*$buttonCoords*/ ctx[8].left + "px");
				add_location(div3, file$g, 94, 1, 2213);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div3, anchor);
				append_dev(div3, div2);
				if (if_block0) if_block0.m(div2, null);
				append_dev(div2, t0);
				if (if_block1) if_block1.m(div2, null);
				append_dev(div2, t1);
				append_dev(div2, button);
				append_dev(button, div0);
				mount_component(binicon, div0, null);
				append_dev(button, t2);
				append_dev(button, div1);
				append_dev(div1, t3);
				append_dev(div1, t4);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button, "mouseenter", /*mouseenter_handler_2*/ ctx[19], false, false, false, false),
						listen_dev(button, "mouseleave", /*mouseleave_handler_2*/ ctx[20], false, false, false, false),
						listen_dev(button, "click", prevent_default(/*deleteInitiate*/ ctx[14]), false, true, false, false),
						action_destroyer(clickOutside.call(null, div3)),
						listen_dev(div3, "clickedOutside", /*handleClickOutside*/ ctx[10], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				if (/*$selectedSection*/ ctx[9] !== "PrivateFolders") {
					if (if_block0) {
						if_block0.p(ctx, dirty);

						if (dirty & /*$selectedSection*/ 512) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_2$5(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div2, t0);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*moreOptionType*/ ctx[1] === "Folder") {
					if (if_block1) {
						if_block1.p(ctx, dirty);

						if (dirty & /*moreOptionType*/ 2) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_1$9(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(div2, t1);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				const binicon_changes = {};
				if (dirty & /*isBinHovered*/ 16) binicon_changes.color = /*isBinHovered*/ ctx[4] ? '#F2F2F0' : '#85889C';
				binicon.$set(binicon_changes);
				if ((!current || dirty & /*moreOptionType*/ 2) && t4_value !== (t4_value = (/*moreOptionType*/ ctx[1] === "Folder" ? "folder" : "") + "")) set_data_dev(t4, t4_value);

				if (!current || dirty & /*moreOptionType*/ 2 && div3_class_value !== (div3_class_value = "absolute z-50 bg-osvauld-frameblack border border-osvauld-iconblack " + (/*moreOptionType*/ ctx[1] === 'Folder'
				? 'w-[166px]'
				: 'w-[130px]') + " rounded-2xl")) {
					attr_dev(div3, "class", div3_class_value);
				}

				if (!current || dirty & /*$buttonCoords*/ 256) {
					set_style(div3, "top", /*$buttonCoords*/ ctx[8].top + "px");
				}

				if (!current || dirty & /*$buttonCoords*/ 256) {
					set_style(div3, "left", /*$buttonCoords*/ ctx[8].left + "px");
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(binicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(binicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div3);
				}

				if (if_block0) if_block0.d();
				if (if_block1) if_block1.d();
				destroy_component(binicon);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$b.name,
			type: "if",
			source: "(72:0) {#if $showMoreOptions && $buttonRef && $modalManager}",
			ctx
		});

		return block;
	}

	// (83:3) {#if $selectedSection !== "PrivateFolders"}
	function create_if_block_2$5(ctx) {
		let button1;
		let foldershare;
		let t0;
		let button0;
		let t1;
		let t2_value = (/*moreOptionType*/ ctx[1] === "Folder" ? "folder" : "") + "";
		let t2;
		let current;
		let mounted;
		let dispose;

		foldershare = new FolderShare({
				props: {
					size: 24,
					color: /*isShareHovered*/ ctx[2] ? '#F2F2F0' : '#85889C'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				button1 = element("button");
				create_component(foldershare.$$.fragment);
				t0 = space();
				button0 = element("button");
				t1 = text("Share ");
				t2 = text(t2_value);
				attr_dev(button0, "class", "font-inter text-base whitespace-nowrap");
				add_location(button0, file$g, 114, 5, 3032);
				attr_dev(button1, "class", "flex justify-start gap-2 items-center w-full p-2 text-osvauld-fieldText hover:text-osvauld-sideListTextActive hover:bg-osvauld-modalFieldActive rounded-lg cursor-pointer");
				add_location(button1, file$g, 105, 4, 2624);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button1, anchor);
				mount_component(foldershare, button1, null);
				append_dev(button1, t0);
				append_dev(button1, button0);
				append_dev(button0, t1);
				append_dev(button0, t2);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(
							button0,
							"click",
							stop_propagation(function () {
								if (is_function(/*moreOptionType*/ ctx[1] === 'Folder'
								? /*callShareFolderModal*/ ctx[11]
								: /*callShareCredentialModal*/ ctx[12])) (/*moreOptionType*/ ctx[1] === 'Folder'
								? /*callShareFolderModal*/ ctx[11]
								: /*callShareCredentialModal*/ ctx[12]).apply(this, arguments);
							}),
							false,
							false,
							true,
							false
						),
						listen_dev(button1, "mouseenter", /*mouseenter_handler*/ ctx[15], false, false, false, false),
						listen_dev(button1, "mouseleave", /*mouseleave_handler*/ ctx[16], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const foldershare_changes = {};
				if (dirty & /*isShareHovered*/ 4) foldershare_changes.color = /*isShareHovered*/ ctx[2] ? '#F2F2F0' : '#85889C';
				foldershare.$set(foldershare_changes);
				if ((!current || dirty & /*moreOptionType*/ 2) && t2_value !== (t2_value = (/*moreOptionType*/ ctx[1] === "Folder" ? "folder" : "") + "")) set_data_dev(t2, t2_value);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(foldershare.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(foldershare.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button1);
				}

				destroy_component(foldershare);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$5.name,
			type: "if",
			source: "(83:3) {#if $selectedSection !== \\\"PrivateFolders\\\"}",
			ctx
		});

		return block;
	}

	// (103:3) {#if moreOptionType === "Folder"}
	function create_if_block_1$9(ctx) {
		let button1;
		let div;
		let editicon;
		let t0;
		let button0;
		let current;
		let mounted;
		let dispose;

		editicon = new EditIcon({
				props: {
					color: /*isEditHovered*/ ctx[3] ? '#F2F2F0' : '#85889C'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				button1 = element("button");
				div = element("div");
				create_component(editicon.$$.fragment);
				t0 = space();
				button0 = element("button");
				button0.textContent = "Rename";
				attr_dev(div, "class", "w-6 h-6 flex items-center justify-center");
				add_location(div, file$g, 131, 5, 3727);
				attr_dev(button0, "class", "font-inter text-base whitespace-nowrap");
				add_location(button0, file$g, 134, 5, 3866);
				attr_dev(button1, "class", "flex justify-start gap-2 items-center w-full p-2 text-osvauld-fieldText hover:text-osvauld-sideListTextActive hover:bg-osvauld-modalFieldActive rounded-lg cursor-pointer");
				add_location(button1, file$g, 125, 4, 3364);
			},
			m: function mount(target, anchor) {
				insert_dev(target, button1, anchor);
				append_dev(button1, div);
				mount_component(editicon, div, null);
				append_dev(button1, t0);
				append_dev(button1, button0);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button1, "mouseenter", /*mouseenter_handler_1*/ ctx[17], false, false, false, false),
						listen_dev(button1, "mouseleave", /*mouseleave_handler_1*/ ctx[18], false, false, false, false),
						listen_dev(button1, "click", stop_propagation(/*callRenameFolderModal*/ ctx[13]), false, false, true, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const editicon_changes = {};
				if (dirty & /*isEditHovered*/ 8) editicon_changes.color = /*isEditHovered*/ ctx[3] ? '#F2F2F0' : '#85889C';
				editicon.$set(editicon_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(editicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(editicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button1);
				}

				destroy_component(editicon);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$9.name,
			type: "if",
			source: "(103:3) {#if moreOptionType === \\\"Folder\\\"}",
			ctx
		});

		return block;
	}

	function create_fragment$g(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*$showMoreOptions*/ ctx[5] && /*$buttonRef*/ ctx[6] && /*$modalManager*/ ctx[7] && create_if_block$b(ctx);

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error_1$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (/*$showMoreOptions*/ ctx[5] && /*$buttonRef*/ ctx[6] && /*$modalManager*/ ctx[7]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*$showMoreOptions, $buttonRef, $modalManager*/ 224) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$b(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$g.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$g($$self, $$props, $$invalidate) {
		let $showMoreOptions;
		let $buttonRef;
		let $modalManager;

		let $buttonCoords,
			$$unsubscribe_buttonCoords = noop,
			$$subscribe_buttonCoords = () => ($$unsubscribe_buttonCoords(), $$unsubscribe_buttonCoords = subscribe(buttonCoords, $$value => $$invalidate(8, $buttonCoords = $$value)), buttonCoords);

		let $selectedSection;
		validate_store(showMoreOptions, 'showMoreOptions');
		component_subscribe($$self, showMoreOptions, $$value => $$invalidate(5, $showMoreOptions = $$value));
		validate_store(buttonRef, 'buttonRef');
		component_subscribe($$self, buttonRef, $$value => $$invalidate(6, $buttonRef = $$value));
		validate_store(modalManager, 'modalManager');
		component_subscribe($$self, modalManager, $$value => $$invalidate(7, $modalManager = $$value));
		validate_store(selectedSection, 'selectedSection');
		component_subscribe($$self, selectedSection, $$value => $$invalidate(9, $selectedSection = $$value));
		$$self.$$.on_destroy.push(() => $$unsubscribe_buttonCoords());
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('MoreActions', slots, []);
		let moreOptionType;
		let isShareHovered = false;
		let isEditHovered = false;
		let isBinHovered = false;

		function closeModal() {
			modalManager.set(null);
			showMoreOptions.set(false);
		}

		const buttonCoords = derived(buttonRef, $buttonRef => {
			if ($buttonRef) {
				// @ts-ignore
				const rect = $buttonRef.getBoundingClientRect();

				const leftVal = moreOptionType === "Folder"
				? rect.left + window.scrollX
				: rect.left + window.scrollX - 2.7 * rect.width;

				return {
					top: rect.top + window.scrollY + rect.height,
					left: leftVal
				};
			}

			return { top: 0, left: 0 };
		});

		validate_store(buttonCoords, 'buttonCoords');
		$$subscribe_buttonCoords();

		const handleKeyDown = event => {
			if (event.key === "Escape") {
				closeModal();
			}
		};

		const handleClickOutside = () => {
			closeModal();
		};

		const callShareFolderModal = () => {
			closeModal();
			showFolderShareDrawer.set(true);
		};

		const callShareCredentialModal = () => {
			showMoreOptions.set(false);
			showCredentialShareDrawer.set(true);
		};

		const callRenameFolderModal = () => {
			closeModal();
			showFolderRenameDrawer.set(true);
		};

		const deleteInitiate = () => {
			showMoreOptions.set(false);
			buttonRef.set(null);
			DeleteConfirmationModal.set(true);
		};

		onMount(() => {
			window.addEventListener("keydown", handleKeyDown);

			if (modalManager && get_store_value(modalManager)) {
				// @ts-ignore
				$$invalidate(1, moreOptionType = get_store_value(modalManager).type);
			} else {
				closeModal();
				throw new Error("modal manager is not set");
			}
		});

		onDestroy(() => {
			window.removeEventListener("keydown", handleKeyDown);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MoreActions> was created with unknown prop '${key}'`);
		});

		const mouseenter_handler = () => $$invalidate(2, isShareHovered = true);
		const mouseleave_handler = () => $$invalidate(2, isShareHovered = false);
		const mouseenter_handler_1 = () => $$invalidate(3, isEditHovered = true);
		const mouseleave_handler_1 = () => $$invalidate(3, isEditHovered = false);
		const mouseenter_handler_2 = () => $$invalidate(4, isBinHovered = true);
		const mouseleave_handler_2 = () => $$invalidate(4, isBinHovered = false);

		$$self.$capture_state = () => ({
			BinIcon,
			EditIcon,
			FolderShare,
			buttonRef,
			showMoreOptions,
			DeleteConfirmationModal,
			modalManager,
			showFolderShareDrawer,
			showFolderRenameDrawer,
			showCredentialShareDrawer,
			selectedSection,
			clickOutside,
			derived,
			onMount,
			onDestroy,
			get: get_store_value,
			moreOptionType,
			isShareHovered,
			isEditHovered,
			isBinHovered,
			closeModal,
			buttonCoords,
			handleKeyDown,
			handleClickOutside,
			callShareFolderModal,
			callShareCredentialModal,
			callRenameFolderModal,
			deleteInitiate,
			$showMoreOptions,
			$buttonRef,
			$modalManager,
			$buttonCoords,
			$selectedSection
		});

		$$self.$inject_state = $$props => {
			if ('moreOptionType' in $$props) $$invalidate(1, moreOptionType = $$props.moreOptionType);
			if ('isShareHovered' in $$props) $$invalidate(2, isShareHovered = $$props.isShareHovered);
			if ('isEditHovered' in $$props) $$invalidate(3, isEditHovered = $$props.isEditHovered);
			if ('isBinHovered' in $$props) $$invalidate(4, isBinHovered = $$props.isBinHovered);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			buttonCoords,
			moreOptionType,
			isShareHovered,
			isEditHovered,
			isBinHovered,
			$showMoreOptions,
			$buttonRef,
			$modalManager,
			$buttonCoords,
			$selectedSection,
			handleClickOutside,
			callShareFolderModal,
			callShareCredentialModal,
			callRenameFolderModal,
			deleteInitiate,
			mouseenter_handler,
			mouseleave_handler,
			mouseenter_handler_1,
			mouseleave_handler_1,
			mouseenter_handler_2,
			mouseleave_handler_2
		];
	}

	class MoreActions extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$g, create_fragment$g, safe_not_equal, { buttonCoords: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "MoreActions",
				options,
				id: create_fragment$g.name
			});
		}

		get buttonCoords() {
			return this.$$.ctx[0];
		}

		set buttonCoords(value) {
			throw new Error_1$1("<MoreActions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/credentials/CredentialDeleteModal.svelte generated by Svelte v4.2.19 */
	const file$f = "src/lib/components/dashboard/credentials/CredentialDeleteModal.svelte";

	function create_fragment$f(ctx) {
		let button3;
		let div7;
		let div0;
		let span;
		let t0;
		let t1_value = /*$modalManager*/ ctx[2].name + "";
		let t1;
		let t2;
		let button0;
		let closepanel;
		let t3;
		let div1;
		let t4;
		let div4;
		let div2;
		let warning;
		let t5;
		let div3;
		let t7;
		let div5;
		let t8;
		let div6;
		let button1;
		let t9;
		let button1_class_value;
		let t10;
		let button2;
		let t11;
		let button2_class_value;
		let div7_intro;
		let current;
		let mounted;
		let dispose;
		closepanel = new ClosePanel({ $$inline: true });
		warning = new Warning({ $$inline: true });

		const block = {
			c: function create() {
				button3 = element("button");
				div7 = element("div");
				div0 = element("div");
				span = element("span");
				t0 = text("Delete ");
				t1 = text(t1_value);
				t2 = space();
				button0 = element("button");
				create_component(closepanel.$$.fragment);
				t3 = space();
				div1 = element("div");
				t4 = space();
				div4 = element("div");
				div2 = element("div");
				create_component(warning.$$.fragment);
				t5 = space();
				div3 = element("div");
				div3.textContent = "Are you sure? This action cannot be undone.";
				t7 = space();
				div5 = element("div");
				t8 = space();
				div6 = element("div");
				button1 = element("button");
				t9 = text("Cancel");
				t10 = space();
				button2 = element("button");
				t11 = text("Delete Credential");
				attr_dev(span, "class", "text-[21px] font-medium text-osvauld-quarzowhite");
				add_location(span, file$f, 41, 3, 1252);
				attr_dev(button0, "class", "cursor-pointer p-2");
				add_location(button0, file$f, 44, 3, 1362);
				attr_dev(div0, "class", "flex justify-between items-center w-full");
				add_location(div0, file$f, 40, 2, 1194);
				attr_dev(div1, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div1, file$f, 51, 2, 1511);
				attr_dev(div2, "class", "justify-center items-center flex");
				add_location(div2, file$f, 57, 3, 1737);
				attr_dev(div3, "class", "text-osvauld-textActive text-left");
				add_location(div3, file$f, 60, 3, 1813);
				attr_dev(div4, "class", "w-full font-normal text-base flex justify-start items-center bg-osvauld-fieldActive rounded-lg gap-3 p-2");
				add_location(div4, file$f, 54, 2, 1608);
				attr_dev(div5, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div5, file$f, 64, 2, 1930);

				attr_dev(button1, "class", button1_class_value = "font-medium text-base rounded-md py-[5px] px-[15px] " + (/*cancelHovered*/ ctx[0]
				? 'bg-osvauld-cancelBackground text-osvauld-quarzowhite'
				: 'text-osvauld-fadedCancel'));

				add_location(button1, file$f, 68, 3, 2087);

				attr_dev(button2, "class", button2_class_value = "border border-osvauld-dangerRed py-[5px] px-[15px] text-base font-medium text-osvauld-dangerRed rounded-md " + (/*finalActionHovered*/ ctx[1]
				? 'bg-osvauld-dangerRed text-osvauld-frameblack'
				: 'text-osvauld-dangerRed'));

				add_location(button2, file$f, 76, 3, 2459);
				attr_dev(div6, "class", "flex justify-end items-center gap-4 w-full");
				add_location(div6, file$f, 67, 2, 2027);
				attr_dev(div7, "class", "p-4 bg-osvauld-frameblack border border-osvauld-activeBorder rounded-3xl w-[32rem] h-[14rem] flex flex-col items-start justify-center gap-3");
				add_location(div7, file$f, 36, 1, 1025);
				attr_dev(button3, "class", "fixed inset-0 flex items-center justify-center z-50 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px]");
				add_location(button3, file$f, 32, 0, 832);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, button3, anchor);
				append_dev(button3, div7);
				append_dev(div7, div0);
				append_dev(div0, span);
				append_dev(span, t0);
				append_dev(span, t1);
				append_dev(div0, t2);
				append_dev(div0, button0);
				mount_component(closepanel, button0, null);
				append_dev(div7, t3);
				append_dev(div7, div1);
				append_dev(div7, t4);
				append_dev(div7, div4);
				append_dev(div4, div2);
				mount_component(warning, div2, null);
				append_dev(div4, t5);
				append_dev(div4, div3);
				append_dev(div7, t7);
				append_dev(div7, div5);
				append_dev(div7, t8);
				append_dev(div7, div6);
				append_dev(div6, button1);
				append_dev(button1, t9);
				append_dev(div6, t10);
				append_dev(div6, button2);
				append_dev(button2, t11);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", prevent_default(/*withdrawCredentialDeleteModal*/ ctx[3]), false, true, false, false),
						listen_dev(button1, "click", prevent_default(/*withdrawCredentialDeleteModal*/ ctx[3]), false, true, false, false),
						listen_dev(button1, "mouseenter", /*mouseenter_handler*/ ctx[5], false, false, false, false),
						listen_dev(button1, "mouseleave", /*mouseleave_handler*/ ctx[6], false, false, false, false),
						listen_dev(button2, "click", prevent_default(/*DeleteConfirmation*/ ctx[4]), false, true, false, false),
						listen_dev(button2, "mouseenter", /*mouseenter_handler_1*/ ctx[7], false, false, false, false),
						listen_dev(button2, "mouseleave", /*mouseleave_handler_1*/ ctx[8], false, false, false, false),
						listen_dev(button3, "click", prevent_default(/*withdrawCredentialDeleteModal*/ ctx[3]), false, true, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if ((!current || dirty & /*$modalManager*/ 4) && t1_value !== (t1_value = /*$modalManager*/ ctx[2].name + "")) set_data_dev(t1, t1_value);

				if (!current || dirty & /*cancelHovered*/ 1 && button1_class_value !== (button1_class_value = "font-medium text-base rounded-md py-[5px] px-[15px] " + (/*cancelHovered*/ ctx[0]
				? 'bg-osvauld-cancelBackground text-osvauld-quarzowhite'
				: 'text-osvauld-fadedCancel'))) {
					attr_dev(button1, "class", button1_class_value);
				}

				if (!current || dirty & /*finalActionHovered*/ 2 && button2_class_value !== (button2_class_value = "border border-osvauld-dangerRed py-[5px] px-[15px] text-base font-medium text-osvauld-dangerRed rounded-md " + (/*finalActionHovered*/ ctx[1]
				? 'bg-osvauld-dangerRed text-osvauld-frameblack'
				: 'text-osvauld-dangerRed'))) {
					attr_dev(button2, "class", button2_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closepanel.$$.fragment, local);
				transition_in(warning.$$.fragment, local);

				if (local) {
					if (!div7_intro) {
						add_render_callback(() => {
							div7_intro = create_in_transition(div7, fly, {});
							div7_intro.start();
						});
					}
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(closepanel.$$.fragment, local);
				transition_out(warning.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button3);
				}

				destroy_component(closepanel);
				destroy_component(warning);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$f.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$f($$self, $$props, $$invalidate) {
		let $modalManager;
		validate_store(modalManager, 'modalManager');
		component_subscribe($$self, modalManager, $$value => $$invalidate(2, $modalManager = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('CredentialDeleteModal', slots, []);
		let cancelHovered = false;
		let finalActionHovered = false;

		function withdrawCredentialDeleteModal() {
			modalManager.set(null);
			showMoreOptions.set(false);
			DeleteConfirmationModal.set(false);
		}

		const removeCredentialHandler = async credentialId => {
			await removeCredential(credentialId);
			await setCredentialStore();
		};

		async function DeleteConfirmation() {
			await removeCredentialHandler($modalManager.id);
			withdrawCredentialDeleteModal();
		}

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CredentialDeleteModal> was created with unknown prop '${key}'`);
		});

		const mouseenter_handler = () => $$invalidate(0, cancelHovered = true);
		const mouseleave_handler = () => $$invalidate(0, cancelHovered = false);
		const mouseenter_handler_1 = () => $$invalidate(1, finalActionHovered = true);
		const mouseleave_handler_1 = () => $$invalidate(1, finalActionHovered = false);

		$$self.$capture_state = () => ({
			ClosePanel,
			modalManager,
			DeleteConfirmationModal,
			showMoreOptions,
			fly,
			Warning,
			removeCredential,
			setCredentialStore,
			cancelHovered,
			finalActionHovered,
			withdrawCredentialDeleteModal,
			removeCredentialHandler,
			DeleteConfirmation,
			$modalManager
		});

		$$self.$inject_state = $$props => {
			if ('cancelHovered' in $$props) $$invalidate(0, cancelHovered = $$props.cancelHovered);
			if ('finalActionHovered' in $$props) $$invalidate(1, finalActionHovered = $$props.finalActionHovered);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			cancelHovered,
			finalActionHovered,
			$modalManager,
			withdrawCredentialDeleteModal,
			DeleteConfirmation,
			mouseenter_handler,
			mouseleave_handler,
			mouseenter_handler_1,
			mouseleave_handler_1
		];
	}

	class CredentialDeleteModal extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "CredentialDeleteModal",
				options,
				id: create_fragment$f.name
			});
		}
	}

	/* src/lib/components/dashboard/folders/FolderDeleteModal.svelte generated by Svelte v4.2.19 */
	const file$e = "src/lib/components/dashboard/folders/FolderDeleteModal.svelte";

	function create_fragment$e(ctx) {
		let button3;
		let div7;
		let div0;
		let span0;
		let t0;
		let t1_value = /*$modalManager*/ ctx[2].name + "";
		let t1;
		let t2;
		let t3;
		let button0;
		let closepanel;
		let t4;
		let div1;
		let t5;
		let div4;
		let div2;
		let warning;
		let t6;
		let div3;
		let t7;
		let br;
		let t8;
		let span1;
		let t10;
		let t11;
		let div5;
		let t12;
		let div6;
		let button1;
		let t13;
		let button1_class_value;
		let t14;
		let button2;
		let t15;
		let button2_class_value;
		let div7_intro;
		let current;
		let mounted;
		let dispose;
		closepanel = new ClosePanel({ $$inline: true });
		warning = new Warning({ $$inline: true });

		const block = {
			c: function create() {
				button3 = element("button");
				div7 = element("div");
				div0 = element("div");
				span0 = element("span");
				t0 = text("Delete ");
				t1 = text(t1_value);
				t2 = text(" folder");
				t3 = space();
				button0 = element("button");
				create_component(closepanel.$$.fragment);
				t4 = space();
				div1 = element("div");
				t5 = space();
				div4 = element("div");
				div2 = element("div");
				create_component(warning.$$.fragment);
				t6 = space();
				div3 = element("div");
				t7 = text("Are you sure? ");
				br = element("br");
				t8 = text(" All\n\t\t\t\t");
				span1 = element("span");
				span1.textContent = "credentials";
				t10 = text(" within\n\t\t\t\tthis folder will be permanently deleted. Users and groups with access to\n\t\t\t\tthis folder will no longer be able to view or manage the credentials");
				t11 = space();
				div5 = element("div");
				t12 = space();
				div6 = element("div");
				button1 = element("button");
				t13 = text("Cancel");
				t14 = space();
				button2 = element("button");
				t15 = text("Delete Folder");
				attr_dev(span0, "class", "text-[21px] font-medium text-osvauld-quarzowhite");
				add_location(span0, file$e, 51, 3, 1470);
				attr_dev(button0, "class", "cursor-pointer p-2");
				add_location(button0, file$e, 54, 3, 1587);
				attr_dev(div0, "class", "flex justify-between items-center w-full");
				add_location(div0, file$e, 50, 2, 1412);
				attr_dev(div1, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div1, file$e, 61, 2, 1732);
				attr_dev(div2, "class", "w-16 h-9 justify-center items-center flex");
				add_location(div2, file$e, 67, 3, 1968);
				add_location(br, file$e, 71, 18, 2119);
				attr_dev(span1, "class", "font-semibold text-osvauld-quarzowhite");
				add_location(span1, file$e, 72, 4, 2134);
				attr_dev(div3, "class", "text-osvauld-textActive text-left");
				add_location(div3, file$e, 70, 3, 2053);
				attr_dev(div4, "class", "h-[140px] w-full font-normal text-base flex justify-center items-start bg-osvauld-fieldActive rounded-lg gap-3 p-2");
				add_location(div4, file$e, 64, 2, 1829);
				attr_dev(div5, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div5, file$e, 77, 2, 2384);

				attr_dev(button1, "class", button1_class_value = "font-medium text-base rounded-md py-[5px] px-[15px] " + (/*cancelHovered*/ ctx[0]
				? 'bg-osvauld-cancelBackground text-osvauld-quarzowhite'
				: 'text-osvauld-fadedCancel'));

				add_location(button1, file$e, 81, 3, 2541);

				attr_dev(button2, "class", button2_class_value = "border border-osvauld-dangerRed py-[5px] px-[15px] text-base font-medium text-osvauld-dangerRed rounded-md " + (/*finalActionHovered*/ ctx[1]
				? 'bg-osvauld-dangerRed text-osvauld-frameblack'
				: 'text-osvauld-dangerRed'));

				add_location(button2, file$e, 89, 3, 2909);
				attr_dev(div6, "class", "flex justify-end items-center gap-4 w-full");
				add_location(div6, file$e, 80, 2, 2481);
				attr_dev(div7, "class", "p-4 bg-osvauld-frameblack border border-osvauld-activeBorder rounded-3xl w-[32rem] h-[17.6rem] flex flex-col items-start justify-center gap-3");
				add_location(div7, file$e, 46, 1, 1241);
				attr_dev(button3, "class", "fixed inset-0 flex items-center justify-center z-50 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px]");
				add_location(button3, file$e, 42, 0, 1052);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, button3, anchor);
				append_dev(button3, div7);
				append_dev(div7, div0);
				append_dev(div0, span0);
				append_dev(span0, t0);
				append_dev(span0, t1);
				append_dev(span0, t2);
				append_dev(div0, t3);
				append_dev(div0, button0);
				mount_component(closepanel, button0, null);
				append_dev(div7, t4);
				append_dev(div7, div1);
				append_dev(div7, t5);
				append_dev(div7, div4);
				append_dev(div4, div2);
				mount_component(warning, div2, null);
				append_dev(div4, t6);
				append_dev(div4, div3);
				append_dev(div3, t7);
				append_dev(div3, br);
				append_dev(div3, t8);
				append_dev(div3, span1);
				append_dev(div3, t10);
				append_dev(div7, t11);
				append_dev(div7, div5);
				append_dev(div7, t12);
				append_dev(div7, div6);
				append_dev(div6, button1);
				append_dev(button1, t13);
				append_dev(div6, t14);
				append_dev(div6, button2);
				append_dev(button2, t15);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", prevent_default(/*withdrawFolderDeleteModal*/ ctx[3]), false, true, false, false),
						listen_dev(button1, "click", prevent_default(/*withdrawFolderDeleteModal*/ ctx[3]), false, true, false, false),
						listen_dev(button1, "mouseenter", /*mouseenter_handler*/ ctx[5], false, false, false, false),
						listen_dev(button1, "mouseleave", /*mouseleave_handler*/ ctx[6], false, false, false, false),
						listen_dev(button2, "click", prevent_default(/*DeleteConfirmation*/ ctx[4]), false, true, false, false),
						listen_dev(button2, "mouseenter", /*mouseenter_handler_1*/ ctx[7], false, false, false, false),
						listen_dev(button2, "mouseleave", /*mouseleave_handler_1*/ ctx[8], false, false, false, false),
						listen_dev(button3, "click", prevent_default(/*withdrawFolderDeleteModal*/ ctx[3]), false, true, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if ((!current || dirty & /*$modalManager*/ 4) && t1_value !== (t1_value = /*$modalManager*/ ctx[2].name + "")) set_data_dev(t1, t1_value);

				if (!current || dirty & /*cancelHovered*/ 1 && button1_class_value !== (button1_class_value = "font-medium text-base rounded-md py-[5px] px-[15px] " + (/*cancelHovered*/ ctx[0]
				? 'bg-osvauld-cancelBackground text-osvauld-quarzowhite'
				: 'text-osvauld-fadedCancel'))) {
					attr_dev(button1, "class", button1_class_value);
				}

				if (!current || dirty & /*finalActionHovered*/ 2 && button2_class_value !== (button2_class_value = "border border-osvauld-dangerRed py-[5px] px-[15px] text-base font-medium text-osvauld-dangerRed rounded-md " + (/*finalActionHovered*/ ctx[1]
				? 'bg-osvauld-dangerRed text-osvauld-frameblack'
				: 'text-osvauld-dangerRed'))) {
					attr_dev(button2, "class", button2_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closepanel.$$.fragment, local);
				transition_in(warning.$$.fragment, local);

				if (local) {
					if (!div7_intro) {
						add_render_callback(() => {
							div7_intro = create_in_transition(div7, fly, {});
							div7_intro.start();
						});
					}
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(closepanel.$$.fragment, local);
				transition_out(warning.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button3);
				}

				destroy_component(closepanel);
				destroy_component(warning);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$e.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$e($$self, $$props, $$invalidate) {
		let $modalManager;
		let $selectedFolder;
		validate_store(modalManager, 'modalManager');
		component_subscribe($$self, modalManager, $$value => $$invalidate(2, $modalManager = $$value));
		validate_store(selectedFolder, 'selectedFolder');
		component_subscribe($$self, selectedFolder, $$value => $$invalidate(9, $selectedFolder = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('FolderDeleteModal', slots, []);
		let cancelHovered = false;
		let finalActionHovered = false;

		function withdrawFolderDeleteModal() {
			showMoreOptions.set(false);
			DeleteConfirmationModal.set(false);
			modalManager.set(null);
		}

		async function DeleteConfirmation() {
			if ($selectedFolder && $selectedFolder.id === $modalManager.id) {
				selectedFolder.set(null);
				credentialStore.set([]);
			}

			let removalResponse = await removeFolder($modalManager.id);

			if (removalResponse.success) {
				toastStore.set({
					type: removalResponse.success,
					message: removalResponse.message,
					show: true
				});
			}

			withdrawFolderDeleteModal();
			await setFolderStore();
		}

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FolderDeleteModal> was created with unknown prop '${key}'`);
		});

		const mouseenter_handler = () => $$invalidate(0, cancelHovered = true);
		const mouseleave_handler = () => $$invalidate(0, cancelHovered = false);
		const mouseenter_handler_1 = () => $$invalidate(1, finalActionHovered = true);
		const mouseleave_handler_1 = () => $$invalidate(1, finalActionHovered = false);

		$$self.$capture_state = () => ({
			ClosePanel,
			modalManager,
			DeleteConfirmationModal,
			showMoreOptions,
			selectedFolder,
			credentialStore,
			toastStore,
			fly,
			Warning,
			removeFolder,
			setFolderStore,
			cancelHovered,
			finalActionHovered,
			withdrawFolderDeleteModal,
			DeleteConfirmation,
			$modalManager,
			$selectedFolder
		});

		$$self.$inject_state = $$props => {
			if ('cancelHovered' in $$props) $$invalidate(0, cancelHovered = $$props.cancelHovered);
			if ('finalActionHovered' in $$props) $$invalidate(1, finalActionHovered = $$props.finalActionHovered);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			cancelHovered,
			finalActionHovered,
			$modalManager,
			withdrawFolderDeleteModal,
			DeleteConfirmation,
			mouseenter_handler,
			mouseleave_handler,
			mouseenter_handler_1,
			mouseleave_handler_1
		];
	}

	class FolderDeleteModal extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "FolderDeleteModal",
				options,
				id: create_fragment$e.name
			});
		}
	}

	/* src/lib/components/popup/Welcome.svelte generated by Svelte v4.2.19 */
	const file$d = "src/lib/components/popup/Welcome.svelte";

	// (68:4) {:else}
	function create_else_block_1$4(ctx) {
		let eye;
		let current;
		eye = new Eye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(eye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(eye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(eye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(eye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(eye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_1$4.name,
			type: "else",
			source: "(68:4) {:else}",
			ctx
		});

		return block;
	}

	// (66:4) {#if showPassword}
	function create_if_block_1$8(ctx) {
		let closedeye;
		let current;
		closedeye = new ClosedEye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(closedeye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(closedeye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closedeye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(closedeye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(closedeye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$8.name,
			type: "if",
			source: "(66:4) {#if showPassword}",
			ctx
		});

		return block;
	}

	// (84:3) {:else}
	function create_else_block$7(ctx) {
		let span;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = "Submit";
				add_location(span, file$d, 87, 4, 2740);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$7.name,
			type: "else",
			source: "(84:3) {:else}",
			ctx
		});

		return block;
	}

	// (82:3) {#if isLoaderActive}
	function create_if_block$a(ctx) {
		let loader;
		let current;

		loader = new Loader({
				props: { size: 24, color: "#1F242A", duration: 1 },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(loader.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(loader, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(loader.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(loader.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(loader, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$a.name,
			type: "if",
			source: "(82:3) {#if isLoaderActive}",
			ctx
		});

		return block;
	}

	function create_fragment$d(ctx) {
		let div1;
		let form;
		let label;
		let t1;
		let div0;
		let input;
		let t2;
		let button0;
		let current_block_type_index;
		let if_block0;
		let t3;
		let span;
		let t4;
		let span_class_value;
		let t5;
		let button1;
		let current_block_type_index_1;
		let if_block1;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block_1$8, create_else_block_1$4];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*showPassword*/ ctx[0]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		const if_block_creators_1 = [create_if_block$a, create_else_block$7];
		const if_blocks_1 = [];

		function select_block_type_1(ctx, dirty) {
			if (/*isLoaderActive*/ ctx[2]) return 0;
			return 1;
		}

		current_block_type_index_1 = select_block_type_1(ctx);
		if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

		const block = {
			c: function create() {
				div1 = element("div");
				form = element("form");
				label = element("label");
				label.textContent = "Enter Passphrase";
				t1 = space();
				div0 = element("div");
				input = element("input");
				t2 = space();
				button0 = element("button");
				if_block0.c();
				t3 = space();
				span = element("span");
				t4 = text("Passphrase doesn't match");
				t5 = space();
				button1 = element("button");
				if_block1.c();
				attr_dev(label, "for", "passphrase");
				add_location(label, file$d, 50, 2, 1626);
				attr_dev(input, "class", "text-white bg-osvauld-frameblack border-0 tracking-wider font-normal border-transparent focus:border-transparent focus:ring-0 focus:border-osvauld-activeBorder");
				attr_dev(input, "type", /*type*/ ctx[3]);
				attr_dev(input, "id", "passphrase");
				input.autofocus = true;
				attr_dev(input, "autocomplete", "off");
				add_location(input, file$d, 55, 3, 1822);
				attr_dev(button0, "type", "button");
				attr_dev(button0, "class", "flex justify-center items-center");
				add_location(button0, file$d, 63, 3, 2103);
				attr_dev(div0, "class", "flex bg-osvauld-frameblack px-3 mt-4 border rounded-lg border-osvauld-iconblack focus-within:border-osvauld-activeBorder");
				add_location(div0, file$d, 52, 2, 1678);
				attr_dev(span, "class", span_class_value = "text-xs text-red-500 font-thin mt-2 " + (/*errorMessage*/ ctx[1] ? 'visible' : 'invisible'));
				add_location(span, file$d, 75, 2, 2316);
				attr_dev(button1, "class", "bg-osvauld-carolinablue py-2 px-10 mt-8 rounded-lg text-osvauld-ninjablack font-medium w-[150px] flex justify-center items-center whitespace-nowrap");
				attr_dev(button1, "type", "submit");
				add_location(button1, file$d, 80, 2, 2455);
				attr_dev(form, "class", "flex flex-col justify-center items-center");
				add_location(form, file$d, 46, 1, 1519);
				attr_dev(div1, "class", "h-auto mt-10 flex justify-center items-center text-base font-normal text-osvauld-sheffieldgrey");
				add_location(div1, file$d, 43, 0, 1407);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, form);
				append_dev(form, label);
				append_dev(form, t1);
				append_dev(form, div0);
				append_dev(div0, input);
				append_dev(div0, t2);
				append_dev(div0, button0);
				if_blocks[current_block_type_index].m(button0, null);
				append_dev(form, t3);
				append_dev(form, span);
				append_dev(span, t4);
				append_dev(form, t5);
				append_dev(form, button1);
				if_blocks_1[current_block_type_index_1].m(button1, null);
				current = true;
				input.focus();

				if (!mounted) {
					dispose = [
						listen_dev(input, "input", /*onInput*/ ctx[6], false, false, false, false),
						listen_dev(button0, "click", /*toggleShowPassword*/ ctx[4], false, false, false, false),
						listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[5]), false, true, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (!current || dirty & /*type*/ 8) {
					attr_dev(input, "type", /*type*/ ctx[3]);
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index !== previous_block_index) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					}

					transition_in(if_block0, 1);
					if_block0.m(button0, null);
				}

				if (!current || dirty & /*errorMessage*/ 2 && span_class_value !== (span_class_value = "text-xs text-red-500 font-thin mt-2 " + (/*errorMessage*/ ctx[1] ? 'visible' : 'invisible'))) {
					attr_dev(span, "class", span_class_value);
				}

				let previous_block_index_1 = current_block_type_index_1;
				current_block_type_index_1 = select_block_type_1(ctx);

				if (current_block_type_index_1 !== previous_block_index_1) {
					group_outros();

					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
						if_blocks_1[previous_block_index_1] = null;
					});

					check_outros();
					if_block1 = if_blocks_1[current_block_type_index_1];

					if (!if_block1) {
						if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
						if_block1.c();
					}

					transition_in(if_block1, 1);
					if_block1.m(button1, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}

				if_blocks[current_block_type_index].d();
				if_blocks_1[current_block_type_index_1].d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$d.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$d($$self, $$props, $$invalidate) {
		let type;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Welcome', slots, []);
		const dispatch = createEventDispatcher();
		let passphrase = "";
		let showPassword = false;
		let errorMessage = false;
		let isLoaderActive = false;

		function toggleShowPassword() {
			$$invalidate(0, showPassword = !showPassword);
		}

		async function handleSubmit() {
			$$invalidate(2, isLoaderActive = true);
			const pubkey = await sendMessage("getPubKey", { passphrase });
			const challengeResponse = await createChallenge(pubkey);

			const signature = await sendMessage("signChallenge", {
				challenge: challengeResponse.data.challenge
			});

			const verificationResponse = await initiateAuth(signature, pubkey);
			const token = verificationResponse.data.token;

			if (token) {
				await StorageService.setToken(token);
				await StorageService.setIsLoggedIn("true");
				dispatch("authenticated", true);
			} else {
				$$invalidate(1, errorMessage = true);
			}

			$$invalidate(2, isLoaderActive = false);
		}

		const onInput = event => {
			passphrase = event.target.value;
		};

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Welcome> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({
			Eye,
			Loader,
			createEventDispatcher,
			ClosedEye,
			sendMessage,
			createChallenge,
			initiateAuth,
			StorageService,
			dispatch,
			passphrase,
			showPassword,
			errorMessage,
			isLoaderActive,
			toggleShowPassword,
			handleSubmit,
			onInput,
			type
		});

		$$self.$inject_state = $$props => {
			if ('passphrase' in $$props) passphrase = $$props.passphrase;
			if ('showPassword' in $$props) $$invalidate(0, showPassword = $$props.showPassword);
			if ('errorMessage' in $$props) $$invalidate(1, errorMessage = $$props.errorMessage);
			if ('isLoaderActive' in $$props) $$invalidate(2, isLoaderActive = $$props.isLoaderActive);
			if ('type' in $$props) $$invalidate(3, type = $$props.type);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*showPassword*/ 1) {
				$$invalidate(3, type = showPassword ? "text" : "password");
			}
		};

		return [
			showPassword,
			errorMessage,
			isLoaderActive,
			type,
			toggleShowPassword,
			handleSubmit,
			onInput
		];
	}

	class Welcome extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Welcome",
				options,
				id: create_fragment$d.name
			});
		}
	}

	/* src/lib/components/popup/TempLogin.svelte generated by Svelte v4.2.19 */

	const file$c = "src/lib/components/popup/TempLogin.svelte";

	// (91:3) {:else}
	function create_else_block_1$3(ctx) {
		let eye;
		let current;
		eye = new Eye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(eye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(eye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(eye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(eye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(eye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_1$3.name,
			type: "else",
			source: "(91:3) {:else}",
			ctx
		});

		return block;
	}

	// (89:3) {#if showPassword}
	function create_if_block_2$4(ctx) {
		let closedeye;
		let current;
		closedeye = new ClosedEye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(closedeye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(closedeye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closedeye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(closedeye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(closedeye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$4.name,
			type: "if",
			source: "(89:3) {#if showPassword}",
			ctx
		});

		return block;
	}

	// (96:1) {#if showVerificationError}
	function create_if_block_1$7(ctx) {
		let span;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = "Wrong username or password";
				attr_dev(span, "class", "text-xs text-red-500 font-thin");
				add_location(span, file$c, 104, 2, 3310);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$7.name,
			type: "if",
			source: "(96:1) {#if showVerificationError}",
			ctx
		});

		return block;
	}

	// (105:2) {:else}
	function create_else_block$6(ctx) {
		let span;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = "Submit";
				add_location(span, file$c, 113, 3, 3677);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$6.name,
			type: "else",
			source: "(105:2) {:else}",
			ctx
		});

		return block;
	}

	// (103:2) {#if isLoaderActive}
	function create_if_block$9(ctx) {
		let loader;
		let current;

		loader = new Loader({
				props: { size: 24, color: "#1F242A", duration: 1 },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(loader.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(loader, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(loader.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(loader.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(loader, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$9.name,
			type: "if",
			source: "(103:2) {#if isLoaderActive}",
			ctx
		});

		return block;
	}

	function create_fragment$c(ctx) {
		let form;
		let label0;
		let t1;
		let div0;
		let input0;
		let t2;
		let label1;
		let t4;
		let div1;
		let input1;
		let t5;
		let label2;
		let t7;
		let div2;
		let input2;
		let t8;
		let button0;
		let current_block_type_index;
		let if_block0;
		let t9;
		let t10;
		let button1;
		let current_block_type_index_1;
		let if_block2;
		let t11;
		let button2;
		let span;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block_2$4, create_else_block_1$3];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*showPassword*/ ctx[2]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		let if_block1 = /*showVerificationError*/ ctx[3] && create_if_block_1$7(ctx);
		const if_block_creators_1 = [create_if_block$9, create_else_block$6];
		const if_blocks_1 = [];

		function select_block_type_1(ctx, dirty) {
			if (/*isLoaderActive*/ ctx[4]) return 0;
			return 1;
		}

		current_block_type_index_1 = select_block_type_1(ctx);
		if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

		const block = {
			c: function create() {
				form = element("form");
				label0 = element("label");
				label0.textContent = "Enter Base URL";
				t1 = space();
				div0 = element("div");
				input0 = element("input");
				t2 = space();
				label1 = element("label");
				label1.textContent = "Enter Username";
				t4 = space();
				div1 = element("div");
				input1 = element("input");
				t5 = space();
				label2 = element("label");
				label2.textContent = "Enter Password";
				t7 = space();
				div2 = element("div");
				input2 = element("input");
				t8 = space();
				button0 = element("button");
				if_block0.c();
				t9 = space();
				if (if_block1) if_block1.c();
				t10 = space();
				button1 = element("button");
				if_block2.c();
				t11 = space();
				button2 = element("button");
				span = element("span");
				span.textContent = "Account Recovery";
				attr_dev(label0, "for", "baseurl");
				attr_dev(label0, "class", "font-normal mt-6");
				add_location(label0, file$c, 60, 1, 1832);
				attr_dev(input0, "class", "text-white bg-osvauld-frameblack border-0 tracking-wider font-normal border-transparent focus:border-transparent focus:ring-0 w-full");
				attr_dev(input0, "type", "text");
				attr_dev(input0, "autocomplete", "off");
				attr_dev(input0, "id", "baseurl");
				add_location(input0, file$c, 63, 2, 2010);
				attr_dev(div0, "class", "flex bg-osvauld-frameblack px-3 mt-4 border rounded-lg border-osvauld-iconblack w-[260px]");
				add_location(div0, file$c, 61, 1, 1902);
				attr_dev(label1, "for", "username");
				attr_dev(label1, "class", "font-normal mt-6");
				add_location(label1, file$c, 71, 1, 2253);
				attr_dev(input1, "class", "text-white bg-osvauld-frameblack border-0 tracking-wider font-normal border-transparent focus:border-transparent focus:ring-0 w-full");
				attr_dev(input1, "type", "text");
				attr_dev(input1, "autocomplete", "off");
				attr_dev(input1, "id", "username");
				add_location(input1, file$c, 74, 2, 2432);
				attr_dev(div1, "class", "flex bg-osvauld-frameblack px-3 mt-4 border rounded-lg border-osvauld-iconblack w-[260px]");
				add_location(div1, file$c, 72, 1, 2324);
				attr_dev(label2, "for", "password");
				attr_dev(label2, "class", "font-normal mt-6");
				add_location(label2, file$c, 82, 1, 2677);
				attr_dev(input2, "class", "text-white bg-osvauld-frameblack border-0 tracking-wider font-normal border-transparent focus:border-transparent focus:ring-0 w-full");
				attr_dev(input2, "type", /*type*/ ctx[5]);
				attr_dev(input2, "autocomplete", "off");
				attr_dev(input2, "id", "password");
				add_location(input2, file$c, 86, 2, 2857);
				attr_dev(button0, "type", "button");
				attr_dev(button0, "class", "flex justify-center items-center");
				add_location(button0, file$c, 92, 2, 3086);
				attr_dev(div2, "class", "flex bg-osvauld-frameblack px-3 mt-4 border rounded-lg border-osvauld-iconblack w-[260px]");
				add_location(div2, file$c, 84, 1, 2749);
				attr_dev(button1, "class", "bg-osvauld-carolinablue py-2 px-10 mt-8 rounded-lg text-osvauld-ninjablack font-medium w-[150px] flex justify-center items-center whitespace-nowrap");
				attr_dev(button1, "type", "submit");
				add_location(button1, file$c, 107, 1, 3401);
				add_location(span, file$c, 119, 2, 3935);
				attr_dev(button2, "class", "bg-osvauld-ownerGreen py-2 px-10 mt-8 rounded-lg text-osvauld-ownerText font-medium w-[150px] flex justify-center items-center whitespace-nowrap");
				attr_dev(button2, "type", "button");
				add_location(button2, file$c, 115, 1, 3715);
				attr_dev(form, "class", "flex flex-col justify-center items-center box-border w-[90%]");
				add_location(form, file$c, 57, 0, 1711);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, form, anchor);
				append_dev(form, label0);
				append_dev(form, t1);
				append_dev(form, div0);
				append_dev(div0, input0);
				set_input_value(input0, /*baseurl*/ ctx[1]);
				append_dev(form, t2);
				append_dev(form, label1);
				append_dev(form, t4);
				append_dev(form, div1);
				append_dev(div1, input1);
				set_input_value(input1, /*username*/ ctx[0]);
				append_dev(form, t5);
				append_dev(form, label2);
				append_dev(form, t7);
				append_dev(form, div2);
				append_dev(div2, input2);
				append_dev(div2, t8);
				append_dev(div2, button0);
				if_blocks[current_block_type_index].m(button0, null);
				append_dev(form, t9);
				if (if_block1) if_block1.m(form, null);
				append_dev(form, t10);
				append_dev(form, button1);
				if_blocks_1[current_block_type_index_1].m(button1, null);
				append_dev(form, t11);
				append_dev(form, button2);
				append_dev(button2, span);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(input0, "input", /*input0_input_handler*/ ctx[10]),
						listen_dev(input1, "input", /*input1_input_handler*/ ctx[11]),
						listen_dev(input2, "input", /*onInput*/ ctx[7], false, false, false, false),
						listen_dev(button0, "click", /*togglePassword*/ ctx[8], false, false, false, false),
						listen_dev(button2, "click", /*triggerAccountRecovery*/ ctx[9], false, false, false, false),
						listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[6]), false, true, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*baseurl*/ 2 && input0.value !== /*baseurl*/ ctx[1]) {
					set_input_value(input0, /*baseurl*/ ctx[1]);
				}

				if (dirty & /*username*/ 1 && input1.value !== /*username*/ ctx[0]) {
					set_input_value(input1, /*username*/ ctx[0]);
				}

				if (!current || dirty & /*type*/ 32) {
					attr_dev(input2, "type", /*type*/ ctx[5]);
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index !== previous_block_index) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					}

					transition_in(if_block0, 1);
					if_block0.m(button0, null);
				}

				if (/*showVerificationError*/ ctx[3]) {
					if (if_block1) ; else {
						if_block1 = create_if_block_1$7(ctx);
						if_block1.c();
						if_block1.m(form, t10);
					}
				} else if (if_block1) {
					if_block1.d(1);
					if_block1 = null;
				}

				let previous_block_index_1 = current_block_type_index_1;
				current_block_type_index_1 = select_block_type_1(ctx);

				if (current_block_type_index_1 !== previous_block_index_1) {
					group_outros();

					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
						if_blocks_1[previous_block_index_1] = null;
					});

					check_outros();
					if_block2 = if_blocks_1[current_block_type_index_1];

					if (!if_block2) {
						if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
						if_block2.c();
					}

					transition_in(if_block2, 1);
					if_block2.m(button1, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block2);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block2);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(form);
				}

				if_blocks[current_block_type_index].d();
				if (if_block1) if_block1.d();
				if_blocks_1[current_block_type_index_1].d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$c.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$c($$self, $$props, $$invalidate) {
		let type;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('TempLogin', slots, []);
		const dispatch = createEventDispatcher();
		let username = LocalStorageService.get("username") || "";
		let password = "";
		let baseurl = LocalStorageService.get("baseUrl") || "";
		let showPassword = false;
		let showVerificationError = false;
		let isLoaderActive = false;

		async function handleSubmit() {
			$$invalidate(4, isLoaderActive = true);
			if (baseurl.length === 0) return;
			await StorageService.setBaseUrl(baseurl);

			if (username && password) {
				const challengeResponse = await getRegsitrationChallenge(username, password);

				if (challengeResponse.success === false) {
					$$invalidate(4, isLoaderActive = false);
					$$invalidate(3, showVerificationError = true);
				}

				if (challengeResponse.data.challenge) {
					dispatch("setPassPhrase", {
						challenge: challengeResponse.data.challenge,
						username
					});

					$$invalidate(4, isLoaderActive = false);
				} else $$invalidate(3, showVerificationError = true);
			}
		}

		function onInput(event) {
			password = event.target.value;
		}

		const togglePassword = () => {
			$$invalidate(2, showPassword = !showPassword);
		};

		const triggerAccountRecovery = () => {
			dispatch("recovery", true);
		};

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TempLogin> was created with unknown prop '${key}'`);
		});

		function input0_input_handler() {
			baseurl = this.value;
			$$invalidate(1, baseurl);
		}

		function input1_input_handler() {
			username = this.value;
			$$invalidate(0, username);
		}

		$$self.$capture_state = () => ({
			getRegsitrationChallenge,
			Eye,
			createEventDispatcher,
			Loader,
			ClosedEye,
			LocalStorageService,
			StorageService,
			dispatch,
			username,
			password,
			baseurl,
			showPassword,
			showVerificationError,
			isLoaderActive,
			handleSubmit,
			onInput,
			togglePassword,
			triggerAccountRecovery,
			type
		});

		$$self.$inject_state = $$props => {
			if ('username' in $$props) $$invalidate(0, username = $$props.username);
			if ('password' in $$props) password = $$props.password;
			if ('baseurl' in $$props) $$invalidate(1, baseurl = $$props.baseurl);
			if ('showPassword' in $$props) $$invalidate(2, showPassword = $$props.showPassword);
			if ('showVerificationError' in $$props) $$invalidate(3, showVerificationError = $$props.showVerificationError);
			if ('isLoaderActive' in $$props) $$invalidate(4, isLoaderActive = $$props.isLoaderActive);
			if ('type' in $$props) $$invalidate(5, type = $$props.type);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*showPassword*/ 4) {
				$$invalidate(5, type = showPassword ? "text" : "password");
			}

			if ($$self.$$.dirty & /*username*/ 1) {
				LocalStorageService.set("username", username);
			}

			if ($$self.$$.dirty & /*baseurl*/ 2) {
				LocalStorageService.set("baseUrl", baseurl);
			}
		};

		return [
			username,
			baseurl,
			showPassword,
			showVerificationError,
			isLoaderActive,
			type,
			handleSubmit,
			onInput,
			togglePassword,
			triggerAccountRecovery,
			input0_input_handler,
			input1_input_handler
		];
	}

	class TempLogin extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "TempLogin",
				options,
				id: create_fragment$c.name
			});
		}
	}

	/* src/lib/components/basic/PasswordStrengthValidator.svelte generated by Svelte v4.2.19 */
	const file$b = "src/lib/components/basic/PasswordStrengthValidator.svelte";

	function get_each_context$1(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[9] = list[i];
		child_ctx[11] = i;
		return child_ctx;
	}

	// (40:3) {#if $strengthScore > 0}
	function create_if_block_1$6(ctx) {
		let div;
		let div_class_value;

		const block = {
			c: function create() {
				div = element("div");
				attr_dev(div, "class", div_class_value = "h-full rounded-full transition-all duration-300 ease-out " + getStrengthColor(/*$strengthScore*/ ctx[0]));
				set_style(div, "width", /*getStrengthWidth*/ ctx[4](/*$strengthScore*/ ctx[0]));
				add_location(div, file$b, 53, 4, 1464);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*$strengthScore*/ 1 && div_class_value !== (div_class_value = "h-full rounded-full transition-all duration-300 ease-out " + getStrengthColor(/*$strengthScore*/ ctx[0]))) {
					attr_dev(div, "class", div_class_value);
				}

				if (dirty & /*$strengthScore*/ 1) {
					set_style(div, "width", /*getStrengthWidth*/ ctx[4](/*$strengthScore*/ ctx[0]));
				}
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$6.name,
			type: "if",
			source: "(40:3) {#if $strengthScore > 0}",
			ctx
		});

		return block;
	}

	// (57:4) {#if index < $strengthResults.length - 1}
	function create_if_block$8(ctx) {
		let t;

		const block = {
			c: function create() {
				t = text(" ");
			},
			m: function mount(target, anchor) {
				insert_dev(target, t, anchor);
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(t);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$8.name,
			type: "if",
			source: "(57:4) {#if index < $strengthResults.length - 1}",
			ctx
		});

		return block;
	}

	// (53:3) {#each $strengthResults as condition, index}
	function create_each_block$1(ctx) {
		let span;
		let t0_value = /*condition*/ ctx[9].label + "";
		let t0;

		let t1_value = (/*index*/ ctx[11] < /*$strengthResults*/ ctx[1].length - 1
		? ","
		: "") + "";

		let t1;
		let span_class_value;
		let t2;
		let if_block_anchor;
		let if_block = /*index*/ ctx[11] < /*$strengthResults*/ ctx[1].length - 1 && create_if_block$8(ctx);

		const block = {
			c: function create() {
				span = element("span");
				t0 = text(t0_value);
				t1 = text(t1_value);
				t2 = space();
				if (if_block) if_block.c();
				if_block_anchor = empty();

				attr_dev(span, "class", span_class_value = /*condition*/ ctx[9].met
				? 'text-green-500'
				: 'text-yellow-300');

				add_location(span, file$b, 66, 4, 1860);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				append_dev(span, t0);
				append_dev(span, t1);
				insert_dev(target, t2, anchor);
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*$strengthResults*/ 2 && t0_value !== (t0_value = /*condition*/ ctx[9].label + "")) set_data_dev(t0, t0_value);

				if (dirty & /*$strengthResults*/ 2 && t1_value !== (t1_value = (/*index*/ ctx[11] < /*$strengthResults*/ ctx[1].length - 1
				? ","
				: "") + "")) set_data_dev(t1, t1_value);

				if (dirty & /*$strengthResults*/ 2 && span_class_value !== (span_class_value = /*condition*/ ctx[9].met
				? 'text-green-500'
				: 'text-yellow-300')) {
					attr_dev(span, "class", span_class_value);
				}

				if (/*index*/ ctx[11] < /*$strengthResults*/ ctx[1].length - 1) {
					if (if_block) ; else {
						if_block = create_if_block$8(ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
					detach_dev(t2);
					detach_dev(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block$1.name,
			type: "each",
			source: "(53:3) {#each $strengthResults as condition, index}",
			ctx
		});

		return block;
	}

	function create_fragment$b(ctx) {
		let div2;
		let div1;
		let div0;
		let t0;
		let p;
		let t1;
		let if_block = /*$strengthScore*/ ctx[0] > 0 && create_if_block_1$6(ctx);
		let each_value = ensure_array_like_dev(/*$strengthResults*/ ctx[1]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
		}

		const block = {
			c: function create() {
				div2 = element("div");
				div1 = element("div");
				div0 = element("div");
				if (if_block) if_block.c();
				t0 = space();
				p = element("p");
				t1 = text("Passphrase should include at least\n\t\t\t");

				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				attr_dev(div0, "class", "h-2 w-full bg-gray-300 rounded-full");
				add_location(div0, file$b, 51, 2, 1382);
				attr_dev(p, "class", "text-xs mt-1 font-light text-osvauld-sheffieldgrey text-center tracking-wide");
				add_location(p, file$b, 61, 2, 1675);
				attr_dev(div1, "class", "mb-4");
				add_location(div1, file$b, 50, 1, 1361);
				attr_dev(div2, "class", "w-[300px] rounded-xl shadow-md overflow-hidden p-2");
				add_location(div2, file$b, 49, 0, 1295);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div2, anchor);
				append_dev(div2, div1);
				append_dev(div1, div0);
				if (if_block) if_block.m(div0, null);
				append_dev(div1, t0);
				append_dev(div1, p);
				append_dev(p, t1);

				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(p, null);
					}
				}
			},
			p: function update(ctx, [dirty]) {
				if (/*$strengthScore*/ ctx[0] > 0) {
					if (if_block) {
						if_block.p(ctx, dirty);
					} else {
						if_block = create_if_block_1$6(ctx);
						if_block.c();
						if_block.m(div0, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if (dirty & /*$strengthResults*/ 2) {
					each_value = ensure_array_like_dev(/*$strengthResults*/ ctx[1]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context$1(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
						} else {
							each_blocks[i] = create_each_block$1(child_ctx);
							each_blocks[i].c();
							each_blocks[i].m(p, null);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].d(1);
					}

					each_blocks.length = each_value.length;
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div2);
				}

				if (if_block) if_block.d();
				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$b.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function getStrengthColor(score) {
		if (score <= 2) return "bg-red-500";
		if (score <= 4) return "bg-yellow-500";
		return "bg-green-500";
	}

	function instance$b($$self, $$props, $$invalidate) {
		let $strengthScore;
		let $strengthResults;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('PasswordStrengthValidator', slots, []);
		let { passphrase = "" } = $$props;
		let passphraseStore = writable(passphrase);
		let { isPassphraseAcceptable = false } = $$props;

		const conditions = [
			{
				key: "lowercase",
				label: "Lowercase letter",
				regex: /[a-z]/
			},
			{
				key: "uppercase",
				label: "Uppercase letter",
				regex: /[A-Z]/
			},
			{
				key: "number",
				label: "Number",
				regex: /[0-9]/
			},
			{
				key: "specialChar",
				label: "Special character",
				regex: /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>/?]/
			},
			{
				key: "length",
				label: "At least 8 characters"
			}
		];

		const strengthResults = derived(passphraseStore, $passphrase => conditions.map(condition => ({
			...condition,
			met: condition.key === "length"
			? $passphrase.length >= 8
			: condition.regex?.test($passphrase) ?? false
		})));

		validate_store(strengthResults, 'strengthResults');
		component_subscribe($$self, strengthResults, value => $$invalidate(1, $strengthResults = value));
		const strengthScore = derived(strengthResults, $results => $results.filter(result => result.met).length);
		validate_store(strengthScore, 'strengthScore');
		component_subscribe($$self, strengthScore, value => $$invalidate(0, $strengthScore = value));

		function getStrengthWidth(score) {
			return `${score / conditions.length * 100}%`;
		}

		const writable_props = ['passphrase', 'isPassphraseAcceptable'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PasswordStrengthValidator> was created with unknown prop '${key}'`);
		});

		$$self.$$set = $$props => {
			if ('passphrase' in $$props) $$invalidate(6, passphrase = $$props.passphrase);
			if ('isPassphraseAcceptable' in $$props) $$invalidate(5, isPassphraseAcceptable = $$props.isPassphraseAcceptable);
		};

		$$self.$capture_state = () => ({
			derived,
			writable,
			passphrase,
			passphraseStore,
			isPassphraseAcceptable,
			conditions,
			strengthResults,
			strengthScore,
			getStrengthColor,
			getStrengthWidth,
			$strengthScore,
			$strengthResults
		});

		$$self.$inject_state = $$props => {
			if ('passphrase' in $$props) $$invalidate(6, passphrase = $$props.passphrase);
			if ('passphraseStore' in $$props) $$invalidate(7, passphraseStore = $$props.passphraseStore);
			if ('isPassphraseAcceptable' in $$props) $$invalidate(5, isPassphraseAcceptable = $$props.isPassphraseAcceptable);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*passphrase*/ 64) {
				passphraseStore.set(passphrase);
			}

			if ($$self.$$.dirty & /*$strengthScore*/ 1) {
				$$invalidate(5, isPassphraseAcceptable = $strengthScore > 4);
			}
		};

		return [
			$strengthScore,
			$strengthResults,
			strengthResults,
			strengthScore,
			getStrengthWidth,
			isPassphraseAcceptable,
			passphrase
		];
	}

	class PasswordStrengthValidator extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$b, create_fragment$b, safe_not_equal, { passphrase: 6, isPassphraseAcceptable: 5 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "PasswordStrengthValidator",
				options,
				id: create_fragment$b.name
			});
		}

		get passphrase() {
			throw new Error("<PasswordStrengthValidator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set passphrase(value) {
			throw new Error("<PasswordStrengthValidator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isPassphraseAcceptable() {
			throw new Error("<PasswordStrengthValidator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isPassphraseAcceptable(value) {
			throw new Error("<PasswordStrengthValidator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/popup/SetPassPhrase.svelte generated by Svelte v4.2.19 */
	const file$a = "src/lib/components/popup/SetPassPhrase.svelte";

	// (102:3) {:else}
	function create_else_block_3(ctx) {
		let eye;
		let current;
		eye = new Eye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(eye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(eye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(eye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(eye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(eye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_3.name,
			type: "else",
			source: "(102:3) {:else}",
			ctx
		});

		return block;
	}

	// (100:3) {#if showFirstPassword}
	function create_if_block_3$3(ctx) {
		let closedeye;
		let current;
		closedeye = new ClosedEye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(closedeye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(closedeye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closedeye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(closedeye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(closedeye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$3.name,
			type: "if",
			source: "(100:3) {#if showFirstPassword}",
			ctx
		});

		return block;
	}

	// (128:3) {:else}
	function create_else_block_2$1(ctx) {
		let eye;
		let current;
		eye = new Eye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(eye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(eye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(eye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(eye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(eye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_2$1.name,
			type: "else",
			source: "(128:3) {:else}",
			ctx
		});

		return block;
	}

	// (126:3) {#if showSecondPassword}
	function create_if_block_2$3(ctx) {
		let closedeye;
		let current;
		closedeye = new ClosedEye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(closedeye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(closedeye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closedeye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(closedeye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(closedeye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$3.name,
			type: "if",
			source: "(126:3) {#if showSecondPassword}",
			ctx
		});

		return block;
	}

	// (140:1) {:else}
	function create_else_block_1$2(ctx) {
		let span;
		let t;
		let span_class_value;

		const block = {
			c: function create() {
				span = element("span");
				t = text("Passphrase doesn't match");

				attr_dev(span, "class", span_class_value = "mt-2 text-xs text-red-400 font-light " + (/*showPassphraseMismatchError*/ ctx[3]
				? 'visible'
				: 'invisible'));

				add_location(span, file$a, 152, 2, 4621);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				append_dev(span, t);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*showPassphraseMismatchError*/ 8 && span_class_value !== (span_class_value = "mt-2 text-xs text-red-400 font-light " + (/*showPassphraseMismatchError*/ ctx[3]
				? 'visible'
				: 'invisible'))) {
					attr_dev(span, "class", span_class_value);
				}
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_1$2.name,
			type: "else",
			source: "(140:1) {:else}",
			ctx
		});

		return block;
	}

	// (134:1) {#if passphraseEmpty}
	function create_if_block_1$5(ctx) {
		let span;
		let t;
		let span_class_value;

		const block = {
			c: function create() {
				span = element("span");
				t = text("Passphrase Empty!");
				attr_dev(span, "class", span_class_value = "mt-2 text-xs text-red-400 font-light " + (/*passphraseEmpty*/ ctx[4] ? 'visible' : 'invisible'));
				add_location(span, file$a, 146, 2, 4476);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				append_dev(span, t);
			},
			p: function update(ctx, dirty) {
				if (dirty & /*passphraseEmpty*/ 16 && span_class_value !== (span_class_value = "mt-2 text-xs text-red-400 font-light " + (/*passphraseEmpty*/ ctx[4] ? 'visible' : 'invisible'))) {
					attr_dev(span, "class", span_class_value);
				}
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$5.name,
			type: "if",
			source: "(134:1) {#if passphraseEmpty}",
			ctx
		});

		return block;
	}

	// (157:2) {:else}
	function create_else_block$5(ctx) {
		let span;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = "Submit";
				add_location(span, file$a, 169, 3, 5181);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$5.name,
			type: "else",
			source: "(157:2) {:else}",
			ctx
		});

		return block;
	}

	// (155:2) {#if isLoaderActive}
	function create_if_block$7(ctx) {
		let loader;
		let current;

		loader = new Loader({
				props: { size: 24, color: "#1F242A", duration: 1 },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(loader.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(loader, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(loader.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(loader.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(loader, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$7.name,
			type: "if",
			source: "(155:2) {#if isLoaderActive}",
			ctx
		});

		return block;
	}

	function create_fragment$a(ctx) {
		let form;
		let label0;
		let t1;
		let div0;
		let input0;
		let t2;
		let button0;
		let current_block_type_index;
		let if_block0;
		let t3;
		let passwordstrengthvalidator;
		let updating_isPassphraseAcceptable;
		let t4;
		let label1;
		let t6;
		let div1;
		let input1;
		let t7;
		let button1;
		let current_block_type_index_1;
		let if_block1;
		let t8;
		let t9;
		let button2;
		let current_block_type_index_2;
		let if_block3;
		let button2_class_value;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block_3$3, create_else_block_3];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*showFirstPassword*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function passwordstrengthvalidator_isPassphraseAcceptable_binding(value) {
			/*passwordstrengthvalidator_isPassphraseAcceptable_binding*/ ctx[18](value);
		}

		let passwordstrengthvalidator_props = { passphrase: /*passphrase*/ ctx[0] };

		if (/*isPassphraseAcceptable*/ ctx[6] !== void 0) {
			passwordstrengthvalidator_props.isPassphraseAcceptable = /*isPassphraseAcceptable*/ ctx[6];
		}

		passwordstrengthvalidator = new PasswordStrengthValidator({
				props: passwordstrengthvalidator_props,
				$$inline: true
			});

		binding_callbacks.push(() => bind(passwordstrengthvalidator, 'isPassphraseAcceptable', passwordstrengthvalidator_isPassphraseAcceptable_binding));
		const if_block_creators_1 = [create_if_block_2$3, create_else_block_2$1];
		const if_blocks_1 = [];

		function select_block_type_1(ctx, dirty) {
			if (/*showSecondPassword*/ ctx[2]) return 0;
			return 1;
		}

		current_block_type_index_1 = select_block_type_1(ctx);
		if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

		function select_block_type_2(ctx, dirty) {
			if (/*passphraseEmpty*/ ctx[4]) return create_if_block_1$5;
			return create_else_block_1$2;
		}

		let current_block_type = select_block_type_2(ctx);
		let if_block2 = current_block_type(ctx);
		const if_block_creators_2 = [create_if_block$7, create_else_block$5];
		const if_blocks_2 = [];

		function select_block_type_3(ctx, dirty) {
			if (/*isLoaderActive*/ ctx[5]) return 0;
			return 1;
		}

		current_block_type_index_2 = select_block_type_3(ctx);
		if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

		const block = {
			c: function create() {
				form = element("form");
				label0 = element("label");
				label0.textContent = "Enter Passphrase";
				t1 = space();
				div0 = element("div");
				input0 = element("input");
				t2 = space();
				button0 = element("button");
				if_block0.c();
				t3 = space();
				create_component(passwordstrengthvalidator.$$.fragment);
				t4 = space();
				label1 = element("label");
				label1.textContent = "Confirm Passphrase";
				t6 = space();
				div1 = element("div");
				input1 = element("input");
				t7 = space();
				button1 = element("button");
				if_block1.c();
				t8 = space();
				if_block2.c();
				t9 = space();
				button2 = element("button");
				if_block3.c();
				attr_dev(label0, "for", "passphrase");
				attr_dev(label0, "class", "font-normal mt-6");
				add_location(label0, file$a, 93, 1, 3021);
				attr_dev(input0, "class", "text-white bg-osvauld-frameblack border-0 tracking-wider font-normal border-transparent focus:border-transparent focus:ring-0 w-full");
				attr_dev(input0, "type", /*firstInputType*/ ctx[9]);
				attr_dev(input0, "autocomplete", "off");
				attr_dev(input0, "id", "password");
				add_location(input0, file$a, 98, 2, 3207);
				attr_dev(button0, "type", "button");
				attr_dev(button0, "class", "flex justify-center items-center");
				add_location(button0, file$a, 106, 2, 3480);
				attr_dev(div0, "class", "w-[300px] flex bg-osvauld-frameblack px-3 mt-4 border rounded-lg border-osvauld-iconblack");
				add_location(div0, file$a, 95, 1, 3097);
				attr_dev(label1, "for", "passphrase");
				attr_dev(label1, "class", "font-normal mt-6");
				add_location(label1, file$a, 119, 1, 3766);
				attr_dev(input1, "class", "text-white bg-osvauld-frameblack border-0 tracking-wider font-normal border-transparent focus:border-transparent focus:ring-0 w-full");
				attr_dev(input1, "type", /*secondInputType*/ ctx[8]);
				attr_dev(input1, "autocomplete", "off");
				attr_dev(input1, "id", "password");
				add_location(input1, file$a, 124, 2, 3954);
				attr_dev(button1, "type", "button");
				attr_dev(button1, "class", "flex justify-center items-center");
				add_location(button1, file$a, 132, 2, 4235);
				attr_dev(div1, "class", "w-[300px] flex bg-osvauld-frameblack px-3 mt-4 border rounded-lg border-osvauld-iconblack");
				add_location(div1, file$a, 121, 1, 3844);

				attr_dev(button2, "class", button2_class_value = "" + ((/*submitDisabled*/ ctx[7]
				? 'border border-osvauld-iconblack text-osvauld-sheffieldgrey'
				: 'bg-osvauld-carolinablue text-osvauld-ninjablack') + " py-2 px-10 mt-8 rounded-lg font-medium w-[150px] flex justify-center items-center whitespace-nowrap"));

				attr_dev(button2, "type", "submit");
				button2.disabled = /*submitDisabled*/ ctx[7];
				add_location(button2, file$a, 159, 1, 4783);
				attr_dev(form, "class", "flex flex-col justify-center items-center");
				add_location(form, file$a, 89, 0, 2908);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, form, anchor);
				append_dev(form, label0);
				append_dev(form, t1);
				append_dev(form, div0);
				append_dev(div0, input0);
				append_dev(div0, t2);
				append_dev(div0, button0);
				if_blocks[current_block_type_index].m(button0, null);
				append_dev(form, t3);
				mount_component(passwordstrengthvalidator, form, null);
				append_dev(form, t4);
				append_dev(form, label1);
				append_dev(form, t6);
				append_dev(form, div1);
				append_dev(div1, input1);
				append_dev(div1, t7);
				append_dev(div1, button1);
				if_blocks_1[current_block_type_index_1].m(button1, null);
				append_dev(form, t8);
				if_block2.m(form, null);
				append_dev(form, t9);
				append_dev(form, button2);
				if_blocks_2[current_block_type_index_2].m(button2, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(input0, "input", /*input_handler*/ ctx[16], false, false, false, false),
						listen_dev(button0, "click", /*click_handler*/ ctx[17], false, false, false, false),
						listen_dev(input1, "input", /*input_handler_1*/ ctx[19], false, false, false, false),
						listen_dev(button1, "click", /*click_handler_1*/ ctx[20], false, false, false, false),
						listen_dev(form, "submit", prevent_default(/*handlePassPhraseSubmit*/ ctx[10]), false, true, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (!current || dirty & /*firstInputType*/ 512) {
					attr_dev(input0, "type", /*firstInputType*/ ctx[9]);
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index !== previous_block_index) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					}

					transition_in(if_block0, 1);
					if_block0.m(button0, null);
				}

				const passwordstrengthvalidator_changes = {};
				if (dirty & /*passphrase*/ 1) passwordstrengthvalidator_changes.passphrase = /*passphrase*/ ctx[0];

				if (!updating_isPassphraseAcceptable && dirty & /*isPassphraseAcceptable*/ 64) {
					updating_isPassphraseAcceptable = true;
					passwordstrengthvalidator_changes.isPassphraseAcceptable = /*isPassphraseAcceptable*/ ctx[6];
					add_flush_callback(() => updating_isPassphraseAcceptable = false);
				}

				passwordstrengthvalidator.$set(passwordstrengthvalidator_changes);

				if (!current || dirty & /*secondInputType*/ 256) {
					attr_dev(input1, "type", /*secondInputType*/ ctx[8]);
				}

				let previous_block_index_1 = current_block_type_index_1;
				current_block_type_index_1 = select_block_type_1(ctx);

				if (current_block_type_index_1 !== previous_block_index_1) {
					group_outros();

					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
						if_blocks_1[previous_block_index_1] = null;
					});

					check_outros();
					if_block1 = if_blocks_1[current_block_type_index_1];

					if (!if_block1) {
						if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
						if_block1.c();
					}

					transition_in(if_block1, 1);
					if_block1.m(button1, null);
				}

				if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2.d(1);
					if_block2 = current_block_type(ctx);

					if (if_block2) {
						if_block2.c();
						if_block2.m(form, t9);
					}
				}

				let previous_block_index_2 = current_block_type_index_2;
				current_block_type_index_2 = select_block_type_3(ctx);

				if (current_block_type_index_2 !== previous_block_index_2) {
					group_outros();

					transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
						if_blocks_2[previous_block_index_2] = null;
					});

					check_outros();
					if_block3 = if_blocks_2[current_block_type_index_2];

					if (!if_block3) {
						if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
						if_block3.c();
					}

					transition_in(if_block3, 1);
					if_block3.m(button2, null);
				}

				if (!current || dirty & /*submitDisabled*/ 128 && button2_class_value !== (button2_class_value = "" + ((/*submitDisabled*/ ctx[7]
				? 'border border-osvauld-iconblack text-osvauld-sheffieldgrey'
				: 'bg-osvauld-carolinablue text-osvauld-ninjablack') + " py-2 px-10 mt-8 rounded-lg font-medium w-[150px] flex justify-center items-center whitespace-nowrap"))) {
					attr_dev(button2, "class", button2_class_value);
				}

				if (!current || dirty & /*submitDisabled*/ 128) {
					prop_dev(button2, "disabled", /*submitDisabled*/ ctx[7]);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(passwordstrengthvalidator.$$.fragment, local);
				transition_in(if_block1);
				transition_in(if_block3);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(passwordstrengthvalidator.$$.fragment, local);
				transition_out(if_block1);
				transition_out(if_block3);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(form);
				}

				if_blocks[current_block_type_index].d();
				destroy_component(passwordstrengthvalidator);
				if_blocks_1[current_block_type_index_1].d();
				if_block2.d();
				if_blocks_2[current_block_type_index_2].d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$a.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$a($$self, $$props, $$invalidate) {
		let firstInputType;
		let secondInputType;
		let submitDisabled;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('SetPassPhrase', slots, []);
		const dispatch = createEventDispatcher();
		let { challenge } = $$props;
		let { username } = $$props;
		let passphrase = "";
		let confirmPassphrase = "";
		let showFirstPassword = false;
		let showSecondPassword = false;
		let showPassphraseMismatchError = false;
		let passphraseEmpty = false;
		let isLoaderActive = false;
		let isPassphraseAcceptable = false;

		const handlePassPhraseSubmit = async () => {
			if (passphrase.length === 0) {
				$$invalidate(4, passphraseEmpty = true);
				$$invalidate(5, isLoaderActive = false);

				setTimeout(
					() => {
						$$invalidate(4, passphraseEmpty = false);
					},
					1500
				);

				return;
			}

			$$invalidate(5, isLoaderActive = true);

			if (passphrase === confirmPassphrase) {
				const response = await sendMessage("savePassphrase", { passphrase, challenge, username });
				const registrationResponse = await finalRegistration(response.username, response.signature, response.deviceKey, response.encryptionKey);

				if (registrationResponse.success) {
					$$invalidate(5, isLoaderActive = false);
					const pubkey = await sendMessage("getPubKey", { passphrase });
					const challengeResponse = await createChallenge(pubkey);

					const signature = await sendMessage("signChallenge", {
						challenge: challengeResponse.data.challenge
					});

					const verificationResponse = await initiateAuth(signature, pubkey);
					const token = verificationResponse.data.token;

					if (token) {
						await StorageService.setToken(token);
						await StorageService.setIsLoggedIn("true");
					}

					dispatch("signedUp");
				}
			} else {
				$$invalidate(3, showPassphraseMismatchError = true);
				$$invalidate(5, isLoaderActive = false);

				setTimeout(
					() => {
						$$invalidate(3, showPassphraseMismatchError = false);
					},
					1500
				);
			}
		};

		function onInput(event, type) {
			if (type === "passphrase") $$invalidate(0, passphrase = event.target.value); else $$invalidate(15, confirmPassphrase = event.target.value);
		}

		const togglePassword = identification => {
			identification
			? $$invalidate(1, showFirstPassword = !showFirstPassword)
			: $$invalidate(2, showSecondPassword = !showSecondPassword);
		};

		$$self.$$.on_mount.push(function () {
			if (challenge === undefined && !('challenge' in $$props || $$self.$$.bound[$$self.$$.props['challenge']])) {
				console.warn("<SetPassPhrase> was created without expected prop 'challenge'");
			}

			if (username === undefined && !('username' in $$props || $$self.$$.bound[$$self.$$.props['username']])) {
				console.warn("<SetPassPhrase> was created without expected prop 'username'");
			}
		});

		const writable_props = ['challenge', 'username'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SetPassPhrase> was created with unknown prop '${key}'`);
		});

		const input_handler = e => onInput(e, 'passphrase');
		const click_handler = () => togglePassword(true);

		function passwordstrengthvalidator_isPassphraseAcceptable_binding(value) {
			isPassphraseAcceptable = value;
			$$invalidate(6, isPassphraseAcceptable);
		}

		const input_handler_1 = e => onInput(e, 'confirmPassphrase');
		const click_handler_1 = () => togglePassword(false);

		$$self.$$set = $$props => {
			if ('challenge' in $$props) $$invalidate(13, challenge = $$props.challenge);
			if ('username' in $$props) $$invalidate(14, username = $$props.username);
		};

		$$self.$capture_state = () => ({
			Eye,
			ClosedEye,
			Loader,
			sendMessage,
			createEventDispatcher,
			createChallenge,
			finalRegistration,
			initiateAuth,
			StorageService,
			PasswordStrengthValidator,
			dispatch,
			challenge,
			username,
			passphrase,
			confirmPassphrase,
			showFirstPassword,
			showSecondPassword,
			showPassphraseMismatchError,
			passphraseEmpty,
			isLoaderActive,
			isPassphraseAcceptable,
			handlePassPhraseSubmit,
			onInput,
			togglePassword,
			submitDisabled,
			secondInputType,
			firstInputType
		});

		$$self.$inject_state = $$props => {
			if ('challenge' in $$props) $$invalidate(13, challenge = $$props.challenge);
			if ('username' in $$props) $$invalidate(14, username = $$props.username);
			if ('passphrase' in $$props) $$invalidate(0, passphrase = $$props.passphrase);
			if ('confirmPassphrase' in $$props) $$invalidate(15, confirmPassphrase = $$props.confirmPassphrase);
			if ('showFirstPassword' in $$props) $$invalidate(1, showFirstPassword = $$props.showFirstPassword);
			if ('showSecondPassword' in $$props) $$invalidate(2, showSecondPassword = $$props.showSecondPassword);
			if ('showPassphraseMismatchError' in $$props) $$invalidate(3, showPassphraseMismatchError = $$props.showPassphraseMismatchError);
			if ('passphraseEmpty' in $$props) $$invalidate(4, passphraseEmpty = $$props.passphraseEmpty);
			if ('isLoaderActive' in $$props) $$invalidate(5, isLoaderActive = $$props.isLoaderActive);
			if ('isPassphraseAcceptable' in $$props) $$invalidate(6, isPassphraseAcceptable = $$props.isPassphraseAcceptable);
			if ('submitDisabled' in $$props) $$invalidate(7, submitDisabled = $$props.submitDisabled);
			if ('secondInputType' in $$props) $$invalidate(8, secondInputType = $$props.secondInputType);
			if ('firstInputType' in $$props) $$invalidate(9, firstInputType = $$props.firstInputType);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*showFirstPassword*/ 2) {
				$$invalidate(9, firstInputType = showFirstPassword ? "text" : "password");
			}

			if ($$self.$$.dirty & /*showSecondPassword*/ 4) {
				$$invalidate(8, secondInputType = showSecondPassword ? "text" : "password");
			}

			if ($$self.$$.dirty & /*passphrase, confirmPassphrase*/ 32769) {
				$$invalidate(7, submitDisabled = passphrase.length === 0 || passphrase !== confirmPassphrase);
			}
		};

		return [
			passphrase,
			showFirstPassword,
			showSecondPassword,
			showPassphraseMismatchError,
			passphraseEmpty,
			isLoaderActive,
			isPassphraseAcceptable,
			submitDisabled,
			secondInputType,
			firstInputType,
			handlePassPhraseSubmit,
			onInput,
			togglePassword,
			challenge,
			username,
			confirmPassphrase,
			input_handler,
			click_handler,
			passwordstrengthvalidator_isPassphraseAcceptable_binding,
			input_handler_1,
			click_handler_1
		];
	}

	class SetPassPhrase extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$a, create_fragment$a, safe_not_equal, { challenge: 13, username: 14 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "SetPassPhrase",
				options,
				id: create_fragment$a.name
			});
		}

		get challenge() {
			throw new Error("<SetPassPhrase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set challenge(value) {
			throw new Error("<SetPassPhrase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get username() {
			throw new Error("<SetPassPhrase>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set username(value) {
			throw new Error("<SetPassPhrase>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/basic/NewPassword.svelte generated by Svelte v4.2.19 */
	const file$9 = "src/lib/components/basic/NewPassword.svelte";

	// (53:2) {#if isPassphraseAcceptable}
	function create_if_block_3$2(ctx) {
		let span;
		let tick_1;
		let current;
		tick_1 = new Tick({ $$inline: true });

		const block = {
			c: function create() {
				span = element("span");
				create_component(tick_1.$$.fragment);
				attr_dev(span, "class", "pr-2");
				add_location(span, file$9, 60, 3, 1787);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
				mount_component(tick_1, span, null);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(tick_1.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(tick_1.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}

				destroy_component(tick_1);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$2.name,
			type: "if",
			source: "(53:2) {#if isPassphraseAcceptable}",
			ctx
		});

		return block;
	}

	// (63:3) {:else}
	function create_else_block_2(ctx) {
		let eye;
		let current;
		eye = new Eye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(eye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(eye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(eye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(eye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(eye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_2.name,
			type: "else",
			source: "(63:3) {:else}",
			ctx
		});

		return block;
	}

	// (61:3) {#if showPassword}
	function create_if_block_2$2(ctx) {
		let closedeye;
		let current;
		closedeye = new ClosedEye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(closedeye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(closedeye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closedeye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(closedeye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(closedeye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$2.name,
			type: "if",
			source: "(61:3) {#if showPassword}",
			ctx
		});

		return block;
	}

	// (90:3) {:else}
	function create_else_block_1$1(ctx) {
		let eye;
		let current;
		eye = new Eye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(eye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(eye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(eye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(eye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(eye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_1$1.name,
			type: "else",
			source: "(90:3) {:else}",
			ctx
		});

		return block;
	}

	// (88:3) {#if showReenteredPassword}
	function create_if_block_1$4(ctx) {
		let closedeye;
		let current;
		closedeye = new ClosedEye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(closedeye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(closedeye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closedeye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(closedeye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(closedeye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$4.name,
			type: "if",
			source: "(88:3) {#if showReenteredPassword}",
			ctx
		});

		return block;
	}

	// (105:2) {:else}
	function create_else_block$4(ctx) {
		let span;

		const block = {
			c: function create() {
				span = element("span");
				span.textContent = "Submit";
				add_location(span, file$9, 112, 3, 3292);
			},
			m: function mount(target, anchor) {
				insert_dev(target, span, anchor);
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(span);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$4.name,
			type: "else",
			source: "(105:2) {:else}",
			ctx
		});

		return block;
	}

	// (103:2) {#if isLoaderActive}
	function create_if_block$6(ctx) {
		let loader;
		let current;
		loader = new Loader({ $$inline: true });

		const block = {
			c: function create() {
				create_component(loader.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(loader, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(loader.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(loader.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(loader, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$6.name,
			type: "if",
			source: "(103:2) {#if isLoaderActive}",
			ctx
		});

		return block;
	}

	function create_fragment$9(ctx) {
		let form;
		let label0;
		let t1;
		let div0;
		let input0;
		let input0_type_value;
		let t2;
		let t3;
		let button0;
		let current_block_type_index;
		let if_block1;
		let t4;
		let passwordstrengthvalidator;
		let updating_isPassphraseAcceptable;
		let t5;
		let label1;
		let t7;
		let div1;
		let input1;
		let input1_type_value;
		let input1_disabled_value;
		let t8;
		let button1;
		let current_block_type_index_1;
		let if_block2;
		let t9;
		let button2;
		let current_block_type_index_2;
		let if_block3;
		let button2_class_value;
		let current;
		let mounted;
		let dispose;
		let if_block0 = /*isPassphraseAcceptable*/ ctx[4] && create_if_block_3$2(ctx);
		const if_block_creators = [create_if_block_2$2, create_else_block_2];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*showPassword*/ ctx[1]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		function passwordstrengthvalidator_isPassphraseAcceptable_binding(value) {
			/*passwordstrengthvalidator_isPassphraseAcceptable_binding*/ ctx[12](value);
		}

		let passwordstrengthvalidator_props = { passphrase: /*passphrase*/ ctx[0] };

		if (/*isPassphraseAcceptable*/ ctx[4] !== void 0) {
			passwordstrengthvalidator_props.isPassphraseAcceptable = /*isPassphraseAcceptable*/ ctx[4];
		}

		passwordstrengthvalidator = new PasswordStrengthValidator({
				props: passwordstrengthvalidator_props,
				$$inline: true
			});

		binding_callbacks.push(() => bind(passwordstrengthvalidator, 'isPassphraseAcceptable', passwordstrengthvalidator_isPassphraseAcceptable_binding));
		const if_block_creators_1 = [create_if_block_1$4, create_else_block_1$1];
		const if_blocks_1 = [];

		function select_block_type_1(ctx, dirty) {
			if (/*showReenteredPassword*/ ctx[2]) return 0;
			return 1;
		}

		current_block_type_index_1 = select_block_type_1(ctx);
		if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
		const if_block_creators_2 = [create_if_block$6, create_else_block$4];
		const if_blocks_2 = [];

		function select_block_type_2(ctx, dirty) {
			if (/*isLoaderActive*/ ctx[3]) return 0;
			return 1;
		}

		current_block_type_index_2 = select_block_type_2(ctx);
		if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);

		const block = {
			c: function create() {
				form = element("form");
				label0 = element("label");
				label0.textContent = "Enter New Passphrase";
				t1 = space();
				div0 = element("div");
				input0 = element("input");
				t2 = space();
				if (if_block0) if_block0.c();
				t3 = space();
				button0 = element("button");
				if_block1.c();
				t4 = space();
				create_component(passwordstrengthvalidator.$$.fragment);
				t5 = space();
				label1 = element("label");
				label1.textContent = "Confirm New Passphrase";
				t7 = space();
				div1 = element("div");
				input1 = element("input");
				t8 = space();
				button1 = element("button");
				if_block2.c();
				t9 = space();
				button2 = element("button");
				if_block3.c();
				attr_dev(label0, "for", "passphrase");
				attr_dev(label0, "class", "font-normal mt-6 mb-2");
				add_location(label0, file$9, 46, 1, 1234);
				attr_dev(input0, "class", "text-white bg-osvauld-frameblack border-0 tracking-wider font-normal border-transparent focus:border-osvauld-iconblack focus:ring-0 active:outline-none focus:ring-offset-0");
				attr_dev(input0, "type", input0_type_value = /*showPassword*/ ctx[1] ? 'text' : 'password');
				attr_dev(input0, "id", "passphrase");
				add_location(input0, file$9, 52, 2, 1457);
				attr_dev(button0, "type", "button");
				attr_dev(button0, "class", "flex justify-center items-center");
				add_location(button0, file$9, 62, 2, 1832);
				attr_dev(div0, "class", "flex justify-between items-center bg-osvauld-frameblack px-3 border rounded-lg border-osvauld-iconblack w-[300px]");
				add_location(div0, file$9, 49, 1, 1323);
				attr_dev(label1, "for", "passphrase");
				attr_dev(label1, "class", "font-normal mt-2 mb-2");
				add_location(label1, file$9, 75, 1, 2123);
				attr_dev(input1, "class", "text-white bg-osvauld-frameblack border-0 tracking-wider font-normal border-transparent focus:border-osvauld-iconblack focus:ring-0 active:outline-none focus:ring-offset-0");
				attr_dev(input1, "type", input1_type_value = /*showReenteredPassword*/ ctx[2] ? 'text' : 'password');
				input1.disabled = input1_disabled_value = !/*isPassphraseAcceptable*/ ctx[4];
				attr_dev(input1, "id", "passphrase");
				add_location(input1, file$9, 81, 2, 2348);
				attr_dev(button1, "type", "button");
				attr_dev(button1, "class", "flex justify-center items-center");
				add_location(button1, file$9, 89, 2, 2707);
				attr_dev(div1, "class", "flex justify-between items-center bg-osvauld-frameblack px-3 border rounded-lg border-osvauld-iconblack w-[300px]");
				add_location(div1, file$9, 78, 1, 2214);

				attr_dev(button2, "class", button2_class_value = "" + ((/*submitDisabled*/ ctx[5]
				? 'border border-osvauld-iconblack text-osvauld-sheffieldgrey'
				: 'bg-osvauld-carolinablue text-osvauld-ninjablack') + " py-2 px-10 mt-8 rounded-lg font-medium w-[150px] flex justify-center items-center whitespace-nowrap"));

				attr_dev(button2, "type", "submit");
				button2.disabled = /*submitDisabled*/ ctx[5];
				add_location(button2, file$9, 102, 1, 2937);
				attr_dev(form, "class", "flex flex-col items-center justify-center");
				add_location(form, file$9, 42, 0, 1131);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, form, anchor);
				append_dev(form, label0);
				append_dev(form, t1);
				append_dev(form, div0);
				append_dev(div0, input0);
				append_dev(div0, t2);
				if (if_block0) if_block0.m(div0, null);
				append_dev(div0, t3);
				append_dev(div0, button0);
				if_blocks[current_block_type_index].m(button0, null);
				append_dev(form, t4);
				mount_component(passwordstrengthvalidator, form, null);
				append_dev(form, t5);
				append_dev(form, label1);
				append_dev(form, t7);
				append_dev(form, div1);
				append_dev(div1, input1);
				append_dev(div1, t8);
				append_dev(div1, button1);
				if_blocks_1[current_block_type_index_1].m(button1, null);
				append_dev(form, t9);
				append_dev(form, button2);
				if_blocks_2[current_block_type_index_2].m(button2, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(input0, "input", /*handleInputChange*/ ctx[7], false, false, false, false),
						listen_dev(button0, "click", /*click_handler*/ ctx[11], false, false, false, false),
						listen_dev(input1, "input", /*handleConfirmationInputChange*/ ctx[8], false, false, false, false),
						listen_dev(button1, "click", /*click_handler_1*/ ctx[13], false, false, false, false),
						listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[9]), false, true, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if (!current || dirty & /*showPassword*/ 2 && input0_type_value !== (input0_type_value = /*showPassword*/ ctx[1] ? 'text' : 'password')) {
					attr_dev(input0, "type", input0_type_value);
				}

				if (/*isPassphraseAcceptable*/ ctx[4]) {
					if (if_block0) {
						if (dirty & /*isPassphraseAcceptable*/ 16) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_3$2(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div0, t3);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index !== previous_block_index) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					}

					transition_in(if_block1, 1);
					if_block1.m(button0, null);
				}

				const passwordstrengthvalidator_changes = {};
				if (dirty & /*passphrase*/ 1) passwordstrengthvalidator_changes.passphrase = /*passphrase*/ ctx[0];

				if (!updating_isPassphraseAcceptable && dirty & /*isPassphraseAcceptable*/ 16) {
					updating_isPassphraseAcceptable = true;
					passwordstrengthvalidator_changes.isPassphraseAcceptable = /*isPassphraseAcceptable*/ ctx[4];
					add_flush_callback(() => updating_isPassphraseAcceptable = false);
				}

				passwordstrengthvalidator.$set(passwordstrengthvalidator_changes);

				if (!current || dirty & /*showReenteredPassword*/ 4 && input1_type_value !== (input1_type_value = /*showReenteredPassword*/ ctx[2] ? 'text' : 'password')) {
					attr_dev(input1, "type", input1_type_value);
				}

				if (!current || dirty & /*isPassphraseAcceptable*/ 16 && input1_disabled_value !== (input1_disabled_value = !/*isPassphraseAcceptable*/ ctx[4])) {
					prop_dev(input1, "disabled", input1_disabled_value);
				}

				let previous_block_index_1 = current_block_type_index_1;
				current_block_type_index_1 = select_block_type_1(ctx);

				if (current_block_type_index_1 !== previous_block_index_1) {
					group_outros();

					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
						if_blocks_1[previous_block_index_1] = null;
					});

					check_outros();
					if_block2 = if_blocks_1[current_block_type_index_1];

					if (!if_block2) {
						if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
						if_block2.c();
					}

					transition_in(if_block2, 1);
					if_block2.m(button1, null);
				}

				let previous_block_index_2 = current_block_type_index_2;
				current_block_type_index_2 = select_block_type_2(ctx);

				if (current_block_type_index_2 !== previous_block_index_2) {
					group_outros();

					transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
						if_blocks_2[previous_block_index_2] = null;
					});

					check_outros();
					if_block3 = if_blocks_2[current_block_type_index_2];

					if (!if_block3) {
						if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
						if_block3.c();
					}

					transition_in(if_block3, 1);
					if_block3.m(button2, null);
				}

				if (!current || dirty & /*submitDisabled*/ 32 && button2_class_value !== (button2_class_value = "" + ((/*submitDisabled*/ ctx[5]
				? 'border border-osvauld-iconblack text-osvauld-sheffieldgrey'
				: 'bg-osvauld-carolinablue text-osvauld-ninjablack') + " py-2 px-10 mt-8 rounded-lg font-medium w-[150px] flex justify-center items-center whitespace-nowrap"))) {
					attr_dev(button2, "class", button2_class_value);
				}

				if (!current || dirty & /*submitDisabled*/ 32) {
					prop_dev(button2, "disabled", /*submitDisabled*/ ctx[5]);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(passwordstrengthvalidator.$$.fragment, local);
				transition_in(if_block2);
				transition_in(if_block3);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(passwordstrengthvalidator.$$.fragment, local);
				transition_out(if_block2);
				transition_out(if_block3);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(form);
				}

				if (if_block0) if_block0.d();
				if_blocks[current_block_type_index].d();
				destroy_component(passwordstrengthvalidator);
				if_blocks_1[current_block_type_index_1].d();
				if_blocks_2[current_block_type_index_2].d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$9.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$9($$self, $$props, $$invalidate) {
		let submitDisabled;
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('NewPassword', slots, []);
		const dispatch = createEventDispatcher();
		let passphrase = "";
		let reenteredPassPhrase = "";
		let showPassword = false;
		let showReenteredPassword = false;
		let isLoaderActive = false;
		let isPassphraseAcceptable = false;

		const togglePasswordVisibility = isInitialResponse => {
			if (isInitialResponse) {
				$$invalidate(1, showPassword = !showPassword);
			} else {
				$$invalidate(2, showReenteredPassword = !showReenteredPassword);
			}
		};

		const handleInputChange = event => {
			$$invalidate(0, passphrase = event.target.value);
		};

		const handleConfirmationInputChange = event => {
			$$invalidate(10, reenteredPassPhrase = event.target.value);
		};

		const handleSubmit = () => {
			$$invalidate(3, isLoaderActive = true);
			dispatch("submit", { passphrase });
		};

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NewPassword> was created with unknown prop '${key}'`);
		});

		const click_handler = () => togglePasswordVisibility(true);

		function passwordstrengthvalidator_isPassphraseAcceptable_binding(value) {
			isPassphraseAcceptable = value;
			$$invalidate(4, isPassphraseAcceptable);
		}

		const click_handler_1 = () => togglePasswordVisibility(false);

		$$self.$capture_state = () => ({
			Loader,
			ClosedEye,
			Eye,
			Tick,
			createEventDispatcher,
			dispatch,
			PasswordStrengthValidator,
			passphrase,
			reenteredPassPhrase,
			showPassword,
			showReenteredPassword,
			isLoaderActive,
			isPassphraseAcceptable,
			togglePasswordVisibility,
			handleInputChange,
			handleConfirmationInputChange,
			handleSubmit,
			submitDisabled
		});

		$$self.$inject_state = $$props => {
			if ('passphrase' in $$props) $$invalidate(0, passphrase = $$props.passphrase);
			if ('reenteredPassPhrase' in $$props) $$invalidate(10, reenteredPassPhrase = $$props.reenteredPassPhrase);
			if ('showPassword' in $$props) $$invalidate(1, showPassword = $$props.showPassword);
			if ('showReenteredPassword' in $$props) $$invalidate(2, showReenteredPassword = $$props.showReenteredPassword);
			if ('isLoaderActive' in $$props) $$invalidate(3, isLoaderActive = $$props.isLoaderActive);
			if ('isPassphraseAcceptable' in $$props) $$invalidate(4, isPassphraseAcceptable = $$props.isPassphraseAcceptable);
			if ('submitDisabled' in $$props) $$invalidate(5, submitDisabled = $$props.submitDisabled);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		$$self.$$.update = () => {
			if ($$self.$$.dirty & /*passphrase, reenteredPassPhrase*/ 1025) {
				$$invalidate(5, submitDisabled = passphrase.length === 0 || passphrase !== reenteredPassPhrase);
			}
		};

		return [
			passphrase,
			showPassword,
			showReenteredPassword,
			isLoaderActive,
			isPassphraseAcceptable,
			submitDisabled,
			togglePasswordVisibility,
			handleInputChange,
			handleConfirmationInputChange,
			handleSubmit,
			reenteredPassPhrase,
			click_handler,
			passwordstrengthvalidator_isPassphraseAcceptable_binding,
			click_handler_1
		];
	}

	class NewPassword extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "NewPassword",
				options,
				id: create_fragment$9.name
			});
		}
	}

	/* src/lib/components/popup/ImportPvtKey.svelte generated by Svelte v4.2.19 */
	const file$8 = "src/lib/components/popup/ImportPvtKey.svelte";

	function create_fragment$8(ctx) {
		let div1;
		let div0;
		let h3;
		let t1;
		let label;
		let t3;
		let textarea;
		let t4;
		let newpassword;
		let current;
		let mounted;
		let dispose;
		newpassword = new NewPassword({ $$inline: true });
		newpassword.$on("submit", /*handleSubmit*/ ctx[1]);

		const block = {
			c: function create() {
				div1 = element("div");
				div0 = element("div");
				h3 = element("h3");
				h3.textContent = "Account Recovery";
				t1 = space();
				label = element("label");
				label.textContent = "Enter Recovery string";
				t3 = space();
				textarea = element("textarea");
				t4 = space();
				create_component(newpassword.$$.fragment);
				attr_dev(h3, "class", "font-medium text-3xl mb-6 text-osvauld-ownerText");
				add_location(h3, file$8, 39, 2, 1253);
				add_location(div0, file$8, 38, 1, 1245);
				attr_dev(label, "for", "privateKey");
				attr_dev(label, "class", "font-normal mt-6 mb-2");
				add_location(label, file$8, 43, 1, 1352);
				attr_dev(textarea, "class", "text-osvauld-quarzowhite bg-osvauld-frameblack border border-osvauld-iconblack tracking-wider font-light text-sm font-mono focus:border-osvauld-iconblack focus:ring-0 resize-none w-[300px] min-h-[6rem] max-h-[10rem] rounded-lg scrollbar-thin overflow-y-scroll");
				attr_dev(textarea, "id", "privateKey");
				add_location(textarea, file$8, 46, 1, 1442);
				attr_dev(div1, "class", "flex flex-col justify-center items-center text-osvauld-sheffieldgrey");
				add_location(div1, file$8, 35, 0, 1159);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, div0);
				append_dev(div0, h3);
				append_dev(div1, t1);
				append_dev(div1, label);
				append_dev(div1, t3);
				append_dev(div1, textarea);
				append_dev(div1, t4);
				mount_component(newpassword, div1, null);
				current = true;

				if (!mounted) {
					dispose = listen_dev(textarea, "input", /*handleInputChange*/ ctx[0], false, false, false, false);
					mounted = true;
				}
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(newpassword.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(newpassword.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}

				destroy_component(newpassword);
				mounted = false;
				dispose();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$8.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$8($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ImportPvtKey', slots, []);
		const dispatch = createEventDispatcher();
		let recoveryData = "";

		const handleInputChange = event => {
			recoveryData = event.target.value;
		};

		const handleSubmit = async e => {
			const passphrase = e.detail.passphrase;
			await sendMessage("importPvtKey", { passphrase, recoveryData });
			const pubkey = await sendMessage("getPubKey", { passphrase });
			const challengeResponse = await createChallenge(pubkey);

			const signature = await sendMessage("signChallenge", {
				challenge: challengeResponse.data.challenge
			});

			const verificationResponse = await initiateAuth(signature, pubkey);
			const token = verificationResponse.data.token;

			if (token) {
				await StorageService.setToken(token);
				await StorageService.setIsLoggedIn("true");
				dispatch("login", true);
			}
		};

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ImportPvtKey> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({
			createEventDispatcher,
			dispatch,
			sendMessage,
			StorageService,
			createChallenge,
			initiateAuth,
			NewPassword,
			recoveryData,
			handleInputChange,
			handleSubmit
		});

		$$self.$inject_state = $$props => {
			if ('recoveryData' in $$props) recoveryData = $$props.recoveryData;
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [handleInputChange, handleSubmit];
	}

	class ImportPvtKey extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ImportPvtKey",
				options,
				id: create_fragment$8.name
			});
		}
	}

	/* src/lib/components/popup/Signup.svelte generated by Svelte v4.2.19 */
	const file$7 = "src/lib/components/popup/Signup.svelte";

	// (30:1) {:else}
	function create_else_block$3(ctx) {
		let templogin;
		let current;
		templogin = new TempLogin({ $$inline: true });
		templogin.$on("setPassPhrase", /*handleTempLogin*/ ctx[4]);
		templogin.$on("recovery", /*handleRecovery*/ ctx[5]);

		const block = {
			c: function create() {
				create_component(templogin.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(templogin, target, anchor);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(templogin.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(templogin.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(templogin, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$3.name,
			type: "else",
			source: "(30:1) {:else}",
			ctx
		});

		return block;
	}

	// (28:31) 
	function create_if_block_1$3(ctx) {
		let setpassphrase;
		let current;

		setpassphrase = new SetPassPhrase({
				props: {
					challenge: /*challenge*/ ctx[1],
					username: /*username*/ ctx[2]
				},
				$$inline: true
			});

		setpassphrase.$on("signedUp", /*handleSignedUp*/ ctx[6]);

		const block = {
			c: function create() {
				create_component(setpassphrase.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(setpassphrase, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const setpassphrase_changes = {};
				if (dirty & /*challenge*/ 2) setpassphrase_changes.challenge = /*challenge*/ ctx[1];
				if (dirty & /*username*/ 4) setpassphrase_changes.username = /*username*/ ctx[2];
				setpassphrase.$set(setpassphrase_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(setpassphrase.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(setpassphrase.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(setpassphrase, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$3.name,
			type: "if",
			source: "(28:31) ",
			ctx
		});

		return block;
	}

	// (26:1) {#if importPvtKeyFlag}
	function create_if_block$5(ctx) {
		let importpvtkey;
		let current;
		importpvtkey = new ImportPvtKey({ $$inline: true });
		importpvtkey.$on("login", /*handleSignedUp*/ ctx[6]);

		const block = {
			c: function create() {
				create_component(importpvtkey.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(importpvtkey, target, anchor);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(importpvtkey.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(importpvtkey.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(importpvtkey, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$5.name,
			type: "if",
			source: "(26:1) {#if importPvtKeyFlag}",
			ctx
		});

		return block;
	}

	function create_fragment$7(ctx) {
		let div;
		let current_block_type_index;
		let if_block;
		let current;
		const if_block_creators = [create_if_block$5, create_if_block_1$3, create_else_block$3];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*importPvtKeyFlag*/ ctx[3]) return 0;
			if (/*isTempLoginVerified*/ ctx[0]) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				div = element("div");
				if_block.c();
				attr_dev(div, "class", "h-full w-full flex justify-center items-center text-base font-bold text-white");
				add_location(div, file$7, 27, 0, 633);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				if_blocks[current_block_type_index].m(div, null);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				if_blocks[current_block_type_index].d();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$7.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$7($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Signup', slots, []);
		let isTempLoginVerified = false;
		let challenge = "";
		let username = "";
		let importPvtKeyFlag = false;
		const dispatch = createEventDispatcher();

		const handleTempLogin = e => {
			$$invalidate(1, challenge = e.detail.challenge);
			$$invalidate(2, username = e.detail.username);
			$$invalidate(0, isTempLoginVerified = true);
		};

		const handleRecovery = e => {
			$$invalidate(3, importPvtKeyFlag = e.detail);
		};

		const handleSignedUp = () => {
			dispatch("signedUp");
		};

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Signup> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({
			TempLogin,
			SetPassPhrase,
			ImportPvtKey,
			createEventDispatcher,
			isTempLoginVerified,
			challenge,
			username,
			importPvtKeyFlag,
			dispatch,
			handleTempLogin,
			handleRecovery,
			handleSignedUp
		});

		$$self.$inject_state = $$props => {
			if ('isTempLoginVerified' in $$props) $$invalidate(0, isTempLoginVerified = $$props.isTempLoginVerified);
			if ('challenge' in $$props) $$invalidate(1, challenge = $$props.challenge);
			if ('username' in $$props) $$invalidate(2, username = $$props.username);
			if ('importPvtKeyFlag' in $$props) $$invalidate(3, importPvtKeyFlag = $$props.importPvtKeyFlag);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			isTempLoginVerified,
			challenge,
			username,
			importPvtKeyFlag,
			handleTempLogin,
			handleRecovery,
			handleSignedUp
		];
	}

	class Signup extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Signup",
				options,
				id: create_fragment$7.name
			});
		}
	}

	/* src/lib/components/dashboard/components/ExistingListParent.svelte generated by Svelte v4.2.19 */
	const file$6 = "src/lib/components/dashboard/components/ExistingListParent.svelte";

	function get_each_context(ctx, list, i) {
		const child_ctx = ctx.slice();
		child_ctx[8] = list[i];
		child_ctx[10] = i;
		return child_ctx;
	}

	// (19:2) {#if existingItemsData}
	function create_if_block$4(ctx) {
		let each_1_anchor;
		let current;
		let each_value = ensure_array_like_dev(/*existingItemsData*/ ctx[0]);
		let each_blocks = [];

		for (let i = 0; i < each_value.length; i += 1) {
			each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
		}

		const out = i => transition_out(each_blocks[i], 1, 1, () => {
			each_blocks[i] = null;
		});

		const block = {
			c: function create() {
				for (let i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				each_1_anchor = empty();
			},
			m: function mount(target, anchor) {
				for (let i = 0; i < each_blocks.length; i += 1) {
					if (each_blocks[i]) {
						each_blocks[i].m(target, anchor);
					}
				}

				insert_dev(target, each_1_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (dirty & /*existingItemsData, isUser, editPermissionTrigger, handleRemoval, handlePermissionChange*/ 31) {
					each_value = ensure_array_like_dev(/*existingItemsData*/ ctx[0]);
					let i;

					for (i = 0; i < each_value.length; i += 1) {
						const child_ctx = get_each_context(ctx, each_value, i);

						if (each_blocks[i]) {
							each_blocks[i].p(child_ctx, dirty);
							transition_in(each_blocks[i], 1);
						} else {
							each_blocks[i] = create_each_block(child_ctx);
							each_blocks[i].c();
							transition_in(each_blocks[i], 1);
							each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
						}
					}

					group_outros();

					for (i = each_value.length; i < each_blocks.length; i += 1) {
						out(i);
					}

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;

				for (let i = 0; i < each_value.length; i += 1) {
					transition_in(each_blocks[i]);
				}

				current = true;
			},
			o: function outro(local) {
				each_blocks = each_blocks.filter(Boolean);

				for (let i = 0; i < each_blocks.length; i += 1) {
					transition_out(each_blocks[i]);
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(each_1_anchor);
				}

				destroy_each(each_blocks, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$4.name,
			type: "if",
			source: "(19:2) {#if existingItemsData}",
			ctx
		});

		return block;
	}

	// (20:3) {#each existingItemsData as item, index}
	function create_each_block(ctx) {
		let existinglistitem;
		let current;

		function remove_handler() {
			return /*remove_handler*/ ctx[5](/*item*/ ctx[8]);
		}

		function permissonChange_handler(...args) {
			return /*permissonChange_handler*/ ctx[6](/*item*/ ctx[8], ...args);
		}

		existinglistitem = new ExistingListItem({
				props: {
					index: /*index*/ ctx[10],
					item: /*item*/ ctx[8],
					isUser: /*isUser*/ ctx[2],
					editPermissionTrigger: /*editPermissionTrigger*/ ctx[1],
					reverseModal: /*existingItemsData*/ ctx[0].length > 3 && /*index*/ ctx[10] > /*existingItemsData*/ ctx[0].length - 3
				},
				$$inline: true
			});

		existinglistitem.$on("remove", remove_handler);
		existinglistitem.$on("permissonChange", permissonChange_handler);

		const block = {
			c: function create() {
				create_component(existinglistitem.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(existinglistitem, target, anchor);
				current = true;
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;
				const existinglistitem_changes = {};
				if (dirty & /*existingItemsData*/ 1) existinglistitem_changes.item = /*item*/ ctx[8];
				if (dirty & /*isUser*/ 4) existinglistitem_changes.isUser = /*isUser*/ ctx[2];
				if (dirty & /*editPermissionTrigger*/ 2) existinglistitem_changes.editPermissionTrigger = /*editPermissionTrigger*/ ctx[1];
				if (dirty & /*existingItemsData*/ 1) existinglistitem_changes.reverseModal = /*existingItemsData*/ ctx[0].length > 3 && /*index*/ ctx[10] > /*existingItemsData*/ ctx[0].length - 3;
				existinglistitem.$set(existinglistitem_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(existinglistitem.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(existinglistitem.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(existinglistitem, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_each_block.name,
			type: "each",
			source: "(20:3) {#each existingItemsData as item, index}",
			ctx
		});

		return block;
	}

	function create_fragment$6(ctx) {
		let div1;
		let div0;
		let current;
		let if_block = /*existingItemsData*/ ctx[0] && create_if_block$4(ctx);

		const block = {
			c: function create() {
				div1 = element("div");
				div0 = element("div");
				if (if_block) if_block.c();
				attr_dev(div0, "class", "overflow-y-scroll scrollbar-thin h-[16rem] pr-1 bg-osvauld-frameblack w-full");
				add_location(div0, file$6, 22, 1, 516);
				attr_dev(div1, "class", "py-2 px-0 mt-0 mb-2 w-full rounded-lg min-h-0 max-h-[50vh]");
				add_location(div1, file$6, 21, 0, 442);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, div0);
				if (if_block) if_block.m(div0, null);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (/*existingItemsData*/ ctx[0]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*existingItemsData*/ 1) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$4(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(div0, null);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}

				if (if_block) if_block.d();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$6.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$6($$self, $$props, $$invalidate) {
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ExistingListParent', slots, []);
		let { existingItemsData } = $$props;
		let { editPermissionTrigger } = $$props;
		let { isUser } = $$props;
		const dispatch = createEventDispatcher();

		const handleRemoval = item => {
			dispatch("remove", item);
		};

		const handlePermissionChange = (e, item) => {
			dispatch("permissionChange", { item, permission: e.detail });
		};

		$$self.$$.on_mount.push(function () {
			if (existingItemsData === undefined && !('existingItemsData' in $$props || $$self.$$.bound[$$self.$$.props['existingItemsData']])) {
				console.warn("<ExistingListParent> was created without expected prop 'existingItemsData'");
			}

			if (editPermissionTrigger === undefined && !('editPermissionTrigger' in $$props || $$self.$$.bound[$$self.$$.props['editPermissionTrigger']])) {
				console.warn("<ExistingListParent> was created without expected prop 'editPermissionTrigger'");
			}

			if (isUser === undefined && !('isUser' in $$props || $$self.$$.bound[$$self.$$.props['isUser']])) {
				console.warn("<ExistingListParent> was created without expected prop 'isUser'");
			}
		});

		const writable_props = ['existingItemsData', 'editPermissionTrigger', 'isUser'];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ExistingListParent> was created with unknown prop '${key}'`);
		});

		const remove_handler = item => handleRemoval(item);
		const permissonChange_handler = (item, e) => handlePermissionChange(e, item);

		$$self.$$set = $$props => {
			if ('existingItemsData' in $$props) $$invalidate(0, existingItemsData = $$props.existingItemsData);
			if ('editPermissionTrigger' in $$props) $$invalidate(1, editPermissionTrigger = $$props.editPermissionTrigger);
			if ('isUser' in $$props) $$invalidate(2, isUser = $$props.isUser);
		};

		$$self.$capture_state = () => ({
			createEventDispatcher,
			ExistingListItem,
			existingItemsData,
			editPermissionTrigger,
			isUser,
			dispatch,
			handleRemoval,
			handlePermissionChange
		});

		$$self.$inject_state = $$props => {
			if ('existingItemsData' in $$props) $$invalidate(0, existingItemsData = $$props.existingItemsData);
			if ('editPermissionTrigger' in $$props) $$invalidate(1, editPermissionTrigger = $$props.editPermissionTrigger);
			if ('isUser' in $$props) $$invalidate(2, isUser = $$props.isUser);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			existingItemsData,
			editPermissionTrigger,
			isUser,
			handleRemoval,
			handlePermissionChange,
			remove_handler,
			permissonChange_handler
		];
	}

	class ExistingListParent extends SvelteComponentDev {
		constructor(options) {
			super(options);

			init(this, options, instance$6, create_fragment$6, safe_not_equal, {
				existingItemsData: 0,
				editPermissionTrigger: 1,
				isUser: 2
			});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ExistingListParent",
				options,
				id: create_fragment$6.name
			});
		}

		get existingItemsData() {
			throw new Error("<ExistingListParent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set existingItemsData(value) {
			throw new Error("<ExistingListParent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get editPermissionTrigger() {
			throw new Error("<ExistingListParent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set editPermissionTrigger(value) {
			throw new Error("<ExistingListParent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		get isUser() {
			throw new Error("<ExistingListParent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}

		set isUser(value) {
			throw new Error("<ExistingListParent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/credentials/AccessListModal.svelte generated by Svelte v4.2.19 */

	const { Error: Error_1 } = globals;
	const file$5 = "src/lib/components/dashboard/credentials/AccessListModal.svelte";

	// (113:1) {#if showInfoTab}
	function create_if_block_1$2(ctx) {
		let div;
		let span;
		let infoicon;
		let t0;
		let p;
		let current;
		infoicon = new InfoIcon({ $$inline: true });

		const block = {
			c: function create() {
				div = element("div");
				span = element("span");
				create_component(infoicon.$$.fragment);
				t0 = space();
				p = element("p");
				p.textContent = "This folder contains credentials you have access directly or indirectly\n\t\t\t\tthrough below assignments";
				attr_dev(span, "class", "w-[12%] mt-1");
				add_location(span, file$5, 145, 3, 4079);
				attr_dev(p, "class", "text-sm text-osvauld-sheffieldgrey font-normal");
				add_location(p, file$5, 146, 3, 4131);
				attr_dev(div, "class", "relative h-auto w-full px-4 py-2 mx-auto flex justify-between items-start rounded-lg cursor-pointer mb-3 bg-osvauld-fieldActive");
				add_location(div, file$5, 142, 2, 3928);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				append_dev(div, span);
				mount_component(infoicon, span, null);
				append_dev(div, t0);
				append_dev(div, p);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(infoicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(infoicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(infoicon);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$2.name,
			type: "if",
			source: "(113:1) {#if showInfoTab}",
			ctx
		});

		return block;
	}

	// (164:3) {:else}
	function create_else_block$2(ctx) {
		let existinglistparent;
		let current;

		existinglistparent = new ExistingListParent({
				props: {
					editPermissionTrigger: /*editPermissionTrigger*/ ctx[4],
					isUser: false,
					existingItemsData: /*existingGroupsData*/ ctx[2]
				},
				$$inline: true
			});

		existinglistparent.$on("remove", /*remove_handler_1*/ ctx[20]);
		existinglistparent.$on("permissionChange", /*permissionChange_handler_1*/ ctx[21]);

		const block = {
			c: function create() {
				create_component(existinglistparent.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(existinglistparent, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const existinglistparent_changes = {};
				if (dirty & /*editPermissionTrigger*/ 16) existinglistparent_changes.editPermissionTrigger = /*editPermissionTrigger*/ ctx[4];
				if (dirty & /*existingGroupsData*/ 4) existinglistparent_changes.existingItemsData = /*existingGroupsData*/ ctx[2];
				existinglistparent.$set(existinglistparent_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(existinglistparent.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(existinglistparent.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(existinglistparent, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$2.name,
			type: "else",
			source: "(164:3) {:else}",
			ctx
		});

		return block;
	}

	// (156:3) {#if selectedTab === "Users"}
	function create_if_block$3(ctx) {
		let existinglistparent;
		let current;

		existinglistparent = new ExistingListParent({
				props: {
					isUser: true,
					editPermissionTrigger: /*editPermissionTrigger*/ ctx[4],
					existingItemsData: /*existingUserData*/ ctx[1]
				},
				$$inline: true
			});

		existinglistparent.$on("remove", /*remove_handler*/ ctx[18]);
		existinglistparent.$on("permissionChange", /*permissionChange_handler*/ ctx[19]);

		const block = {
			c: function create() {
				create_component(existinglistparent.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(existinglistparent, target, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				const existinglistparent_changes = {};
				if (dirty & /*editPermissionTrigger*/ 16) existinglistparent_changes.editPermissionTrigger = /*editPermissionTrigger*/ ctx[4];
				if (dirty & /*existingUserData*/ 2) existinglistparent_changes.existingItemsData = /*existingUserData*/ ctx[1];
				existinglistparent.$set(existinglistparent_changes);
			},
			i: function intro(local) {
				if (current) return;
				transition_in(existinglistparent.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(existinglistparent.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(existinglistparent, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$3.name,
			type: "if",
			source: "(156:3) {#if selectedTab === \\\"Users\\\"}",
			ctx
		});

		return block;
	}

	function create_fragment$5(ctx) {
		let div6;
		let div0;
		let span;
		let t0;
		let button0;
		let infoicon;
		let t1;
		let button1;
		let closepanel;
		let t2;
		let t3;
		let div2;
		let toggle;
		let t4;
		let div1;
		let button2;
		let editicon;
		let button2_class_value;
		let t5;
		let div5;
		let div3;
		let lens;
		let t6;
		let input;
		let t7;
		let div4;
		let current_block_type_index;
		let if_block1;
		let div6_intro;
		let current;
		let mounted;
		let dispose;

		infoicon = new InfoIcon({
				props: {
					color: /*infoOnHover*/ ctx[5] ? '#BFC0CC' : '#4D4F60'
				},
				$$inline: true
			});

		closepanel = new ClosePanel({ $$inline: true });
		let if_block0 = /*showInfoTab*/ ctx[6] && create_if_block_1$2(ctx);
		toggle = new Toggle({ $$inline: true });
		toggle.$on("select", /*toggleSelect*/ ctx[10]);

		editicon = new EditIcon({
				props: {
					color: /*editPermissionTrigger*/ ctx[4] ? '#89B4FA' : '#6E7681'
				},
				$$inline: true
			});

		lens = new Lens({ $$inline: true });
		const if_block_creators = [create_if_block$3, create_else_block$2];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*selectedTab*/ ctx[3] === "Users") return 0;
			return 1;
		}

		current_block_type_index = select_block_type(ctx);
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				div6 = element("div");
				div0 = element("div");
				span = element("span");
				t0 = text("Access List\n\t\t\t");
				button0 = element("button");
				create_component(infoicon.$$.fragment);
				t1 = space();
				button1 = element("button");
				create_component(closepanel.$$.fragment);
				t2 = space();
				if (if_block0) if_block0.c();
				t3 = space();
				div2 = element("div");
				create_component(toggle.$$.fragment);
				t4 = space();
				div1 = element("div");
				button2 = element("button");
				create_component(editicon.$$.fragment);
				t5 = space();
				div5 = element("div");
				div3 = element("div");
				create_component(lens.$$.fragment);
				t6 = space();
				input = element("input");
				t7 = space();
				div4 = element("div");
				if_block1.c();
				attr_dev(button0, "class", "ml-2 pt-1");
				add_location(button0, file$5, 130, 3, 3552);
				attr_dev(span, "class", "font-sans text-osvauld-quarzowhite text-2xl font-normal");
				add_location(span, file$5, 128, 2, 3463);
				attr_dev(button1, "class", "p-2");
				add_location(button1, file$5, 138, 2, 3822);
				attr_dev(div0, "class", "flex justify-between items-center p-3");
				add_location(div0, file$5, 127, 1, 3409);

				attr_dev(button2, "class", button2_class_value = "p-2 rounded-lg " + (/*editPermissionTrigger*/ ctx[4]
				? 'bg-osvauld-cardshade'
				: '') + " " + (/*$selectedFolder*/ ctx[7]?.accessType === 'manager'
				? 'visible'
				: 'hidden'));

				add_location(button2, file$5, 155, 3, 4464);
				attr_dev(div1, "class", "flex justify-end items-center w-full");
				add_location(div1, file$5, 154, 2, 4410);
				attr_dev(div2, "class", "flex justify-around items-center");
				add_location(div2, file$5, 152, 1, 4321);
				attr_dev(input, "type", "text");
				attr_dev(input, "class", "h-[1.60rem] w-full bg-osvauld-frameblack border-0 text-osvauld-quarzowhite placeholder-osvauld-placeholderblack border-transparent text-base focus:border-transparent focus:ring-0 cursor-pointer");
				attr_dev(input, "placeholder", "Search for users");
				add_location(input, file$5, 174, 3, 5035);
				attr_dev(div3, "class", "h-[1.875rem] w-full px-2 mx-auto flex justify-start items-center border border-osvauld-iconblack rounded-lg cursor-pointer");
				add_location(div3, file$5, 170, 2, 4877);
				attr_dev(div4, "class", "overflow-y-auto scrollbar-thin min-h-0 max-h-[35vh] bg-osvauld-frameblack w-full flex flex-col justify-center items-center");
				add_location(div4, file$5, 181, 2, 5317);
				attr_dev(div5, "class", "p-2rounded-lg max-h-[65vh]");
				add_location(div5, file$5, 169, 1, 4834);
				attr_dev(div6, "class", "absolute w-[29rem] min-h-[30rem] max-h-[40rem] p-4 z-50 bg-osvauld-frameblack border border-osvauld-iconblack rounded-2xl");
				set_style(div6, "top", /*$buttonCoords*/ ctx[8].top + "px");
				set_style(div6, "right", window.innerWidth - /*$buttonCoords*/ ctx[8].right + "px");
				add_location(div6, file$5, 119, 0, 3111);
			},
			l: function claim(nodes) {
				throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div6, anchor);
				append_dev(div6, div0);
				append_dev(div0, span);
				append_dev(span, t0);
				append_dev(span, button0);
				mount_component(infoicon, button0, null);
				append_dev(div0, t1);
				append_dev(div0, button1);
				mount_component(closepanel, button1, null);
				append_dev(div6, t2);
				if (if_block0) if_block0.m(div6, null);
				append_dev(div6, t3);
				append_dev(div6, div2);
				mount_component(toggle, div2, null);
				append_dev(div2, t4);
				append_dev(div2, div1);
				append_dev(div1, button2);
				mount_component(editicon, button2, null);
				append_dev(div6, t5);
				append_dev(div6, div5);
				append_dev(div5, div3);
				mount_component(lens, div3, null);
				append_dev(div3, t6);
				append_dev(div3, input);
				append_dev(div5, t7);
				append_dev(div5, div4);
				if_blocks[current_block_type_index].m(div4, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "mouseenter", /*mouseenter_handler*/ ctx[14], false, false, false, false),
						listen_dev(button0, "mouseleave", /*mouseleave_handler*/ ctx[15], false, false, false, false),
						listen_dev(button0, "click", /*click_handler*/ ctx[16], false, false, false, false),
						listen_dev(button1, "click", /*handleClickOutside*/ ctx[9], false, false, false, false),
						listen_dev(button2, "click", /*click_handler_1*/ ctx[17], false, false, false, false),
						action_destroyer(clickOutside.call(null, div6)),
						listen_dev(div6, "clickedOutside", /*handleClickOutside*/ ctx[9], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				const infoicon_changes = {};
				if (dirty & /*infoOnHover*/ 32) infoicon_changes.color = /*infoOnHover*/ ctx[5] ? '#BFC0CC' : '#4D4F60';
				infoicon.$set(infoicon_changes);

				if (/*showInfoTab*/ ctx[6]) {
					if (if_block0) {
						if (dirty & /*showInfoTab*/ 64) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_1$2(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(div6, t3);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				const editicon_changes = {};
				if (dirty & /*editPermissionTrigger*/ 16) editicon_changes.color = /*editPermissionTrigger*/ ctx[4] ? '#89B4FA' : '#6E7681';
				editicon.$set(editicon_changes);

				if (!current || dirty & /*editPermissionTrigger, $selectedFolder*/ 144 && button2_class_value !== (button2_class_value = "p-2 rounded-lg " + (/*editPermissionTrigger*/ ctx[4]
				? 'bg-osvauld-cardshade'
				: '') + " " + (/*$selectedFolder*/ ctx[7]?.accessType === 'manager'
				? 'visible'
				: 'hidden'))) {
					attr_dev(button2, "class", button2_class_value);
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div4, null);
				}

				if (!current || dirty & /*$buttonCoords*/ 256) {
					set_style(div6, "top", /*$buttonCoords*/ ctx[8].top + "px");
				}

				if (!current || dirty & /*$buttonCoords*/ 256) {
					set_style(div6, "right", window.innerWidth - /*$buttonCoords*/ ctx[8].right + "px");
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(infoicon.$$.fragment, local);
				transition_in(closepanel.$$.fragment, local);
				transition_in(if_block0);
				transition_in(toggle.$$.fragment, local);
				transition_in(editicon.$$.fragment, local);
				transition_in(lens.$$.fragment, local);
				transition_in(if_block1);

				if (local) {
					if (!div6_intro) {
						add_render_callback(() => {
							div6_intro = create_in_transition(div6, fly, {});
							div6_intro.start();
						});
					}
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(infoicon.$$.fragment, local);
				transition_out(closepanel.$$.fragment, local);
				transition_out(if_block0);
				transition_out(toggle.$$.fragment, local);
				transition_out(editicon.$$.fragment, local);
				transition_out(lens.$$.fragment, local);
				transition_out(if_block1);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div6);
				}

				destroy_component(infoicon);
				destroy_component(closepanel);
				if (if_block0) if_block0.d();
				destroy_component(toggle);
				destroy_component(editicon);
				destroy_component(lens);
				if_blocks[current_block_type_index].d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$5.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$5($$self, $$props, $$invalidate) {
		let $selectedFolder;

		let $buttonCoords,
			$$unsubscribe_buttonCoords = noop,
			$$subscribe_buttonCoords = () => ($$unsubscribe_buttonCoords(), $$unsubscribe_buttonCoords = subscribe(buttonCoords, $$value => $$invalidate(8, $buttonCoords = $$value)), buttonCoords);

		validate_store(selectedFolder, 'selectedFolder');
		component_subscribe($$self, selectedFolder, $$value => $$invalidate(7, $selectedFolder = $$value));
		$$self.$$.on_destroy.push(() => $$unsubscribe_buttonCoords());
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('AccessListModal', slots, []);
		let existingUserData = [];
		let existingGroupsData = [];
		let selectedTab = "Groups";
		let editPermissionTrigger = false;
		let infoOnHover = false;
		let showInfoTab = false;

		const buttonCoords = derived(buttonRef, $buttonRef => {
			if ($buttonRef) {
				// @ts-ignore
				const rect = $buttonRef.getBoundingClientRect();

				const rightVal = rect.right + window.scrollX;

				return {
					top: rect.top + window.scrollY + rect.height + 10,
					right: rightVal
				};
			}

			return { top: 0, left: 0 };
		});

		validate_store(buttonCoords, 'buttonCoords');
		$$subscribe_buttonCoords();

		function handleClickOutside() {
			accessListSelected.set(false);
			buttonRef.set(null);
		}

		const toggleSelect = async e => {
			$$invalidate(3, selectedTab = e.detail);
			await existingItems();
		};

		const existingItems = async () => {
			if ($selectedFolder && selectedTab === "Users") {
				const responseJson = await fetchFolderUsers($selectedFolder.id);
				$$invalidate(1, existingUserData = responseJson.data);
			} else {
				$$invalidate(1, existingUserData.length = 0, existingUserData);
			}

			if ($selectedFolder && selectedTab === "Groups") {
				const reponseJson = await fetchFolderGroups($selectedFolder.id);
				$$invalidate(2, existingGroupsData = reponseJson.data);
			} else {
				$$invalidate(2, existingGroupsData.length = 0, existingGroupsData);
			}
		};

		const removeExistingUser = async e => {
			if ($selectedFolder === undefined) {
				throw new Error("Folder not selected");
			}

			await removeUserFromFolder($selectedFolder.id, e.detail.id);
			await existingItems();
		};

		const removeExistingGroup = async e => {
			if ($selectedFolder === undefined) {
				throw new Error("Folder not selected");
			}

			await removeGroupFromFolder($selectedFolder.id, e.detail.groupId);
			await existingItems();
		};

		const handlePermissionChange = async e => {
			if (!$selectedFolder) {
				throw new Error("Folder not selected");
			}

			let editPermissionResponse;

			if (selectedTab === "Users") {
				editPermissionResponse = await editFolderPermissionForUser($selectedFolder.id, e.detail.item.id, e.detail.permission);
			} else {
				editPermissionResponse = await editFolderPermissionForGroup($selectedFolder.id, e.detail.item.groupId, e.detail.permission);
			}

			if (editPermissionResponse.success) {
				toastStore.set({
					show: editPermissionResponse.success,
					message: editPermissionResponse.message,
					type: true
				});
			}

			await existingItems();
		};

		onMount(async () => {
			await existingItems();
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AccessListModal> was created with unknown prop '${key}'`);
		});

		const mouseenter_handler = () => $$invalidate(5, infoOnHover = true);
		const mouseleave_handler = () => $$invalidate(5, infoOnHover = false);
		const click_handler = () => $$invalidate(6, showInfoTab = !showInfoTab);

		const click_handler_1 = () => {
			$$invalidate(4, editPermissionTrigger = !editPermissionTrigger);
		};

		const remove_handler = e => removeExistingUser(e);
		const permissionChange_handler = e => handlePermissionChange(e);
		const remove_handler_1 = e => removeExistingGroup(e);
		const permissionChange_handler_1 = e => handlePermissionChange(e);

		$$self.$capture_state = () => ({
			Lens,
			ClosePanel,
			EditIcon,
			InfoIcon,
			ExistingListParent,
			Toggle,
			accessListSelected,
			selectedFolder,
			buttonRef,
			toastStore,
			fetchFolderUsers,
			removeUserFromFolder,
			editFolderPermissionForUser,
			fetchFolderGroups,
			removeGroupFromFolder,
			editFolderPermissionForGroup,
			clickOutside,
			derived,
			onMount,
			fly,
			existingUserData,
			existingGroupsData,
			selectedTab,
			editPermissionTrigger,
			infoOnHover,
			showInfoTab,
			buttonCoords,
			handleClickOutside,
			toggleSelect,
			existingItems,
			removeExistingUser,
			removeExistingGroup,
			handlePermissionChange,
			$selectedFolder,
			$buttonCoords
		});

		$$self.$inject_state = $$props => {
			if ('existingUserData' in $$props) $$invalidate(1, existingUserData = $$props.existingUserData);
			if ('existingGroupsData' in $$props) $$invalidate(2, existingGroupsData = $$props.existingGroupsData);
			if ('selectedTab' in $$props) $$invalidate(3, selectedTab = $$props.selectedTab);
			if ('editPermissionTrigger' in $$props) $$invalidate(4, editPermissionTrigger = $$props.editPermissionTrigger);
			if ('infoOnHover' in $$props) $$invalidate(5, infoOnHover = $$props.infoOnHover);
			if ('showInfoTab' in $$props) $$invalidate(6, showInfoTab = $$props.showInfoTab);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			buttonCoords,
			existingUserData,
			existingGroupsData,
			selectedTab,
			editPermissionTrigger,
			infoOnHover,
			showInfoTab,
			$selectedFolder,
			$buttonCoords,
			handleClickOutside,
			toggleSelect,
			removeExistingUser,
			removeExistingGroup,
			handlePermissionChange,
			mouseenter_handler,
			mouseleave_handler,
			click_handler,
			click_handler_1,
			remove_handler,
			permissionChange_handler,
			remove_handler_1,
			permissionChange_handler_1
		];
	}

	class AccessListModal extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$5, create_fragment$5, safe_not_equal, { buttonCoords: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "AccessListModal",
				options,
				id: create_fragment$5.name
			});
		}

		get buttonCoords() {
			return this.$$.ctx[0];
		}

		set buttonCoords(value) {
			throw new Error_1("<AccessListModal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/components/MoreActionsGroup.svelte generated by Svelte v4.2.19 */
	const file$4 = "src/lib/components/dashboard/components/MoreActionsGroup.svelte";

	// (53:0) {#if $showMoreGroupOptions && $buttonRef && $modalManager}
	function create_if_block$2(ctx) {
		let div5;
		let div4;
		let button0;
		let div0;
		let editicon;
		let t0;
		let div1;
		let t2;
		let button1;
		let div2;
		let binicon;
		let t3;
		let div3;
		let t4;

		let t5_value = (/*$modalManager*/ ctx[3].type === "Folder"
		? "folder"
		: "") + "";

		let t5;
		let div5_class_value;
		let current;
		let mounted;
		let dispose;

		editicon = new EditIcon({
				props: {
					color: /*isEditHovered*/ ctx[1] ? '#F2F2F0' : '#85889C'
				},
				$$inline: true
			});

		binicon = new BinIcon({
				props: {
					color: /*isBinHovered*/ ctx[2] ? '#F2F2F0' : '#85889C'
				},
				$$inline: true
			});

		const block = {
			c: function create() {
				div5 = element("div");
				div4 = element("div");
				button0 = element("button");
				div0 = element("div");
				create_component(editicon.$$.fragment);
				t0 = space();
				div1 = element("div");
				div1.textContent = "Rename";
				t2 = space();
				button1 = element("button");
				div2 = element("div");
				create_component(binicon.$$.fragment);
				t3 = space();
				div3 = element("div");
				t4 = text("Delete ");
				t5 = text(t5_value);
				attr_dev(div0, "class", "w-6 h-6 flex items-center justify-center");
				add_location(div0, file$4, 86, 4, 2369);
				attr_dev(div1, "class", "font-inter text-base whitespace-nowrap");
				add_location(div1, file$4, 89, 4, 2505);
				attr_dev(button0, "class", "flex items-center p-2 gap-2 w-full h-12 text-osvauld-fieldText hover:text-osvauld-sideListTextActive hover:bg-osvauld-modalFieldActive rounded-lg");
				add_location(button0, file$4, 80, 3, 2044);
				attr_dev(div2, "class", "w-6 h-6 flex items-center justify-center");
				add_location(div2, file$4, 98, 4, 2910);
				attr_dev(div3, "class", "font-inter text-base whitespace-nowrap");
				add_location(div3, file$4, 101, 4, 3044);
				attr_dev(button1, "class", "flex items-center p-2 gap-2 w-full h-12 text-osvauld-fieldText hover:text-osvauld-sideListTextActive hover:bg-osvauld-modalFieldActive rounded-lg");
				add_location(button1, file$4, 92, 3, 2587);
				attr_dev(div4, "class", "flex flex-col items-start p-2 gap-2 w-full h-full");
				add_location(div4, file$4, 79, 2, 1977);

				attr_dev(div5, "class", div5_class_value = "absolute z-50 bg-osvauld-frameblack border border-osvauld-iconblack " + (/*$modalManager*/ ctx[3].type === 'Folder'
				? 'w-[166px]'
				: 'w-[130px]') + " rounded-2xl");

				set_style(div5, "top", /*$buttonCoords*/ ctx[6].top + "px");
				set_style(div5, "left", /*$buttonCoords*/ ctx[6].left + "px");
				add_location(div5, file$4, 70, 1, 1679);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div5, anchor);
				append_dev(div5, div4);
				append_dev(div4, button0);
				append_dev(button0, div0);
				mount_component(editicon, div0, null);
				append_dev(button0, t0);
				append_dev(button0, div1);
				append_dev(div4, t2);
				append_dev(div4, button1);
				append_dev(button1, div2);
				mount_component(binicon, div2, null);
				append_dev(button1, t3);
				append_dev(button1, div3);
				append_dev(div3, t4);
				append_dev(div3, t5);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "mouseenter", /*mouseenter_handler*/ ctx[10], false, false, false, false),
						listen_dev(button0, "mouseleave", /*mouseleave_handler*/ ctx[11], false, false, false, false),
						listen_dev(button0, "click", prevent_default(/*renameInitiate*/ ctx[9]), false, true, false, false),
						listen_dev(button1, "mouseenter", /*mouseenter_handler_1*/ ctx[12], false, false, false, false),
						listen_dev(button1, "mouseleave", /*mouseleave_handler_1*/ ctx[13], false, false, false, false),
						listen_dev(button1, "click", prevent_default(/*deleteInitiate*/ ctx[8]), false, true, false, false),
						action_destroyer(clickOutside.call(null, div5)),
						listen_dev(div5, "clickOutside", /*handleClickOutside*/ ctx[7], false, false, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, dirty) {
				const editicon_changes = {};
				if (dirty & /*isEditHovered*/ 2) editicon_changes.color = /*isEditHovered*/ ctx[1] ? '#F2F2F0' : '#85889C';
				editicon.$set(editicon_changes);
				const binicon_changes = {};
				if (dirty & /*isBinHovered*/ 4) binicon_changes.color = /*isBinHovered*/ ctx[2] ? '#F2F2F0' : '#85889C';
				binicon.$set(binicon_changes);

				if ((!current || dirty & /*$modalManager*/ 8) && t5_value !== (t5_value = (/*$modalManager*/ ctx[3].type === "Folder"
				? "folder"
				: "") + "")) set_data_dev(t5, t5_value);

				if (!current || dirty & /*$modalManager*/ 8 && div5_class_value !== (div5_class_value = "absolute z-50 bg-osvauld-frameblack border border-osvauld-iconblack " + (/*$modalManager*/ ctx[3].type === 'Folder'
				? 'w-[166px]'
				: 'w-[130px]') + " rounded-2xl")) {
					attr_dev(div5, "class", div5_class_value);
				}

				if (!current || dirty & /*$buttonCoords*/ 64) {
					set_style(div5, "top", /*$buttonCoords*/ ctx[6].top + "px");
				}

				if (!current || dirty & /*$buttonCoords*/ 64) {
					set_style(div5, "left", /*$buttonCoords*/ ctx[6].left + "px");
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(editicon.$$.fragment, local);
				transition_in(binicon.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(editicon.$$.fragment, local);
				transition_out(binicon.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div5);
				}

				destroy_component(editicon);
				destroy_component(binicon);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$2.name,
			type: "if",
			source: "(53:0) {#if $showMoreGroupOptions && $buttonRef && $modalManager}",
			ctx
		});

		return block;
	}

	function create_fragment$4(ctx) {
		let if_block_anchor;
		let current;
		let if_block = /*$showMoreGroupOptions*/ ctx[4] && /*$buttonRef*/ ctx[5] && /*$modalManager*/ ctx[3] && create_if_block$2(ctx);

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				if (/*$showMoreGroupOptions*/ ctx[4] && /*$buttonRef*/ ctx[5] && /*$modalManager*/ ctx[3]) {
					if (if_block) {
						if_block.p(ctx, dirty);

						if (dirty & /*$showMoreGroupOptions, $buttonRef, $modalManager*/ 56) {
							transition_in(if_block, 1);
						}
					} else {
						if_block = create_if_block$2(ctx);
						if_block.c();
						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					group_outros();

					transition_out(if_block, 1, 1, () => {
						if_block = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if (if_block) if_block.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$4.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$4($$self, $$props, $$invalidate) {
		let $modalManager;
		let $showMoreGroupOptions;
		let $buttonRef;

		let $buttonCoords,
			$$unsubscribe_buttonCoords = noop,
			$$subscribe_buttonCoords = () => ($$unsubscribe_buttonCoords(), $$unsubscribe_buttonCoords = subscribe(buttonCoords, $$value => $$invalidate(6, $buttonCoords = $$value)), buttonCoords);

		validate_store(modalManager, 'modalManager');
		component_subscribe($$self, modalManager, $$value => $$invalidate(3, $modalManager = $$value));
		validate_store(showMoreGroupOptions, 'showMoreGroupOptions');
		component_subscribe($$self, showMoreGroupOptions, $$value => $$invalidate(4, $showMoreGroupOptions = $$value));
		validate_store(buttonRef, 'buttonRef');
		component_subscribe($$self, buttonRef, $$value => $$invalidate(5, $buttonRef = $$value));
		$$self.$$.on_destroy.push(() => $$unsubscribe_buttonCoords());
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('MoreActionsGroup', slots, []);
		let isEditHovered = false;
		let isBinHovered = false;

		function closeModal() {
			showMoreGroupOptions.set(false);
			modalManager.set(null);
		}

		const buttonCoords = derived(buttonRef, $buttonRef => {
			if ($buttonRef && $modalManager != null) {
				// @ts-ignore
				const rect = $buttonRef.getBoundingClientRect();

				const leftVal = $modalManager.type === "Group"
				? rect.left + window.scrollX
				: rect.left + window.scrollX - 3.5 * rect.width;

				return {
					top: rect.top + window.scrollY + rect.height,
					left: leftVal
				};
			}

			return { top: 0, left: 0 };
		});

		validate_store(buttonCoords, 'buttonCoords');
		$$subscribe_buttonCoords();

		const handleKeyDown = event => {
			if (event.key === "Escape") {
				closeModal();
			}
		};

		const handleClickOutside = () => {
			closeModal();
		};

		const deleteInitiate = () => {
			buttonRef.set(null);
			DeleteConfirmationModal.set(true);
			showMoreGroupOptions.set(false);
		};

		const renameInitiate = () => {
			buttonRef.set(null);
			showMoreGroupOptions.set(false);
			showRenameGroupDrawer.set(true);
		};

		onMount(() => {
			window.addEventListener("keydown", handleKeyDown);
		});

		onDestroy(() => {
			window.removeEventListener("keydown", handleKeyDown);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MoreActionsGroup> was created with unknown prop '${key}'`);
		});

		const mouseenter_handler = () => $$invalidate(1, isEditHovered = true);
		const mouseleave_handler = () => $$invalidate(1, isEditHovered = false);
		const mouseenter_handler_1 = () => $$invalidate(2, isBinHovered = true);
		const mouseleave_handler_1 = () => $$invalidate(2, isBinHovered = false);

		$$self.$capture_state = () => ({
			BinIcon,
			EditIcon,
			buttonRef,
			DeleteConfirmationModal,
			modalManager,
			showMoreGroupOptions,
			showRenameGroupDrawer,
			clickOutside,
			derived,
			onMount,
			onDestroy,
			isEditHovered,
			isBinHovered,
			closeModal,
			buttonCoords,
			handleKeyDown,
			handleClickOutside,
			deleteInitiate,
			renameInitiate,
			$modalManager,
			$showMoreGroupOptions,
			$buttonRef,
			$buttonCoords
		});

		$$self.$inject_state = $$props => {
			if ('isEditHovered' in $$props) $$invalidate(1, isEditHovered = $$props.isEditHovered);
			if ('isBinHovered' in $$props) $$invalidate(2, isBinHovered = $$props.isBinHovered);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			buttonCoords,
			isEditHovered,
			isBinHovered,
			$modalManager,
			$showMoreGroupOptions,
			$buttonRef,
			$buttonCoords,
			handleClickOutside,
			deleteInitiate,
			renameInitiate,
			mouseenter_handler,
			mouseleave_handler,
			mouseenter_handler_1,
			mouseleave_handler_1
		];
	}

	class MoreActionsGroup extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$4, create_fragment$4, safe_not_equal, { buttonCoords: 0 });

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "MoreActionsGroup",
				options,
				id: create_fragment$4.name
			});
		}

		get buttonCoords() {
			return this.$$.ctx[0];
		}

		set buttonCoords(value) {
			throw new Error("<MoreActionsGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
		}
	}

	/* src/lib/components/dashboard/groups/GroupDeleteModal.svelte generated by Svelte v4.2.19 */
	const file$3 = "src/lib/components/dashboard/groups/GroupDeleteModal.svelte";

	function create_fragment$3(ctx) {
		let button3;
		let div7;
		let div0;
		let span0;
		let t0;
		let t1_value = /*$modalManager*/ ctx[2].name + "";
		let t1;
		let t2;
		let t3;
		let button0;
		let closepanel;
		let t4;
		let div1;
		let t5;
		let div4;
		let div2;
		let warning;
		let t6;
		let div3;
		let t7;
		let br;
		let t8;
		let span1;
		let t10;
		let t11;
		let div5;
		let t12;
		let div6;
		let button1;
		let t13;
		let button1_class_value;
		let t14;
		let button2;
		let t15;
		let button2_class_value;
		let div7_intro;
		let current;
		let mounted;
		let dispose;
		closepanel = new ClosePanel({ $$inline: true });
		warning = new Warning({ $$inline: true });

		const block = {
			c: function create() {
				button3 = element("button");
				div7 = element("div");
				div0 = element("div");
				span0 = element("span");
				t0 = text("Delete ");
				t1 = text(t1_value);
				t2 = text(" group");
				t3 = space();
				button0 = element("button");
				create_component(closepanel.$$.fragment);
				t4 = space();
				div1 = element("div");
				t5 = space();
				div4 = element("div");
				div2 = element("div");
				create_component(warning.$$.fragment);
				t6 = space();
				div3 = element("div");
				t7 = text("Are you sure? ");
				br = element("br");
				t8 = text(" All\n\t\t\t\t");
				span1 = element("span");
				span1.textContent = "credentials";
				t10 = text(" shared\n\t\t\t\twith this group will be Revoked.");
				t11 = space();
				div5 = element("div");
				t12 = space();
				div6 = element("div");
				button1 = element("button");
				t13 = text("Cancel");
				t14 = space();
				button2 = element("button");
				t15 = text("Delete Group");
				attr_dev(span0, "class", "text-[21px] font-medium text-osvauld-quarzowhite");
				add_location(span0, file$3, 44, 3, 1312);
				attr_dev(button0, "class", "cursor-pointer p-2");
				add_location(button0, file$3, 47, 3, 1428);
				attr_dev(div0, "class", "flex justify-between items-center w-full");
				add_location(div0, file$3, 43, 2, 1254);
				attr_dev(div1, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div1, file$3, 54, 2, 1572);
				attr_dev(div2, "class", "w-16 h-9 justify-center items-center flex");
				add_location(div2, file$3, 60, 3, 1808);
				add_location(br, file$3, 64, 18, 1959);
				attr_dev(span1, "class", "font-semibold text-osvauld-quarzowhite");
				add_location(span1, file$3, 65, 4, 1974);
				attr_dev(div3, "class", "text-osvauld-textActive text-left");
				add_location(div3, file$3, 63, 3, 1893);
				attr_dev(div4, "class", "h-[100px] w-full font-normal text-base flex justify-center items-start bg-osvauld-fieldActive rounded-lg gap-3 p-2");
				add_location(div4, file$3, 57, 2, 1669);
				attr_dev(div5, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div5, file$3, 69, 2, 2111);

				attr_dev(button1, "class", button1_class_value = "font-medium text-base rounded-md py-[5px] px-[15px] " + (/*cancelHovered*/ ctx[0]
				? 'bg-osvauld-cancelBackground text-osvauld-quarzowhite'
				: 'text-osvauld-fadedCancel'));

				add_location(button1, file$3, 73, 3, 2268);

				attr_dev(button2, "class", button2_class_value = "border border-osvauld-dangerRed py-[5px] px-[15px] text-base font-medium text-osvauld-dangerRed rounded-md " + (/*finalActionHovered*/ ctx[1]
				? 'bg-osvauld-dangerRed text-osvauld-frameblack'
				: 'text-osvauld-dangerRed'));

				add_location(button2, file$3, 81, 3, 2635);
				attr_dev(div6, "class", "flex justify-end items-center gap-4 w-full");
				add_location(div6, file$3, 72, 2, 2208);
				attr_dev(div7, "class", "p-4 bg-osvauld-frameblack border border-osvauld-activeBorder rounded-3xl w-[32rem] h-[17.6rem] flex flex-col items-start justify-center gap-3");
				add_location(div7, file$3, 39, 1, 1083);
				attr_dev(button3, "class", "fixed inset-0 flex items-center justify-center z-50 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px]");
				add_location(button3, file$3, 35, 0, 895);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, button3, anchor);
				append_dev(button3, div7);
				append_dev(div7, div0);
				append_dev(div0, span0);
				append_dev(span0, t0);
				append_dev(span0, t1);
				append_dev(span0, t2);
				append_dev(div0, t3);
				append_dev(div0, button0);
				mount_component(closepanel, button0, null);
				append_dev(div7, t4);
				append_dev(div7, div1);
				append_dev(div7, t5);
				append_dev(div7, div4);
				append_dev(div4, div2);
				mount_component(warning, div2, null);
				append_dev(div4, t6);
				append_dev(div4, div3);
				append_dev(div3, t7);
				append_dev(div3, br);
				append_dev(div3, t8);
				append_dev(div3, span1);
				append_dev(div3, t10);
				append_dev(div7, t11);
				append_dev(div7, div5);
				append_dev(div7, t12);
				append_dev(div7, div6);
				append_dev(div6, button1);
				append_dev(button1, t13);
				append_dev(div6, t14);
				append_dev(div6, button2);
				append_dev(button2, t15);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", prevent_default(/*withdrawGroupDeleteModal*/ ctx[3]), false, true, false, false),
						listen_dev(button1, "click", prevent_default(/*withdrawGroupDeleteModal*/ ctx[3]), false, true, false, false),
						listen_dev(button1, "mouseenter", /*mouseenter_handler*/ ctx[5], false, false, false, false),
						listen_dev(button1, "mouseleave", /*mouseleave_handler*/ ctx[6], false, false, false, false),
						listen_dev(button2, "click", prevent_default(/*DeleteConfirmation*/ ctx[4]), false, true, false, false),
						listen_dev(button2, "mouseenter", /*mouseenter_handler_1*/ ctx[7], false, false, false, false),
						listen_dev(button2, "mouseleave", /*mouseleave_handler_1*/ ctx[8], false, false, false, false),
						listen_dev(button3, "click", prevent_default(/*withdrawGroupDeleteModal*/ ctx[3]), false, true, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				if ((!current || dirty & /*$modalManager*/ 4) && t1_value !== (t1_value = /*$modalManager*/ ctx[2].name + "")) set_data_dev(t1, t1_value);

				if (!current || dirty & /*cancelHovered*/ 1 && button1_class_value !== (button1_class_value = "font-medium text-base rounded-md py-[5px] px-[15px] " + (/*cancelHovered*/ ctx[0]
				? 'bg-osvauld-cancelBackground text-osvauld-quarzowhite'
				: 'text-osvauld-fadedCancel'))) {
					attr_dev(button1, "class", button1_class_value);
				}

				if (!current || dirty & /*finalActionHovered*/ 2 && button2_class_value !== (button2_class_value = "border border-osvauld-dangerRed py-[5px] px-[15px] text-base font-medium text-osvauld-dangerRed rounded-md " + (/*finalActionHovered*/ ctx[1]
				? 'bg-osvauld-dangerRed text-osvauld-frameblack'
				: 'text-osvauld-dangerRed'))) {
					attr_dev(button2, "class", button2_class_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closepanel.$$.fragment, local);
				transition_in(warning.$$.fragment, local);

				if (local) {
					if (!div7_intro) {
						add_render_callback(() => {
							div7_intro = create_in_transition(div7, fly, {});
							div7_intro.start();
						});
					}
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(closepanel.$$.fragment, local);
				transition_out(warning.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(button3);
				}

				destroy_component(closepanel);
				destroy_component(warning);
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$3.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$3($$self, $$props, $$invalidate) {
		let $modalManager;
		let $selectedGroup;
		validate_store(modalManager, 'modalManager');
		component_subscribe($$self, modalManager, $$value => $$invalidate(2, $modalManager = $$value));
		validate_store(selectedGroup, 'selectedGroup');
		component_subscribe($$self, selectedGroup, $$value => $$invalidate(9, $selectedGroup = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('GroupDeleteModal', slots, []);
		let cancelHovered = false;
		let finalActionHovered = false;

		function withdrawGroupDeleteModal() {
			showMoreGroupOptions.set(false);
			DeleteConfirmationModal.set(false);
			modalManager.set(null);
		}

		const DeleteConfirmation = async () => {
			if ($selectedGroup && $selectedGroup.groupId === $modalManager.id) {
				selectedGroup.set(null);
			}

			await removeGroup($modalManager.id);
			await setGroupStore();
			DeleteConfirmationModal.set(false);
			showMoreGroupOptions.set(false);
			modalManager.set(null);
		};

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GroupDeleteModal> was created with unknown prop '${key}'`);
		});

		const mouseenter_handler = () => $$invalidate(0, cancelHovered = true);
		const mouseleave_handler = () => $$invalidate(0, cancelHovered = false);
		const mouseenter_handler_1 = () => $$invalidate(1, finalActionHovered = true);
		const mouseleave_handler_1 = () => $$invalidate(1, finalActionHovered = false);

		$$self.$capture_state = () => ({
			ClosePanel,
			modalManager,
			DeleteConfirmationModal,
			showMoreGroupOptions,
			selectedGroup,
			fly,
			Warning,
			removeGroup,
			setGroupStore,
			cancelHovered,
			finalActionHovered,
			withdrawGroupDeleteModal,
			DeleteConfirmation,
			$modalManager,
			$selectedGroup
		});

		$$self.$inject_state = $$props => {
			if ('cancelHovered' in $$props) $$invalidate(0, cancelHovered = $$props.cancelHovered);
			if ('finalActionHovered' in $$props) $$invalidate(1, finalActionHovered = $$props.finalActionHovered);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			cancelHovered,
			finalActionHovered,
			$modalManager,
			withdrawGroupDeleteModal,
			DeleteConfirmation,
			mouseenter_handler,
			mouseleave_handler,
			mouseenter_handler_1,
			mouseleave_handler_1
		];
	}

	class GroupDeleteModal extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "GroupDeleteModal",
				options,
				id: create_fragment$3.name
			});
		}
	}

	/* src/lib/components/dashboard/components/ShareToast.svelte generated by Svelte v4.2.19 */
	const file$2 = "src/lib/components/dashboard/components/ShareToast.svelte";

	function create_fragment$2(ctx) {
		let div1;
		let div0;
		let span;
		let t0_value = /*$toastStore*/ ctx[0].message + "";
		let t0;
		let t1;
		let div0_class_value;

		const block = {
			c: function create() {
				div1 = element("div");
				div0 = element("div");
				span = element("span");
				t0 = text(t0_value);
				t1 = text("!");
				attr_dev(span, "class", "text-base font-sans whitespace-nowrap");
				add_location(span, file$2, 22, 2, 780);

				attr_dev(div0, "class", div0_class_value = "flex justify-center items-center rounded-xl border " + (/*$toastStore*/ ctx[0].type
				? 'border-osvauld-iconblack text-osvauld-chalkwhite '
				: 'border-osvauld-dangerRed text-osvauld-dangerRed') + " font-normal text-xl px-5 py-4 my-2 bg-osvauld-cardshade");

				add_location(div0, file$2, 17, 1, 522);
				attr_dev(div1, "class", "fixed w-[20%] max-w-[30%] h-[12%] top-auto left-[40%] right-auto bottom-6 flex items-center justify-center px-6 py-5 my-2 rounded-lg bg-transparent font-normal text-xl !z-[1000] mr-4 mb-4");
				add_location(div1, file$2, 14, 0, 317);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, div0);
				append_dev(div0, span);
				append_dev(span, t0);
				append_dev(span, t1);
			},
			p: function update(ctx, [dirty]) {
				if (dirty & /*$toastStore*/ 1 && t0_value !== (t0_value = /*$toastStore*/ ctx[0].message + "")) set_data_dev(t0, t0_value);

				if (dirty & /*$toastStore*/ 1 && div0_class_value !== (div0_class_value = "flex justify-center items-center rounded-xl border " + (/*$toastStore*/ ctx[0].type
				? 'border-osvauld-iconblack text-osvauld-chalkwhite '
				: 'border-osvauld-dangerRed text-osvauld-dangerRed') + " font-normal text-xl px-5 py-4 my-2 bg-osvauld-cardshade")) {
					attr_dev(div0, "class", div0_class_value);
				}
			},
			i: noop,
			o: noop,
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$2.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$2($$self, $$props, $$invalidate) {
		let $toastStore;
		validate_store(toastStore, 'toastStore');
		component_subscribe($$self, toastStore, $$value => $$invalidate(0, $toastStore = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('ShareToast', slots, []);

		const triggerCloseEvent = () => {
			toastStore.set({ show: false, message: "", type: false });
		};

		onMount(() => {
			setTimeout(
				() => {
					triggerCloseEvent();
				},
				2000
			);
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ShareToast> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({
			onMount,
			toastStore,
			triggerCloseEvent,
			$toastStore
		});

		return [$toastStore];
	}

	class ShareToast extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "ShareToast",
				options,
				id: create_fragment$2.name
			});
		}
	}

	/* src/lib/components/dashboard/components/PasswordPromptModal.svelte generated by Svelte v4.2.19 */
	const file$1 = "src/lib/components/dashboard/components/PasswordPromptModal.svelte";

	// (93:2) {:else}
	function create_else_block$1(ctx) {
		let form;
		let div0;
		let span;
		let t1;
		let button0;
		let closepanel;
		let t2;
		let div1;
		let t3;
		let div3;
		let div2;
		let input;
		let input_type_value;
		let t4;
		let button1;
		let current_block_type_index;
		let if_block;
		let t5;
		let button2;
		let t6;
		let button2_disabled_value;
		let current;
		let mounted;
		let dispose;
		closepanel = new ClosePanel({ $$inline: true });
		const if_block_creators = [create_if_block_3$1, create_else_block_1];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*showPassword*/ ctx[4]) return 0;
			return 1;
		}

		current_block_type_index = select_block_type_1(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				form = element("form");
				div0 = element("div");
				span = element("span");
				span.textContent = "Confirm Passphrase";
				t1 = space();
				button0 = element("button");
				create_component(closepanel.$$.fragment);
				t2 = space();
				div1 = element("div");
				t3 = space();
				div3 = element("div");
				div2 = element("div");
				input = element("input");
				t4 = space();
				button1 = element("button");
				if_block.c();
				t5 = space();
				button2 = element("button");
				t6 = text("Proceed");
				attr_dev(span, "id", "export-recovery-data");
				attr_dev(span, "class", "text-[21px] font-medium text-osvauld-quarzowhite");
				add_location(span, file$1, 110, 5, 2917);
				attr_dev(button0, "class", "cursor-pointer p-2");
				attr_dev(button0, "type", "button");
				attr_dev(button0, "aria-label", "Close");
				add_location(button0, file$1, 116, 5, 3068);
				attr_dev(div0, "class", "flex justify-between items-center w-full");
				add_location(div0, file$1, 109, 4, 2857);
				attr_dev(div1, "class", "border-b border-osvauld-iconblack w-[calc(100%+2rem)] -translate-x-4");
				add_location(div1, file$1, 125, 4, 3257);
				attr_dev(input, "class", "text-white bg-osvauld-frameblack border-0 tracking-wider font-normal border-transparent focus:border-osvauld-iconblack focus:ring-0 active:outline-none focus:ring-offset-0");
				attr_dev(input, "type", input_type_value = /*showPassword*/ ctx[4] ? 'text' : 'password');
				attr_dev(input, "id", "passphrase");
				attr_dev(input, "aria-label", "passphrase");
				add_location(input, file$1, 132, 6, 3563);
				attr_dev(button1, "type", "button");
				attr_dev(button1, "class", "flex justify-center items-center");
				add_location(button1, file$1, 141, 6, 3937);
				attr_dev(div2, "class", "flex justify-between items-center bg-osvauld-frameblack px-3 border rounded-lg border-osvauld-iconblack w-[300px]");
				add_location(div2, file$1, 129, 5, 3417);
				attr_dev(div3, "class", "grow flex justify-center items-center");
				add_location(div3, file$1, 128, 4, 3360);
				attr_dev(button2, "class", "border w-[10rem] py-3 px-6 my-4 mx-auto text-base font-medium rounded-md bg-osvauld-carolinablue border-osvauld-carolinablue text-osvauld-frameblack cursor-pointer");
				attr_dev(button2, "type", "submit");
				button2.disabled = button2_disabled_value = !/*password*/ ctx[0];
				add_location(button2, file$1, 154, 4, 4214);
				attr_dev(form, "class", "flex flex-col h-full w-full");
				add_location(form, file$1, 103, 3, 2691);
			},
			m: function mount(target, anchor) {
				insert_dev(target, form, anchor);
				append_dev(form, div0);
				append_dev(div0, span);
				append_dev(div0, t1);
				append_dev(div0, button0);
				mount_component(closepanel, button0, null);
				append_dev(form, t2);
				append_dev(form, div1);
				append_dev(form, t3);
				append_dev(form, div3);
				append_dev(div3, div2);
				append_dev(div2, input);
				append_dev(div2, t4);
				append_dev(div2, button1);
				if_blocks[current_block_type_index].m(button1, null);
				append_dev(form, t5);
				append_dev(form, button2);
				append_dev(button2, t6);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(button0, "click", prevent_default(/*closeModal*/ ctx[6]), false, true, false, false),
						action_destroyer(/*autofocus*/ ctx[7].call(null, input)),
						listen_dev(input, "input", /*handleInputChange*/ ctx[11], false, false, false, false),
						listen_dev(button1, "click", /*click_handler_1*/ ctx[13], false, false, false, false),
						listen_dev(
							form,
							"submit",
							prevent_default(function () {
								if (is_function(/*$changePassword*/ ctx[5]
								? /*newPasswordViewHandler*/ ctx[8]
								: /*handleRecoveryDataSubmit*/ ctx[10])) (/*$changePassword*/ ctx[5]
								? /*newPasswordViewHandler*/ ctx[8]
								: /*handleRecoveryDataSubmit*/ ctx[10]).apply(this, arguments);
							}),
							false,
							true,
							false,
							false
						)
					];

					mounted = true;
				}
			},
			p: function update(new_ctx, dirty) {
				ctx = new_ctx;

				if (!current || dirty & /*showPassword*/ 16 && input_type_value !== (input_type_value = /*showPassword*/ ctx[4] ? 'text' : 'password')) {
					attr_dev(input, "type", input_type_value);
				}

				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index !== previous_block_index) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					}

					transition_in(if_block, 1);
					if_block.m(button1, null);
				}

				if (!current || dirty & /*password*/ 1 && button2_disabled_value !== (button2_disabled_value = !/*password*/ ctx[0])) {
					prop_dev(button2, "disabled", button2_disabled_value);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closepanel.$$.fragment, local);
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(closepanel.$$.fragment, local);
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(form);
				}

				destroy_component(closepanel);
				if_blocks[current_block_type_index].d();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block$1.name,
			type: "else",
			source: "(93:2) {:else}",
			ctx
		});

		return block;
	}

	// (91:28) 
	function create_if_block_2$1(ctx) {
		let newpassword;
		let current;
		newpassword = new NewPassword({ $$inline: true });
		newpassword.$on("submit", /*handlePasswordChangeSubmit*/ ctx[9]);

		const block = {
			c: function create() {
				create_component(newpassword.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(newpassword, target, anchor);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(newpassword.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(newpassword.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(newpassword, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2$1.name,
			type: "if",
			source: "(91:28) ",
			ctx
		});

		return block;
	}

	// (89:20) 
	function create_if_block_1$1(ctx) {
		let successview;
		let current;

		successview = new SuccessView({
				props: { status: true, recovery: true },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(successview.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(successview, target, anchor);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(successview.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(successview.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(successview, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1$1.name,
			type: "if",
			source: "(89:20) ",
			ctx
		});

		return block;
	}

	// (87:2) {#if errorView}
	function create_if_block$1(ctx) {
		let successview;
		let current;

		successview = new SuccessView({
				props: { status: false, recovery: true },
				$$inline: true
			});

		const block = {
			c: function create() {
				create_component(successview.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(successview, target, anchor);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(successview.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(successview.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(successview, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block$1.name,
			type: "if",
			source: "(87:2) {#if errorView}",
			ctx
		});

		return block;
	}

	// (139:7) {:else}
	function create_else_block_1(ctx) {
		let eye;
		let current;
		eye = new Eye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(eye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(eye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(eye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(eye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(eye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block_1.name,
			type: "else",
			source: "(139:7) {:else}",
			ctx
		});

		return block;
	}

	// (137:7) {#if showPassword}
	function create_if_block_3$1(ctx) {
		let closedeye;
		let current;
		closedeye = new ClosedEye({ $$inline: true });

		const block = {
			c: function create() {
				create_component(closedeye.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(closedeye, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(closedeye.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(closedeye.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(closedeye, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3$1.name,
			type: "if",
			source: "(137:7) {#if showPassword}",
			ctx
		});

		return block;
	}

	function create_fragment$1(ctx) {
		let div1;
		let div0;
		let current_block_type_index;
		let if_block;
		let div0_intro;
		let div0_outro;
		let current;
		let mounted;
		let dispose;
		const if_block_creators = [create_if_block$1, create_if_block_1$1, create_if_block_2$1, create_else_block$1];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (/*errorView*/ ctx[2]) return 0;
			if (/*success*/ ctx[1]) return 1;
			if (/*newPasswordView*/ ctx[3]) return 2;
			return 3;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				div1 = element("div");
				div0 = element("div");
				if_block.c();
				attr_dev(div0, "class", "p-4 bg-osvauld-frameblack border border-osvauld-activeBorder rounded-3xl w-[28rem] h-[24rem] flex flex-col justify-center items-center");
				attr_dev(div0, "role", "presentation");
				attr_dev(div0, "aria-labelledby", "export-recovery-data");
				add_location(div0, file$1, 88, 1, 2181);
				attr_dev(div1, "class", "fixed inset-0 flex items-center justify-center z-50 bg-osvauld-backgroundBlur backdrop-filter backdrop-blur-[2px]");
				attr_dev(div1, "role", "presentation");
				add_location(div1, file$1, 83, 0, 1989);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, div1, anchor);
				append_dev(div1, div0);
				if_blocks[current_block_type_index].m(div0, null);
				current = true;

				if (!mounted) {
					dispose = [
						listen_dev(div0, "click", stop_propagation(/*click_handler*/ ctx[12]), false, false, true, false),
						listen_dev(div1, "click", prevent_default(/*closeModal*/ ctx[6]), false, true, false, false)
					];

					mounted = true;
				}
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(div0, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);

				if (local) {
					add_render_callback(() => {
						if (!current) return;
						if (div0_outro) div0_outro.end(1);
						div0_intro = create_in_transition(div0, fly, {});
						div0_intro.start();
					});
				}

				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				if (div0_intro) div0_intro.invalidate();

				if (local) {
					div0_outro = create_out_transition(div0, fly, {});
				}

				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div1);
				}

				if_blocks[current_block_type_index].d();
				if (detaching && div0_outro) div0_outro.end();
				mounted = false;
				run_all(dispose);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment$1.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance$1($$self, $$props, $$invalidate) {
		let $changePassword;
		validate_store(changePassword, 'changePassword');
		component_subscribe($$self, changePassword, $$value => $$invalidate(5, $changePassword = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('PasswordPromptModal', slots, []);
		let password = "";
		let success = false;
		let errorView = false;
		let newPasswordView = false;
		let showPassword = false;

		const closeModal = () => {
			promptPassword.set(false);
		};

		const autofocus = node => {
			node.focus();
		};

		const newPasswordViewHandler = async () => {
			$$invalidate(3, newPasswordView = true);
		};

		const handlePasswordChangeSubmit = async e => {
			const passphrase = e.detail.passphrase;
			const certificate = await sendMessage("changePassphrase", { password, passphrase });
			$$invalidate(3, newPasswordView = false);

			if (certificate) {
				$$invalidate(1, success = true);
			} else {
				$$invalidate(2, errorView = true);
			}

			setTimeout(
				() => {
					closeModal();
				},
				1500
			);
		};

		const handleRecoveryDataSubmit = async () => {
			const { baseUrl } = await getTokenAndBaseUrl();
			const certificate = await sendMessage("exportCertificate", { passphrase: password });

			if (certificate) {
				const exporter = JSON.stringify({ certificate, baseUrl });
				await navigator.clipboard.writeText(exporter);
				$$invalidate(1, success = true);
			} else {
				$$invalidate(2, errorView = true);
			}

			setTimeout(
				() => {
					changePassword.set(false);
					closeModal();
				},
				1500
			);
		};

		const handleInputChange = e => {
			$$invalidate(0, password = e.target.value);
		};

		onMount(() => {
			const handleKeydown = event => {
				if (event.key === "Escape") {
					closeModal();
				}
			};

			window.addEventListener("keydown", handleKeydown);

			return () => {
				window.removeEventListener("keydown", handleKeydown);
			};
		});

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PasswordPromptModal> was created with unknown prop '${key}'`);
		});

		function click_handler(event) {
			bubble.call(this, $$self, event);
		}

		const click_handler_1 = () => $$invalidate(4, showPassword = !showPassword);

		$$self.$capture_state = () => ({
			onMount,
			sendMessage,
			getTokenAndBaseUrl,
			fly,
			promptPassword,
			changePassword,
			ClosedEye,
			ClosePanel,
			Eye,
			SuccessView,
			NewPassword,
			password,
			success,
			errorView,
			newPasswordView,
			showPassword,
			closeModal,
			autofocus,
			newPasswordViewHandler,
			handlePasswordChangeSubmit,
			handleRecoveryDataSubmit,
			handleInputChange,
			$changePassword
		});

		$$self.$inject_state = $$props => {
			if ('password' in $$props) $$invalidate(0, password = $$props.password);
			if ('success' in $$props) $$invalidate(1, success = $$props.success);
			if ('errorView' in $$props) $$invalidate(2, errorView = $$props.errorView);
			if ('newPasswordView' in $$props) $$invalidate(3, newPasswordView = $$props.newPasswordView);
			if ('showPassword' in $$props) $$invalidate(4, showPassword = $$props.showPassword);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			password,
			success,
			errorView,
			newPasswordView,
			showPassword,
			$changePassword,
			closeModal,
			autofocus,
			newPasswordViewHandler,
			handlePasswordChangeSubmit,
			handleRecoveryDataSubmit,
			handleInputChange,
			click_handler,
			click_handler_1
		];
	}

	class PasswordPromptModal extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "PasswordPromptModal",
				options,
				id: create_fragment$1.name
			});
		}
	}

	/* src/lib/Dashboard.svelte generated by Svelte v4.2.19 */
	const file = "src/lib/Dashboard.svelte";

	// (55:1) {:else}
	function create_else_block(ctx) {
		let div2;
		let div0;
		let leftcontainer;
		let t0;
		let div1;
		let rightcontainer;
		let t1;
		let t2;
		let t3;
		let t4;
		let t5;
		let t6;
		let if_block5_anchor;
		let current;
		leftcontainer = new LeftContainer({ $$inline: true });
		rightcontainer = new RightContainer({ $$inline: true });
		let if_block0 = /*$showMoreOptions*/ ctx[2] && create_if_block_10(ctx);
		let if_block1 = /*$promptPassword*/ ctx[3] && create_if_block_9(ctx);
		let if_block2 = /*$modalManager*/ ctx[4] && create_if_block_5(ctx);
		let if_block3 = /*$accessListSelected*/ ctx[6] && /*$selectedFolder*/ ctx[7] && create_if_block_4(ctx);
		let if_block4 = /*$showMoreGroupOptions*/ ctx[8] && create_if_block_3(ctx);
		let if_block5 = /*$toastStore*/ ctx[9].show && create_if_block_2(ctx);

		const block = {
			c: function create() {
				div2 = element("div");
				div0 = element("div");
				create_component(leftcontainer.$$.fragment);
				t0 = space();
				div1 = element("div");
				create_component(rightcontainer.$$.fragment);
				t1 = space();
				if (if_block0) if_block0.c();
				t2 = space();
				if (if_block1) if_block1.c();
				t3 = space();
				if (if_block2) if_block2.c();
				t4 = space();
				if (if_block3) if_block3.c();
				t5 = space();
				if (if_block4) if_block4.c();
				t6 = space();
				if (if_block5) if_block5.c();
				if_block5_anchor = empty();
				attr_dev(div0, "class", "w-1/5 h-full scrollbar-thin overflow-y-hidden overflow-x-hidden relative z-10");
				add_location(div0, file, 66, 3, 2466);
				attr_dev(div1, "class", "w-4/5 h-full overflow-hidden border-l border-osvauld-iconblack");
				add_location(div1, file, 71, 3, 2625);
				attr_dev(div2, "class", "flex h-full");
				add_location(div2, file, 65, 2, 2437);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div2, anchor);
				append_dev(div2, div0);
				mount_component(leftcontainer, div0, null);
				append_dev(div2, t0);
				append_dev(div2, div1);
				mount_component(rightcontainer, div1, null);
				insert_dev(target, t1, anchor);
				if (if_block0) if_block0.m(target, anchor);
				insert_dev(target, t2, anchor);
				if (if_block1) if_block1.m(target, anchor);
				insert_dev(target, t3, anchor);
				if (if_block2) if_block2.m(target, anchor);
				insert_dev(target, t4, anchor);
				if (if_block3) if_block3.m(target, anchor);
				insert_dev(target, t5, anchor);
				if (if_block4) if_block4.m(target, anchor);
				insert_dev(target, t6, anchor);
				if (if_block5) if_block5.m(target, anchor);
				insert_dev(target, if_block5_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				if (/*$showMoreOptions*/ ctx[2]) {
					if (if_block0) {
						if (dirty & /*$showMoreOptions*/ 4) {
							transition_in(if_block0, 1);
						}
					} else {
						if_block0 = create_if_block_10(ctx);
						if_block0.c();
						transition_in(if_block0, 1);
						if_block0.m(t2.parentNode, t2);
					}
				} else if (if_block0) {
					group_outros();

					transition_out(if_block0, 1, 1, () => {
						if_block0 = null;
					});

					check_outros();
				}

				if (/*$promptPassword*/ ctx[3]) {
					if (if_block1) {
						if (dirty & /*$promptPassword*/ 8) {
							transition_in(if_block1, 1);
						}
					} else {
						if_block1 = create_if_block_9(ctx);
						if_block1.c();
						transition_in(if_block1, 1);
						if_block1.m(t3.parentNode, t3);
					}
				} else if (if_block1) {
					group_outros();

					transition_out(if_block1, 1, 1, () => {
						if_block1 = null;
					});

					check_outros();
				}

				if (/*$modalManager*/ ctx[4]) {
					if (if_block2) {
						if_block2.p(ctx, dirty);

						if (dirty & /*$modalManager*/ 16) {
							transition_in(if_block2, 1);
						}
					} else {
						if_block2 = create_if_block_5(ctx);
						if_block2.c();
						transition_in(if_block2, 1);
						if_block2.m(t4.parentNode, t4);
					}
				} else if (if_block2) {
					group_outros();

					transition_out(if_block2, 1, 1, () => {
						if_block2 = null;
					});

					check_outros();
				}

				if (/*$accessListSelected*/ ctx[6] && /*$selectedFolder*/ ctx[7]) {
					if (if_block3) {
						if (dirty & /*$accessListSelected, $selectedFolder*/ 192) {
							transition_in(if_block3, 1);
						}
					} else {
						if_block3 = create_if_block_4(ctx);
						if_block3.c();
						transition_in(if_block3, 1);
						if_block3.m(t5.parentNode, t5);
					}
				} else if (if_block3) {
					group_outros();

					transition_out(if_block3, 1, 1, () => {
						if_block3 = null;
					});

					check_outros();
				}

				if (/*$showMoreGroupOptions*/ ctx[8]) {
					if (if_block4) {
						if (dirty & /*$showMoreGroupOptions*/ 256) {
							transition_in(if_block4, 1);
						}
					} else {
						if_block4 = create_if_block_3(ctx);
						if_block4.c();
						transition_in(if_block4, 1);
						if_block4.m(t6.parentNode, t6);
					}
				} else if (if_block4) {
					group_outros();

					transition_out(if_block4, 1, 1, () => {
						if_block4 = null;
					});

					check_outros();
				}

				if (/*$toastStore*/ ctx[9].show) {
					if (if_block5) {
						if (dirty & /*$toastStore*/ 512) {
							transition_in(if_block5, 1);
						}
					} else {
						if_block5 = create_if_block_2(ctx);
						if_block5.c();
						transition_in(if_block5, 1);
						if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
					}
				} else if (if_block5) {
					group_outros();

					transition_out(if_block5, 1, 1, () => {
						if_block5 = null;
					});

					check_outros();
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(leftcontainer.$$.fragment, local);
				transition_in(rightcontainer.$$.fragment, local);
				transition_in(if_block0);
				transition_in(if_block1);
				transition_in(if_block2);
				transition_in(if_block3);
				transition_in(if_block4);
				transition_in(if_block5);
				current = true;
			},
			o: function outro(local) {
				transition_out(leftcontainer.$$.fragment, local);
				transition_out(rightcontainer.$$.fragment, local);
				transition_out(if_block0);
				transition_out(if_block1);
				transition_out(if_block2);
				transition_out(if_block3);
				transition_out(if_block4);
				transition_out(if_block5);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div2);
					detach_dev(t1);
					detach_dev(t2);
					detach_dev(t3);
					detach_dev(t4);
					detach_dev(t5);
					detach_dev(t6);
					detach_dev(if_block5_anchor);
				}

				destroy_component(leftcontainer);
				destroy_component(rightcontainer);
				if (if_block0) if_block0.d(detaching);
				if (if_block1) if_block1.d(detaching);
				if (if_block2) if_block2.d(detaching);
				if (if_block3) if_block3.d(detaching);
				if (if_block4) if_block4.d(detaching);
				if (if_block5) if_block5.d(detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_else_block.name,
			type: "else",
			source: "(55:1) {:else}",
			ctx
		});

		return block;
	}

	// (51:23) 
	function create_if_block_1(ctx) {
		let div;
		let welcome;
		let current;
		welcome = new Welcome({ $$inline: true });
		welcome.$on("authenticated", /*handleAuthenticated*/ ctx[11]);

		const block = {
			c: function create() {
				div = element("div");
				create_component(welcome.$$.fragment);
				attr_dev(div, "class", "overflow-hidden flex justify-center items-center w-full h-full");
				add_location(div, file, 61, 2, 2284);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				mount_component(welcome, div, null);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(welcome.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(welcome.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(welcome);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_1.name,
			type: "if",
			source: "(51:23) ",
			ctx
		});

		return block;
	}

	// (49:1) {#if !signedUp}
	function create_if_block(ctx) {
		let signup;
		let current;
		signup = new Signup({ $$inline: true });
		signup.$on("signedUp", /*handleSignedUp*/ ctx[10]);

		const block = {
			c: function create() {
				create_component(signup.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(signup, target, anchor);
				current = true;
			},
			p: noop,
			i: function intro(local) {
				if (current) return;
				transition_in(signup.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(signup.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(signup, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block.name,
			type: "if",
			source: "(49:1) {#if !signedUp}",
			ctx
		});

		return block;
	}

	// (68:2) {#if $showMoreOptions}
	function create_if_block_10(ctx) {
		let moreactions;
		let current;
		moreactions = new MoreActions({ $$inline: true });

		const block = {
			c: function create() {
				create_component(moreactions.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(moreactions, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(moreactions.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(moreactions.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(moreactions, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_10.name,
			type: "if",
			source: "(68:2) {#if $showMoreOptions}",
			ctx
		});

		return block;
	}

	// (71:2) {#if $promptPassword}
	function create_if_block_9(ctx) {
		let passwordpromptmodal;
		let current;
		passwordpromptmodal = new PasswordPromptModal({ $$inline: true });

		const block = {
			c: function create() {
				create_component(passwordpromptmodal.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(passwordpromptmodal, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(passwordpromptmodal.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(passwordpromptmodal.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(passwordpromptmodal, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_9.name,
			type: "if",
			source: "(71:2) {#if $promptPassword}",
			ctx
		});

		return block;
	}

	// (74:2) {#if $modalManager}
	function create_if_block_5(ctx) {
		let current_block_type_index;
		let if_block;
		let if_block_anchor;
		let current;
		const if_block_creators = [create_if_block_6, create_if_block_7, create_if_block_8];
		const if_blocks = [];

		function select_block_type_1(ctx, dirty) {
			if (/*$DeleteConfirmationModal*/ ctx[5] && /*$modalManager*/ ctx[4].type === "Credential") return 0;
			if (/*$DeleteConfirmationModal*/ ctx[5] && /*$modalManager*/ ctx[4].type === "Folder") return 1;
			if (/*$DeleteConfirmationModal*/ ctx[5] && /*$modalManager*/ ctx[4].type === "Group") return 2;
			return -1;
		}

		if (~(current_block_type_index = select_block_type_1(ctx))) {
			if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
		}

		const block = {
			c: function create() {
				if (if_block) if_block.c();
				if_block_anchor = empty();
			},
			m: function mount(target, anchor) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].m(target, anchor);
				}

				insert_dev(target, if_block_anchor, anchor);
				current = true;
			},
			p: function update(ctx, dirty) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type_1(ctx);

				if (current_block_type_index !== previous_block_index) {
					if (if_block) {
						group_outros();

						transition_out(if_blocks[previous_block_index], 1, 1, () => {
							if_blocks[previous_block_index] = null;
						});

						check_outros();
					}

					if (~current_block_type_index) {
						if_block = if_blocks[current_block_type_index];

						if (!if_block) {
							if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
							if_block.c();
						}

						transition_in(if_block, 1);
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					} else {
						if_block = null;
					}
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(if_block_anchor);
				}

				if (~current_block_type_index) {
					if_blocks[current_block_type_index].d(detaching);
				}
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_5.name,
			type: "if",
			source: "(74:2) {#if $modalManager}",
			ctx
		});

		return block;
	}

	// (79:72) 
	function create_if_block_8(ctx) {
		let groupdeletemodal;
		let current;
		groupdeletemodal = new GroupDeleteModal({ $$inline: true });

		const block = {
			c: function create() {
				create_component(groupdeletemodal.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(groupdeletemodal, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(groupdeletemodal.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(groupdeletemodal.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(groupdeletemodal, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_8.name,
			type: "if",
			source: "(79:72) ",
			ctx
		});

		return block;
	}

	// (77:73) 
	function create_if_block_7(ctx) {
		let folderdeletemodal;
		let current;
		folderdeletemodal = new FolderDeleteModal({ $$inline: true });

		const block = {
			c: function create() {
				create_component(folderdeletemodal.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(folderdeletemodal, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(folderdeletemodal.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(folderdeletemodal.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(folderdeletemodal, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_7.name,
			type: "if",
			source: "(77:73) ",
			ctx
		});

		return block;
	}

	// (75:3) {#if $DeleteConfirmationModal && $modalManager.type === "Credential"}
	function create_if_block_6(ctx) {
		let credentialdeletemodal;
		let current;
		credentialdeletemodal = new CredentialDeleteModal({ $$inline: true });

		const block = {
			c: function create() {
				create_component(credentialdeletemodal.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(credentialdeletemodal, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(credentialdeletemodal.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(credentialdeletemodal.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(credentialdeletemodal, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_6.name,
			type: "if",
			source: "(75:3) {#if $DeleteConfirmationModal && $modalManager.type === \\\"Credential\\\"}",
			ctx
		});

		return block;
	}

	// (83:2) {#if $accessListSelected && $selectedFolder}
	function create_if_block_4(ctx) {
		let accesslistmodal;
		let current;
		accesslistmodal = new AccessListModal({ $$inline: true });

		const block = {
			c: function create() {
				create_component(accesslistmodal.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(accesslistmodal, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(accesslistmodal.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(accesslistmodal.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(accesslistmodal, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_4.name,
			type: "if",
			source: "(83:2) {#if $accessListSelected && $selectedFolder}",
			ctx
		});

		return block;
	}

	// (86:2) {#if $showMoreGroupOptions}
	function create_if_block_3(ctx) {
		let moreactionsgroup;
		let current;
		moreactionsgroup = new MoreActionsGroup({ $$inline: true });

		const block = {
			c: function create() {
				create_component(moreactionsgroup.$$.fragment);
			},
			m: function mount(target, anchor) {
				mount_component(moreactionsgroup, target, anchor);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(moreactionsgroup.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(moreactionsgroup.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				destroy_component(moreactionsgroup, detaching);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_3.name,
			type: "if",
			source: "(86:2) {#if $showMoreGroupOptions}",
			ctx
		});

		return block;
	}

	// (89:2) {#if $toastStore.show}
	function create_if_block_2(ctx) {
		let div;
		let sharetoast;
		let current;
		sharetoast = new ShareToast({ $$inline: true });

		const block = {
			c: function create() {
				div = element("div");
				create_component(sharetoast.$$.fragment);
				attr_dev(div, "class", "z-100");
				add_location(div, file, 100, 3, 3391);
			},
			m: function mount(target, anchor) {
				insert_dev(target, div, anchor);
				mount_component(sharetoast, div, null);
				current = true;
			},
			i: function intro(local) {
				if (current) return;
				transition_in(sharetoast.$$.fragment, local);
				current = true;
			},
			o: function outro(local) {
				transition_out(sharetoast.$$.fragment, local);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(div);
				}

				destroy_component(sharetoast);
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_if_block_2.name,
			type: "if",
			source: "(89:2) {#if $toastStore.show}",
			ctx
		});

		return block;
	}

	function create_fragment(ctx) {
		let main;
		let current_block_type_index;
		let if_block;
		let current;
		const if_block_creators = [create_if_block, create_if_block_1, create_else_block];
		const if_blocks = [];

		function select_block_type(ctx, dirty) {
			if (!/*signedUp*/ ctx[1]) return 0;
			if (/*showWelcome*/ ctx[0]) return 1;
			return 2;
		}

		current_block_type_index = select_block_type(ctx);
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

		const block = {
			c: function create() {
				main = element("main");
				if_block.c();
				attr_dev(main, "class", "bg-osvauld-frameblack w-screen h-screen text-macchiato-text text-lg overflow-hidden !font-sans");
				add_location(main, file, 54, 0, 2078);
			},
			l: function claim(nodes) {
				throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
			},
			m: function mount(target, anchor) {
				insert_dev(target, main, anchor);
				if_blocks[current_block_type_index].m(main, null);
				current = true;
			},
			p: function update(ctx, [dirty]) {
				let previous_block_index = current_block_type_index;
				current_block_type_index = select_block_type(ctx);

				if (current_block_type_index === previous_block_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				} else {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(main, null);
				}
			},
			i: function intro(local) {
				if (current) return;
				transition_in(if_block);
				current = true;
			},
			o: function outro(local) {
				transition_out(if_block);
				current = false;
			},
			d: function destroy(detaching) {
				if (detaching) {
					detach_dev(main);
				}

				if_blocks[current_block_type_index].d();
			}
		};

		dispatch_dev("SvelteRegisterBlock", {
			block,
			id: create_fragment.name,
			type: "component",
			source: "",
			ctx
		});

		return block;
	}

	function instance($$self, $$props, $$invalidate) {
		let $showMoreOptions;
		let $promptPassword;
		let $modalManager;
		let $DeleteConfirmationModal;
		let $accessListSelected;
		let $selectedFolder;
		let $showMoreGroupOptions;
		let $toastStore;
		validate_store(showMoreOptions, 'showMoreOptions');
		component_subscribe($$self, showMoreOptions, $$value => $$invalidate(2, $showMoreOptions = $$value));
		validate_store(promptPassword, 'promptPassword');
		component_subscribe($$self, promptPassword, $$value => $$invalidate(3, $promptPassword = $$value));
		validate_store(modalManager, 'modalManager');
		component_subscribe($$self, modalManager, $$value => $$invalidate(4, $modalManager = $$value));
		validate_store(DeleteConfirmationModal, 'DeleteConfirmationModal');
		component_subscribe($$self, DeleteConfirmationModal, $$value => $$invalidate(5, $DeleteConfirmationModal = $$value));
		validate_store(accessListSelected, 'accessListSelected');
		component_subscribe($$self, accessListSelected, $$value => $$invalidate(6, $accessListSelected = $$value));
		validate_store(selectedFolder, 'selectedFolder');
		component_subscribe($$self, selectedFolder, $$value => $$invalidate(7, $selectedFolder = $$value));
		validate_store(showMoreGroupOptions, 'showMoreGroupOptions');
		component_subscribe($$self, showMoreGroupOptions, $$value => $$invalidate(8, $showMoreGroupOptions = $$value));
		validate_store(toastStore, 'toastStore');
		component_subscribe($$self, toastStore, $$value => $$invalidate(9, $toastStore = $$value));
		let { $$slots: slots = {}, $$scope } = $$props;
		validate_slots('Dashboard', slots, []);
		let showWelcome = false;
		let signedUp = true;

		onMount(async () => {
			const response = await sendMessage("isSignedUp");
			const checkPvtLoad = await sendMessage("checkPvtLoaded");
			$$invalidate(1, signedUp = response.isSignedUp);

			if (checkPvtLoad === false) {
				$$invalidate(0, showWelcome = true);
			} else {
				await setFolderStore();
			}
		});

		const handleSignedUp = () => {
			$$invalidate(1, signedUp = true);
			$$invalidate(0, showWelcome = false);
		};

		const handleAuthenticated = async () => {
			const user = await getUser();
			LocalStorageService.set("user", user.data, true);
			await setFolderStore();
			$$invalidate(0, showWelcome = false);
		};

		const writable_props = [];

		Object.keys($$props).forEach(key => {
			if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dashboard> was created with unknown prop '${key}'`);
		});

		$$self.$capture_state = () => ({
			onMount,
			LeftContainer,
			RightContainer,
			MoreActions,
			CredentialDeleteModal,
			FolderDeleteModal,
			showMoreOptions,
			DeleteConfirmationModal,
			modalManager,
			accessListSelected,
			showMoreGroupOptions,
			toastStore,
			promptPassword,
			sendMessage,
			Welcome,
			Signup,
			getUser,
			AccessListModal,
			MoreActionsGroup,
			GroupDeleteModal,
			ShareToast,
			setFolderStore,
			selectedFolder,
			LocalStorageService,
			PasswordPromptModal,
			showWelcome,
			signedUp,
			handleSignedUp,
			handleAuthenticated,
			$showMoreOptions,
			$promptPassword,
			$modalManager,
			$DeleteConfirmationModal,
			$accessListSelected,
			$selectedFolder,
			$showMoreGroupOptions,
			$toastStore
		});

		$$self.$inject_state = $$props => {
			if ('showWelcome' in $$props) $$invalidate(0, showWelcome = $$props.showWelcome);
			if ('signedUp' in $$props) $$invalidate(1, signedUp = $$props.signedUp);
		};

		if ($$props && "$$inject" in $$props) {
			$$self.$inject_state($$props.$$inject);
		}

		return [
			showWelcome,
			signedUp,
			$showMoreOptions,
			$promptPassword,
			$modalManager,
			$DeleteConfirmationModal,
			$accessListSelected,
			$selectedFolder,
			$showMoreGroupOptions,
			$toastStore,
			handleSignedUp,
			handleAuthenticated
		];
	}

	class Dashboard extends SvelteComponentDev {
		constructor(options) {
			super(options);
			init(this, options, instance, create_fragment, safe_not_equal, {});

			dispatch_dev("SvelteRegisterComponent", {
				component: this,
				tagName: "Dashboard",
				options,
				id: create_fragment.name
			});
		}
	}

	const app = new Dashboard({
	    target: document.body,
	});

	return app;

})();
//# sourceMappingURL=dashboard.js.map
